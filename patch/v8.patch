diff --git a/BUILD.gn b/BUILD.gn
index 83f1fdb..f02ad45 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -2125,6 +2125,8 @@ v8_source_set("v8_base") {
     "src/interpreter/constant-array-builder.h",
     "src/interpreter/control-flow-builders.cc",
     "src/interpreter/control-flow-builders.h",
+    "src/interpreter/global_ids.cc",
+    "src/interpreter/global_ids.h",
     "src/interpreter/handler-table-builder.cc",
     "src/interpreter/handler-table-builder.h",
     "src/interpreter/interpreter-generator.h",
@@ -2304,12 +2306,20 @@ v8_source_set("v8_base") {
     "src/optimized-compilation-info.h",
     "src/ostreams.cc",
     "src/ostreams.h",
+    "src/parsing/asglogs-generator.cc",
+    "src/parsing/asglogs-generator.h",
     "src/parsing/duplicate-finder.h",
     "src/parsing/expression-classifier.h",
+    "src/parsing/expression-converter.cc",
+    "src/parsing/expression-converter.h",
+    "src/parsing/expression-printer.cc",
+    "src/parsing/expression-printer.h",
     "src/parsing/expression-scope-reparenter.cc",
     "src/parsing/expression-scope-reparenter.h",
     "src/parsing/func-name-inferrer.cc",
     "src/parsing/func-name-inferrer.h",
+    "src/parsing/global_maps.cc",
+    "src/parsing/global_maps.h",
     "src/parsing/parse-info.cc",
     "src/parsing/parse-info.h",
     "src/parsing/parser-base.h",
diff --git a/include/v8.h b/include/v8.h
index a4bbe1b..14bc74d 100644
--- a/include/v8.h
+++ b/include/v8.h
@@ -22,6 +22,9 @@
 #include <utility>
 #include <vector>
 
+#include <string>
+#include <sstream>
+
 #include "v8-internal.h"  // NOLINT(build/include)
 #include "v8-version.h"   // NOLINT(build/include)
 #include "v8config.h"     // NOLINT(build/include)
@@ -1414,6 +1417,8 @@ class V8_EXPORT ScriptCompiler {
   class V8_EXPORT ScriptStreamingTask final {
    public:
     void Run();
+    void set_script_url(std::string str) {script_url_ = str;}
+    std::string script_url() {return script_url_;}
 
    private:
     friend class ScriptCompiler;
@@ -1422,6 +1427,7 @@ class V8_EXPORT ScriptCompiler {
         : data_(data) {}
 
     internal::ScriptStreamingData* data_;
+    std::string script_url_;
   };
 
   enum CompileOptions {
diff --git a/src/api-arguments-inl.h b/src/api-arguments-inl.h
index 1e5d6b2..80b489f 100644
--- a/src/api-arguments-inl.h
+++ b/src/api-arguments-inl.h
@@ -122,6 +122,7 @@ FOR_EACH_CALLBACK(CREATE_INDEXED_CALLBACK)
 #undef CREATE_INDEXED_CALLBACK
 
 Handle<Object> FunctionCallbackArguments::Call(CallHandlerInfo* handler) {
+
   Isolate* isolate = this->isolate();
   LOG(isolate, ApiObjectAccess("call", holder()));
   RuntimeCallTimerScope timer(isolate, RuntimeCallCounterId::kFunctionCallback);
diff --git a/src/api.cc b/src/api.cc
index 3f62a23..fbe2bbd 100644
--- a/src/api.cc
+++ b/src/api.cc
@@ -2,7 +2,10 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include <fstream>
+
 #include "src/api.h"
+#include "src/parsing/global_maps.h"
 
 #include <string.h>  // For memcpy, strlen.
 #include <cmath>     // For isnan.
@@ -97,6 +100,7 @@
 #include "src/wasm/wasm-result.h"
 #include "src/wasm/wasm-serialization.h"
 
+
 namespace v8 {
 
 /*
@@ -2353,21 +2357,25 @@ MaybeLocal<UnboundScript> ScriptCompiler::CompileUnboundInternal(
   }
 
   i::Handle<i::String> str = Utils::OpenHandle(*(source->source_string));
+
   i::Handle<i::SharedFunctionInfo> result;
   TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT("v8.compile"), "V8.CompileScript");
   i::Compiler::ScriptDetails script_details = GetScriptDetails(
       isolate, source->resource_name, source->resource_line_offset,
       source->resource_column_offset, source->source_map_url,
       source->host_defined_options);
+
   i::MaybeHandle<i::SharedFunctionInfo> maybe_function_info =
       i::Compiler::GetSharedFunctionInfoForScript(
           isolate, str, script_details, source->resource_options, nullptr,
-          script_data, options, no_cache_reason, i::NOT_NATIVES_CODE);
+          script_data, options, no_cache_reason, i::NOT_NATIVES_CODE);  
+  
   if (options == kConsumeCodeCache) {
     source->cached_data->rejected = script_data->rejected();
   }
   delete script_data;
   has_pending_exception = !maybe_function_info.ToHandle(&result);
+
   RETURN_ON_FAILED_EXECUTION(UnboundScript);
   RETURN_ESCAPED(ToApiHandle<UnboundScript>(result));
 }
@@ -2527,7 +2535,7 @@ MaybeLocal<Function> ScriptCompiler::CompileFunctionInContext(
   RETURN_ESCAPED(Utils::CallableToLocal(result));
 }
 
-void ScriptCompiler::ScriptStreamingTask::Run() { data_->task->Run(); }
+void ScriptCompiler::ScriptStreamingTask::Run() { std::string str = this->script_url(); data_->task->set_script_url(str); data_->task->Run(); }
 
 ScriptCompiler::ScriptStreamingTask* ScriptCompiler::StartStreamingScript(
     Isolate* v8_isolate, StreamedSource* source, CompileOptions options) {
@@ -2572,6 +2580,7 @@ MaybeLocal<Script> ScriptCompiler::Compile(Local<Context> context,
   RETURN_ON_FAILED_EXECUTION(Script);
 
   Local<UnboundScript> generic = ToApiHandle<UnboundScript>(result);
+
   if (generic.IsEmpty()) return Local<Script>();
   Local<Script> bound = generic->BindToCurrentContext();
   if (bound.IsEmpty()) return Local<Script>();
@@ -4823,7 +4832,7 @@ MaybeLocal<Value> v8::Object::GetRealNamedProperty(Local<Context> context,
   i::LookupIterator it = i::LookupIterator::PropertyOrElement(
       isolate, self, key_obj, self,
       i::LookupIterator::PROTOTYPE_CHAIN_SKIP_INTERCEPTOR);
-  Local<Value> result;
+  Local<Value> result;  
   has_pending_exception = !ToLocal<Value>(i::Object::GetProperty(&it), &result);
   RETURN_ON_FAILED_EXECUTION(Value);
   if (!it.IsFound()) return MaybeLocal<Value>();
diff --git a/src/asmjs/asm-js.cc b/src/asmjs/asm-js.cc
index aea4c0a..617e2f6 100644
--- a/src/asmjs/asm-js.cc
+++ b/src/asmjs/asm-js.cc
@@ -203,7 +203,7 @@ class AsmJsCompilationJob final : public UnoptimizedCompilationJob {
         translate_zone_size_(0) {}
 
  protected:
-  Status ExecuteJobImpl() final;
+  Status ExecuteJobImpl(bool should_inject = true) final;
   Status FinalizeJobImpl(Handle<SharedFunctionInfo> shared_info,
                          Isolate* isolate) final;
 
@@ -226,7 +226,7 @@ class AsmJsCompilationJob final : public UnoptimizedCompilationJob {
   DISALLOW_COPY_AND_ASSIGN(AsmJsCompilationJob);
 };
 
-UnoptimizedCompilationJob::Status AsmJsCompilationJob::ExecuteJobImpl() {
+UnoptimizedCompilationJob::Status AsmJsCompilationJob::ExecuteJobImpl(bool should_inject) {
   // Step 1: Translate asm.js module to WebAssembly module.
   size_t compile_zone_start = compilation_info()->zone()->allocation_size();
   base::ElapsedTimer translate_timer;
diff --git a/src/ast/ast.cc b/src/ast/ast.cc
index 617a26b..1434ccb 100644
--- a/src/ast/ast.cc
+++ b/src/ast/ast.cc
@@ -216,6 +216,10 @@ Assignment::Assignment(NodeType node_type, Token::Value op, Expression* target,
                        Expression* value, int pos)
     : Expression(pos, node_type), target_(target), value_(value) {
   bit_field_ |= TokenField::encode(op);
+  typeof_expr_ = nullptr;
+  decomposed_new_target_ = nullptr;
+  should_start_log_ = false;
+  force_not_start_log_ = false;
 }
 
 void FunctionLiteral::set_inferred_name(Handle<String> inferred_name) {
@@ -307,7 +311,7 @@ ObjectLiteralProperty::ObjectLiteralProperty(Expression* key, Expression* value,
                                              Kind kind, bool is_computed_name)
     : LiteralProperty(key, value, is_computed_name),
       kind_(kind),
-      emit_store_(true) {}
+      emit_store_(true) {allocated_temp_var_ = std::string("");}
 
 ObjectLiteralProperty::ObjectLiteralProperty(AstValueFactory* ast_value_factory,
                                              Expression* key, Expression* value,
diff --git a/src/ast/ast.h b/src/ast/ast.h
index 6cc2cbc..5c56ceb 100644
--- a/src/ast/ast.h
+++ b/src/ast/ast.h
@@ -6,6 +6,8 @@
 #define V8_AST_AST_H_
 
 #include <memory>
+#include "src/parsing/global_maps.h"
+#include "src/interpreter/global_ids.h"
 
 #include "src/ast/ast-value-factory.h"
 #include "src/ast/modules.h"
@@ -16,6 +18,7 @@
 #include "src/isolate.h"
 #include "src/label.h"
 #include "src/objects/literal-objects.h"
+#include "src/parsing/parse-info.h"
 #include "src/parsing/token.h"
 #include "src/runtime/runtime.h"
 
@@ -178,9 +181,31 @@ class Statement : public AstNode {
  public:
   bool IsEmpty() { return AsEmptyStatement() != nullptr; }
   bool IsJump() const;
+  std::string allocated_temp_var() {return allocated_temp_var_;}
+  void set_allocated_temp_var(std::string tmp) {allocated_temp_var_ = tmp;}
+  std::string allocated_temp_var_for_asg() {return allocated_temp_var_for_asg_;}
+  void set_allocated_temp_var_for_asg(std::string tmp) {allocated_temp_var_for_asg_ = tmp;}
+  std::list<Expression*> asglog_calls() {return asglog_calls_;}
+  void append_asglog_call(Expression* expr) {asglog_calls_.push_back(expr);}
+  void clear_asglog_calls() {asglog_calls_.clear();}
+  bool should_start_log() {return should_start_log_;}
+  void set_should_start_log(bool flag) {should_start_log_ = flag;}
+  bool is_child() {return is_child_;}
+  void set_is_child(bool flag) {is_child_ = flag;}
+  bool should_inject() {return should_inject_;}
+  void set_should_inject(bool flag) {should_inject_ = flag;}
+
 
  protected:
-  Statement(int position, NodeType type) : AstNode(position, type) {}
+  Statement(int position, NodeType type) : AstNode(position, type) {allocated_temp_var_ = std::string(""); allocated_temp_var_for_asg_ = std::string(""); asglog_calls_.clear(); should_start_log_ = false; is_child_ = false;  should_inject_ = true;}
+
+  std::string allocated_temp_var_;
+  std::string allocated_temp_var_for_asg_;
+  std::list<Expression*> asglog_calls_;
+  bool should_start_log_;
+  bool is_child_;
+  bool should_inject_;
+
 
   static const uint8_t kNextBitFieldIndex = AstNode::kNextBitFieldIndex;
 };
@@ -192,7 +217,7 @@ class Expression : public AstNode {
     // Not assigned a context yet, or else will not be visited during
     // code generation.
     kUninitialized,
-    // Evaluated for its side effects.
+    // Evaluated for its side effects.    
     kEffect,
     // Evaluated for its value (and side effects).
     kValue,
@@ -243,10 +268,55 @@ class Expression : public AstNode {
 
   bool IsCompileTimeValue();
 
+  //Expression* temp_var() {return temp_var_;}
+  //void set_temp_var(Expression* var) {temp_var_ = var;}
+  bool has_temp_var() {return has_temp_var_;}
+  void set_has_temp_var(bool flag) {has_temp_var_ = flag;}
+  std::string allocated_temp_var() {return allocated_temp_var_;}
+  void set_allocated_temp_var(std::string tmp) {allocated_temp_var_ = tmp;}
+  std::string allocated_temp_var_for_asg() {return allocated_temp_var_for_asg_;}
+  void set_allocated_temp_var_for_asg(std::string tmp) {allocated_temp_var_for_asg_ = tmp;}
+  bool has_logged() {return has_logged_;}
+  void set_has_logged(bool flag) {has_logged_=flag;}
+  bool should_set_has_logged() {return should_set_has_logged_;}
+  void set_should_set_has_logged(bool flag) {should_set_has_logged_ = flag;}
+  bool temp_var_from_new() {return temp_var_from_new_;}
+  void set_temp_var_from_new(bool flag) {temp_var_from_new_ = flag;}
+  bool should_start_log() {return should_start_log_;}
+  void set_should_start_log(bool flag) {should_start_log_ = flag;}
+  std::list<Expression*> asglog_calls() {return asglog_calls_;}
+  void append_asglog_call(Expression* call) {asglog_calls_.push_back(call);}
+  void clear_asglog_calls() {asglog_calls_.clear();}
+  bool should_inject() {return should_inject_;}
+  void set_should_inject(bool flag) {should_inject_ = flag;}
+  bool is_child() {return is_child_;}
+  void set_is_child(bool flag) {is_child_ = flag;}
+  std::string rhs_string() {return rhs_string_;}
+  void set_rhs_string(std::string str) {rhs_string_ = str;}
+  bool should_break() {return should_break_;}
+  void set_should_break(bool flag) {should_break_ = flag;}
+  
  protected:
-  Expression(int pos, NodeType type) : AstNode(pos, type) {}
+  Expression(int pos, NodeType type) : AstNode(pos, type) {
+    has_temp_var_=false; allocated_temp_var_ = std::string(""); allocated_temp_var_for_asg_ = std::string(""); has_logged_ = false; should_set_has_logged_ = true; temp_var_from_new_ = false; 
+    should_start_log_ = false; asglog_calls_.clear(); should_inject_ = true; is_child_ = false; rhs_string_ = std::string(""); should_break_=true;
+  } 
 
   static const uint8_t kNextBitFieldIndex = AstNode::kNextBitFieldIndex;
+
+  //Expression* temp_var_;
+  bool has_temp_var_;
+  std::string allocated_temp_var_;
+  std::string allocated_temp_var_for_asg_;
+  bool has_logged_;
+  bool should_set_has_logged_;
+  bool temp_var_from_new_;
+  bool should_start_log_;
+  bool should_break_;
+  std::list<Expression*> asglog_calls_;
+  bool should_inject_;
+  bool is_child_;
+  std::string rhs_string_;
 };
 
 // V8's notion of BreakableStatement does not correspond to the notion of
@@ -757,6 +827,8 @@ class ReturnStatement final : public JumpStatement {
 
   int end_position() const { return end_position_; }
 
+  void set_expression(Expression* expr) {expression_ = expr;}
+
  private:
   friend class AstNodeFactory;
 
@@ -1095,43 +1167,54 @@ class Literal final : public Expression {
   uint32_t Hash();
   static bool Match(void* literal1, void* literal2);
 
+
+  bool quote() {return quote_;}
+  void set_quote(bool quote) {quote_ = quote;}
+
  private:
   friend class AstNodeFactory;
 
   class TypeField : public BitField<Type, Expression::kNextBitFieldIndex, 4> {};
 
-  Literal(int smi, int position) : Expression(position, kLiteral), smi_(smi) {
+  Literal(int smi, int position, bool quote=false) : Expression(position, kLiteral), smi_(smi) {
     bit_field_ = TypeField::update(bit_field_, kSmi);
+    quote_ = quote;
   }
 
-  Literal(double number, int position)
+  Literal(double number, int position, bool quote=false)
       : Expression(position, kLiteral), number_(number) {
     bit_field_ = TypeField::update(bit_field_, kHeapNumber);
+    quote_ = quote;
   }
 
-  Literal(AstBigInt bigint, int position)
+  Literal(AstBigInt bigint, int position, bool quote=false)
       : Expression(position, kLiteral), bigint_(bigint) {
     bit_field_ = TypeField::update(bit_field_, kBigInt);
+    quote_ = quote;
   }
 
-  Literal(const AstRawString* string, int position)
+  Literal(const AstRawString* string, int position, bool quote=false)
       : Expression(position, kLiteral), string_(string) {
     bit_field_ = TypeField::update(bit_field_, kString);
+    quote_ = quote;
   }
 
-  Literal(AstSymbol symbol, int position)
+  Literal(AstSymbol symbol, int position, bool quote=false)
       : Expression(position, kLiteral), symbol_(symbol) {
     bit_field_ = TypeField::update(bit_field_, kSymbol);
+    quote_ = quote;
   }
 
-  Literal(bool boolean, int position)
+  Literal(bool boolean, int position, bool quote=false)
       : Expression(position, kLiteral), boolean_(boolean) {
     bit_field_ = TypeField::update(bit_field_, kBoolean);
+    quote_ = quote;
   }
 
-  Literal(Type type, int position) : Expression(position, kLiteral) {
+  Literal(Type type, int position, bool quote=false) : Expression(position, kLiteral) {
     DCHECK(type == kNull || type == kUndefined || type == kTheHole);
     bit_field_ = TypeField::update(bit_field_, type);
+    quote_ = quote;
   }
 
   union {
@@ -1142,6 +1225,9 @@ class Literal final : public Expression {
     AstBigInt bigint_;
     bool boolean_;
   };
+
+  bool quote_;
+
 };
 
 // Base class for literals that need space in the type feedback vector.
@@ -1263,6 +1349,7 @@ class LiteralProperty : public ZoneObject {
  public:
   Expression* key() const { return key_; }
   Expression* value() const { return value_; }
+  void set_property_value(Expression* value) {value_ = value;}
 
   bool is_computed_name() const { return is_computed_name_; }
   bool NeedsSetFunctionName() const;
@@ -1302,6 +1389,10 @@ class ObjectLiteralProperty final : public LiteralProperty {
     return IsPrototype() && value()->IsNullLiteral();
   }
   bool IsPrototype() const { return kind() == PROTOTYPE; }
+  std::string allocated_temp_var() {return allocated_temp_var_;}
+  std::string allocated_temp_var_for_asg() {return allocated_temp_var_for_asg_;}
+  void set_allocated_temp_var(std::string tmp) {allocated_temp_var_ = tmp;}
+  void set_allocated_temp_var_for_asg(std::string tmp) {allocated_temp_var_for_asg_ = tmp;}
 
  private:
   friend class AstNodeFactory;
@@ -1313,6 +1404,8 @@ class ObjectLiteralProperty final : public LiteralProperty {
 
   Kind kind_;
   bool emit_store_;
+  std::string allocated_temp_var_;
+  std::string allocated_temp_var_for_asg_;
 };
 
 
@@ -1399,6 +1492,11 @@ class ObjectLiteral final : public AggregateLiteral {
     ObjectLiteralProperty* setter;
   };
 
+  const AstRawString* print_name() {return print_name_;}
+  void set_print_name(const AstRawString* name) {print_name_ = name;}
+  bool has_print_name() {return has_print_name_;}
+  void set_has_print_name(bool flag) {has_print_name_ = flag;}
+
  private:
   friend class AstNodeFactory;
 
@@ -1412,6 +1510,7 @@ class ObjectLiteral final : public AggregateLiteral {
                   HasRestPropertyField::encode(has_rest_property) |
                   FastElementsField::encode(false) |
                   HasNullPrototypeField::encode(false);
+    has_print_name_ = false;
   }
 
   void InitFlagsForPendingNullPrototype(int i);
@@ -1429,6 +1528,8 @@ class ObjectLiteral final : public AggregateLiteral {
   uint32_t boilerplate_properties_;
   Handle<ObjectBoilerplateDescription> boilerplate_description_;
   ZoneList<Property*>* properties_;
+  const AstRawString* print_name_;
+  bool has_print_name_;
 
   class HasElementsField
       : public BitField<bool, AggregateLiteral::kNextBitFieldIndex, 1> {};
@@ -1706,6 +1807,9 @@ class Call final : public Expression {
     return !arguments_->is_empty() && arguments_->last()->IsSpread();
   }
 
+  bool should_inject_mark() {return should_inject_mark_;}
+  void set_should_inject_mark(bool flag) {should_inject_mark_=flag;}
+
   enum CallType {
     GLOBAL_CALL,
     WITH_CALL,
@@ -1737,6 +1841,7 @@ class Call final : public Expression {
     bit_field_ |=
         IsPossiblyEvalField::encode(possibly_eval == IS_POSSIBLY_EVAL) |
         IsTaggedTemplateField::encode(false);
+    should_inject_mark_ = true;
   }
 
   Call(Expression* expression, ZonePtrList<Expression>* arguments, int pos,
@@ -1753,6 +1858,7 @@ class Call final : public Expression {
 
   Expression* expression_;
   ZonePtrList<Expression>* arguments_;
+  bool should_inject_mark_;
 };
 
 
@@ -1765,6 +1871,7 @@ class CallNew final : public Expression {
     return !arguments_->is_empty() && arguments_->last()->IsSpread();
   }
 
+
  private:
   friend class AstNodeFactory;
 
@@ -2026,6 +2133,9 @@ class Conditional final : public Expression {
   Expression* then_expression() const { return then_expression_; }
   Expression* else_expression() const { return else_expression_; }
 
+  void set_then_expression(Expression* then) {then_expression_ = then;}
+  void set_else_expression(Expression* expr) {else_expression_ = expr;}
+
  private:
   friend class AstNodeFactory;
 
@@ -2047,6 +2157,16 @@ class Assignment : public Expression {
   Expression* target() const { return target_; }
   Expression* value() const { return value_; }
 
+  void set_target(Expression* target) {target_ = target;}
+  void set_value(Expression* value) {value_ = value;}
+  Expression* expr_for_typeof() {return typeof_expr_;}
+  void set_expr_for_typeof(Expression* typeof_expr) {typeof_expr_ = typeof_expr;}
+  void set_op(Token::Value op) {bit_field_ |= TokenField::encode(op);}
+  bool force_not_start_log() {return force_not_start_log_;}
+  void set_force_not_start_log(bool flag) {force_not_start_log_ = flag;}
+  void set_decomposed_new_target(Expression* expr) {decomposed_new_target_ = expr;}
+  Expression* decomposed_new_target() {return decomposed_new_target_;}
+
   // The assignment was generated as part of block-scoped sloppy-mode
   // function hoisting, see
   // ES#sec-block-level-function-declarations-web-legacy-compatibility-semantics
@@ -2073,11 +2193,16 @@ class Assignment : public Expression {
 
   Expression* target_;
   Expression* value_;
+  Expression* typeof_expr_;
+  Expression* decomposed_new_target_;
+  bool force_not_start_log_;
 };
 
 class CompoundAssignment final : public Assignment {
  public:
   BinaryOperation* binary_operation() const { return binary_operation_; }
+  bool force_to_asg() {return force_to_asg_;}
+  void set_force_to_asg(bool force_to_asg) {force_to_asg_ = force_to_asg;}
 
  private:
   friend class AstNodeFactory;
@@ -2085,9 +2210,12 @@ class CompoundAssignment final : public Assignment {
   CompoundAssignment(Token::Value op, Expression* target, Expression* value,
                      int pos, BinaryOperation* binary_operation)
       : Assignment(kCompoundAssignment, op, target, value, pos),
-        binary_operation_(binary_operation) {}
+        binary_operation_(binary_operation) {
+          force_to_asg_ = false;
+        }
 
   BinaryOperation* binary_operation_;
+  bool force_to_asg_;
 };
 
 // The RewritableExpression class is a wrapper for AST nodes that wait
@@ -2356,6 +2484,11 @@ class FunctionLiteral final : public Expression {
     function_literal_id_ = function_literal_id;
   }
 
+  int script_id() {return script_id_;}
+  Object* script_url() {return script_url_;}
+  std::string script_url_str() {return script_url_str_;}
+  MaybeHandle<ScopeInfo> maybe_outer_scope_info() {return maybe_outer_scope_info_;}
+
   void set_requires_instance_fields_initializer(bool value) {
     bit_field_ = RequiresInstanceFieldsInitializer::update(bit_field_, value);
   }
@@ -2367,6 +2500,14 @@ class FunctionLiteral final : public Expression {
     return produced_preparsed_scope_data_;
   }
 
+  int function_id() { return function_id_; }
+  void set_function_id(int id) {function_id_ = id;}
+  std::list<Expression*> asglog_calls() {return asglog_calls_;}
+  void append_asglog_call(Expression* expr) {asglog_calls_.push_back(expr);}
+  void clear_asglog_calls() {asglog_calls_.clear();}
+  bool has_injected() {return has_injected_;}
+  void set_has_injected(bool flag) {has_injected_ = flag;}
+
  private:
   friend class AstNodeFactory;
 
@@ -2377,7 +2518,7 @@ class FunctionLiteral final : public Expression {
       FunctionType function_type, ParameterFlag has_duplicate_parameters,
       EagerCompileHint eager_compile_hint, int position, bool has_braces,
       int function_literal_id,
-      ProducedPreParsedScopeData* produced_preparsed_scope_data = nullptr)
+      ProducedPreParsedScopeData* produced_preparsed_scope_data = nullptr, ParseInfo* info=nullptr)
       : Expression(position, kFunctionLiteral),
         expected_property_count_(expected_property_count),
         parameter_count_(parameter_count),
@@ -2385,11 +2526,25 @@ class FunctionLiteral final : public Expression {
         function_token_position_(kNoSourcePosition),
         suspend_count_(0),
         function_literal_id_(function_literal_id),
+        script_id_(info ? info->script_id() : -1),
+        script_url_str_(info ? info->script_url() : ""),
+        maybe_outer_scope_info_(info ? info->maybe_outer_scope_info() : MaybeHandle<ScopeInfo>()),
+        has_injected_(false),
         raw_name_(name ? ast_value_factory->NewConsString(name) : nullptr),
         scope_(scope),
         body_(body),
         raw_inferred_name_(ast_value_factory->empty_cons_string()),
         produced_preparsed_scope_data_(produced_preparsed_scope_data) {
+
+    if(info && info->script().location()) {
+      script_url_ = info->script()->name();
+    }
+    else
+      script_url_ = nullptr;
+    asglog_calls_.clear();
+
+    function_id_ = ++functionID;
+
     bit_field_ |= FunctionTypeBits::encode(function_type) |
                   Pretenure::encode(false) |
                   HasDuplicateParameters::encode(has_duplicate_parameters ==
@@ -2420,6 +2575,17 @@ class FunctionLiteral final : public Expression {
   int suspend_count_;
   int function_literal_id_;
 
+  // added for script-isolation project
+  const int script_id_;
+  Object* script_url_;
+  std::string script_url_str_;
+  MaybeHandle<ScopeInfo> maybe_outer_scope_info_;
+
+  int function_id_; // this is a globally unique ID for each function literal
+  std::list<Expression*> asglog_calls_;
+  bool has_injected_;
+
+
   const AstConsString* raw_name_;
   DeclarationScope* scope_;
   ZonePtrList<Statement>* body_;
@@ -2994,8 +3160,8 @@ class AstNodeFactory final {
     return new (zone_) CaseClause(label, statements);
   }
 
-  Literal* NewStringLiteral(const AstRawString* string, int pos) {
-    return new (zone_) Literal(string, pos);
+  Literal* NewStringLiteral(const AstRawString* string, int pos, bool quote=false) {
+    return new (zone_) Literal(string, pos, quote);
   }
 
   // A JavaScript symbol (ECMA-262 edition 6).
@@ -3097,6 +3263,7 @@ class AstNodeFactory final {
 
   Call* NewCall(Expression* expression, ZonePtrList<Expression>* arguments,
                 int pos, Call::PossiblyEval possibly_eval = Call::NOT_EVAL) {
+
     return new (zone_) Call(expression, arguments, pos, possibly_eval);
   }
 
@@ -3192,15 +3359,17 @@ class AstNodeFactory final {
       target->AsVariableProxy()->set_is_assigned();
     }
 
+    Assignment* asg;
     if (op == Token::ASSIGN || op == Token::INIT) {
-      return new (zone_)
+      asg = new (zone_)
           Assignment(AstNode::kAssignment, op, target, value, pos);
     } else {
-      return new (zone_) CompoundAssignment(
+      asg = new (zone_) CompoundAssignment(
           op, target, value, pos,
           NewBinaryOperation(Token::BinaryOpForAssignment(op), target, value,
                              pos + 1));
     }
+    return asg;
   }
 
   Suspend* NewYield(Expression* expression, int pos,
@@ -3231,12 +3400,12 @@ class AstNodeFactory final {
       FunctionLiteral::FunctionType function_type,
       FunctionLiteral::EagerCompileHint eager_compile_hint, int position,
       bool has_braces, int function_literal_id,
-      ProducedPreParsedScopeData* produced_preparsed_scope_data = nullptr) {
+      ProducedPreParsedScopeData* produced_preparsed_scope_data = nullptr, ParseInfo* info=nullptr) {
     return new (zone_) FunctionLiteral(
         zone_, name, ast_value_factory_, scope, body, expected_property_count,
         parameter_count, function_length, function_type,
         has_duplicate_parameters, eager_compile_hint, position, has_braces,
-        function_literal_id, produced_preparsed_scope_data);
+        function_literal_id, produced_preparsed_scope_data, info);
   }
 
   // Creates a FunctionLiteral representing a top-level script, the
diff --git a/src/ast/scopes.cc b/src/ast/scopes.cc
index e9fb195..d22729d 100644
--- a/src/ast/scopes.cc
+++ b/src/ast/scopes.cc
@@ -406,7 +406,14 @@ Scope* Scope::DeserializeScopeChain(Isolate* isolate, Zone* zone,
   Scope* current_scope = nullptr;
   Scope* innermost_scope = nullptr;
   Scope* outer_scope = nullptr;
+
+  std::list<std::string> direct_outer_declared_vars;
+
   while (scope_info) {
+    for(int i=0; i<scope_info->ContextLocalCount(); i++) {
+      direct_outer_declared_vars.push_back(std::string(scope_info->ContextLocalName(i)->ToCString().get()));
+    }
+
     if (scope_info->scope_type() == WITH_SCOPE) {
       // For scope analysis, debug-evaluate is equivalent to a with scope.
       outer_scope =
@@ -457,6 +464,10 @@ Scope* Scope::DeserializeScopeChain(Isolate* isolate, Zone* zone,
           Scope(zone, ast_value_factory->GetString(handle(name, isolate)),
                 maybe_assigned, handle(scope_info, isolate));
     }
+
+    outer_scope->set_declared_vars(direct_outer_declared_vars);
+    direct_outer_declared_vars.clear();
+
     if (deserialization_mode == DeserializationMode::kScopesOnly) {
       outer_scope->scope_info_ = Handle<ScopeInfo>::null();
     }
@@ -595,6 +606,20 @@ void DeclarationScope::HoistSloppyBlockFunctions(AstNodeFactory* factory) {
         Assignment* assignment = factory->NewAssignment(
             Token::ASSIGN, NewUnresolved(factory, name),
             delegate->scope()->NewUnresolved(factory, name), kNoSourcePosition);
+
+        Scope* closure_scope = this;
+        while(closure_scope->outer_scope())
+          closure_scope = closure_scope->outer_scope();
+
+        gmutex.lock();
+        assign_id++;
+        std::string tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+        gmutex.unlock();
+        const AstRawString* tmp_token = factory->ast_value_factory()->GetOneByteString(tmp.c_str());
+        //AstNodeFactory ast_node_factory(info->GetOrCreateAstValueFactory(), info->zone());
+        closure_scope->NewUnresolved(factory, tmp_token);
+        assignment->set_allocated_temp_var(tmp);
+
         assignment->set_lookup_hoisting_mode(LookupHoistingMode::kLegacySloppy);
         Statement* statement =
             factory->NewExpressionStatement(assignment, kNoSourcePosition);
@@ -957,6 +982,9 @@ void Scope::ReplaceOuterScope(Scope* outer) {
   DCHECK_NOT_NULL(outer);
   DCHECK_NOT_NULL(outer_scope_);
   DCHECK(!already_resolved_);
+
+  outer->set_declared_vars(outer_scope_->declared_vars());
+
   outer_scope_->RemoveInnerScope(this);
   outer->AddInnerScope(this);
   outer_scope_ = outer;
@@ -1205,7 +1233,7 @@ Variable* Scope::DeclareVariable(
   // same variable if it is declared several times. This is not a
   // semantic issue, but it may be a performance issue since it may
   // lead to repeated DeclareEvalVar or DeclareEvalFunction calls.
-  decls_.Add(declaration);
+  decls_.Add(declaration);  
   proxy->BindTo(var);
   return var;
 }
@@ -1391,7 +1419,7 @@ int Scope::ContextChainLength(Scope* scope) const {
   int n = 0;
   for (const Scope* s = this; s != scope; s = s->outer_scope_) {
     DCHECK_NOT_NULL(s);  // scope must be in the scope chain
-    if (s->NeedsContext()) n++;
+    if (s->NeedsContext()) n++; 
   }
   return n;
 }
@@ -1831,6 +1859,7 @@ Variable* Scope::NonLocal(const AstRawString* name, VariableMode mode) {
 
 Variable* Scope::LookupRecursive(ParseInfo* info, VariableProxy* proxy,
                                  Scope* outer_scope_end) {
+
   DCHECK_NE(outer_scope_end, this);
   // Short-cut: whenever we find a debug-evaluate scope, just look everything up
   // dynamically. Debug-evaluate doesn't properly create scope info for the
@@ -1839,7 +1868,7 @@ Variable* Scope::LookupRecursive(ParseInfo* info, VariableProxy* proxy,
   // variables.
   // TODO(yangguo): Remove once debug-evaluate creates proper ScopeInfo for the
   // scopes in which it's evaluating.
-  if (is_debug_evaluate_scope_)
+  if (is_debug_evaluate_scope_) 
     return NonLocal(proxy->raw_name(), VariableMode::kDynamic);
 
   // Try to find the variable in this scope.
@@ -1853,7 +1882,7 @@ Variable* Scope::LookupRecursive(ParseInfo* info, VariableProxy* proxy,
   if (outer_scope_ == outer_scope_end) {
     // We may just be trying to find all free variables. In that case, don't
     // declare them in the outer scope.
-    if (!is_script_scope()) return nullptr;
+    if (!is_script_scope()) return nullptr; 
 
     if (proxy->is_private_field()) {
       info->pending_error_handler()->ReportMessageAt(
@@ -1869,7 +1898,6 @@ Variable* Scope::LookupRecursive(ParseInfo* info, VariableProxy* proxy,
   }
 
   DCHECK(!is_script_scope());
-
   var = outer_scope_->LookupRecursive(info, proxy, outer_scope_end);
 
   // The variable could not be resolved statically.
@@ -1928,6 +1956,24 @@ Variable* Scope::LookupRecursive(ParseInfo* info, VariableProxy* proxy,
   return var;
 }
 
+
+
+bool Scope::PublicResolveVariable(ParseInfo* info, VariableProxy* proxy) {
+  DCHECK(info->script_scope()->is_script_scope());
+  DCHECK(!proxy->is_resolved());
+
+  Variable* var = LookupRecursive(info, proxy, nullptr);
+  if (var == nullptr) {
+    DCHECK(proxy->is_private_field());  
+    return false;
+  }
+
+  ResolveTo(info, proxy, var);
+  return true;
+}
+
+
+
 bool Scope::ResolveVariable(ParseInfo* info, VariableProxy* proxy) {
   DCHECK(info->script_scope()->is_script_scope());
   DCHECK(!proxy->is_resolved());
@@ -1936,6 +1982,7 @@ bool Scope::ResolveVariable(ParseInfo* info, VariableProxy* proxy) {
     DCHECK(proxy->is_private_field());
     return false;
   }
+
   ResolveTo(info, proxy, var);
   return true;
 }
@@ -1953,7 +2000,7 @@ void UpdateNeedsHoleCheck(Variable* var, VariableProxy* proxy, Scope* scope) {
     // VariableMode::kVar bindings, either from var or function declarations),
     // but the variable they shadow might need a hole check, which we want to do
     // if we decide that no shadowing variable was dynamically introoduced.
-    DCHECK_EQ(kCreatedInitialized, var->initialization_flag());
+    DCHECK_EQ(kCreatedInitialized, var->initialization_flag());    
     return UpdateNeedsHoleCheck(var->local_if_not_shadowed(), proxy, scope);
   }
 
@@ -1984,7 +2031,7 @@ void UpdateNeedsHoleCheck(Variable* var, VariableProxy* proxy, Scope* scope) {
   //   switch (1) { case 0: let x = 2; case 1: f(x); }
   // The scope of the variable needs to be checked, in case the use is
   // in a sub-block which may be linear.
-  if (var->scope()->GetClosureScope() != scope->GetClosureScope()) {
+  if (var->scope()->GetClosureScope() != scope->GetClosureScope()) {    
     return SetNeedsHoleCheck(var, proxy);
   }
 
@@ -1994,7 +2041,8 @@ void UpdateNeedsHoleCheck(Variable* var, VariableProxy* proxy, Scope* scope) {
     return SetNeedsHoleCheck(var, proxy);
   }
 
-  // We should always have valid source positions.
+  // We should always have valid source positions.    
+
   DCHECK_NE(var->initializer_position(), kNoSourcePosition);
   DCHECK_NE(proxy->position(), kNoSourcePosition);
 
@@ -2006,6 +2054,39 @@ void UpdateNeedsHoleCheck(Variable* var, VariableProxy* proxy, Scope* scope) {
 
 }  // anonymous namespace
 
+
+
+
+void Scope::PublicResolveTo(ParseInfo* info, VariableProxy* proxy, Variable* var) {
+#ifdef DEBUG
+  if (info->is_native()) {
+    // To avoid polluting the global object in native scripts
+    //  - Variables must not be allocated to the global scope.
+    DCHECK_NOT_NULL(outer_scope());
+    //  - Variables must be bound locally or unallocated.
+    if (var->IsGlobalObjectProperty()) {
+      // The following variable name may be minified. If so, disable
+      // minification in js2c.py for better output.
+      Handle<String> name = proxy->raw_name()->string();
+      FATAL("Unbound variable: '%s' in native script.",
+            name->ToCString().get());
+    }
+    VariableLocation location = var->location();
+    DCHECK(location == VariableLocation::LOCAL ||
+           location == VariableLocation::CONTEXT ||
+           location == VariableLocation::PARAMETER ||
+           location == VariableLocation::UNALLOCATED);
+  }
+#endif
+
+  DCHECK_NOT_NULL(var);
+  UpdateNeedsHoleCheck(var, proxy, this);
+
+  proxy->BindTo(var);
+}
+
+
+
 void Scope::ResolveTo(ParseInfo* info, VariableProxy* proxy, Variable* var) {
 #ifdef DEBUG
   if (info->is_native()) {
@@ -2030,6 +2111,7 @@ void Scope::ResolveTo(ParseInfo* info, VariableProxy* proxy, Variable* var) {
 
   DCHECK_NOT_NULL(var);
   UpdateNeedsHoleCheck(var, proxy, this);
+
   proxy->BindTo(var);
 }
 
@@ -2067,6 +2149,8 @@ bool Scope::ResolveVariablesRecursively(ParseInfo* info) {
   return true;
 }
 
+
+
 bool Scope::MustAllocate(Variable* var) {
   if (var == kDummyPreParserLexicalVariable || var == kDummyPreParserVariable) {
     return true;
diff --git a/src/ast/scopes.h b/src/ast/scopes.h
index 0b88cc0..3f6152e 100644
--- a/src/ast/scopes.h
+++ b/src/ast/scopes.h
@@ -480,6 +480,23 @@ class V8_EXPORT_PRIVATE Scope : public NON_EXPORTED_BASE(ZoneObject) {
   static void* const kDummyPreParserVariable;
   static void* const kDummyPreParserLexicalVariable;
 
+
+  void PublicResolveTo(ParseInfo* info, VariableProxy* proxy, Variable* var);
+  V8_WARN_UNUSED_RESULT bool PublicResolveVariable(ParseInfo* info,
+                                             VariableProxy* proxy);
+
+  bool has_scope_info() { return !scope_info_.is_null(); }
+  void set_declared_vars(std::list<std::string> declared_vars) {
+    std::list<std::string>::iterator i;
+    for(i=declared_vars.begin(); i!=declared_vars.end(); ++i) {
+      declared_vars_.push_back(*i);
+    }
+  }
+  void append_declared_function_name(std::string func) {declared_function_names_.push_back(func);}
+  std::list<std::string> declared_vars() {return declared_vars_;}
+  std::list<std::string> declared_function_names() {return declared_function_names_;}
+
+
  protected:
   explicit Scope(Zone* zone);
 
@@ -636,6 +653,10 @@ class V8_EXPORT_PRIVATE Scope : public NON_EXPORTED_BASE(ZoneObject) {
 
   friend class DeclarationScope;
   friend class ScopeTestHelper;
+
+  std::list<std::string> declared_vars_;
+  std::list<std::string> declared_function_names_;
+
 };
 
 class V8_EXPORT_PRIVATE DeclarationScope : public Scope {
diff --git a/src/bootstrapper.cc b/src/bootstrapper.cc
index d910486..1f857ba 100644
--- a/src/bootstrapper.cc
+++ b/src/bootstrapper.cc
@@ -1257,6 +1257,7 @@ Handle<JSGlobalObject> Genesis::CreateNewGlobals(
 #ifdef DEBUG
     LookupIterator it(isolate(), prototype, factory()->constructor_string(),
                       LookupIterator::OWN_SKIP_INTERCEPTOR);
+
     Handle<Object> value = Object::GetProperty(&it).ToHandleChecked();
     DCHECK(it.IsFound());
     DCHECK_EQ(*isolate()->object_function(), *value);
@@ -1488,9 +1489,14 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     native_context()->set_object_define_properties(*object_define_properties);
 
     Handle<JSFunction> object_define_property = SimpleInstallFunction(
+        isolate_, object_function, "getGlobalId",
+        Builtins::kObjectGetGlobalId, 3, true);
+    native_context()->set_object_define_property(*object_define_property);
+
+    Handle<JSFunction> object_get_global_id = SimpleInstallFunction(
         isolate_, object_function, factory->defineProperty_string(),
         Builtins::kObjectDefineProperty, 3, true);
-    native_context()->set_object_define_property(*object_define_property);
+    native_context()->set_object_get_global_id(*object_get_global_id);
 
     SimpleInstallFunction(isolate_, object_function, "freeze",
                           Builtins::kObjectFreeze, 1, false);
@@ -3944,24 +3950,27 @@ bool Bootstrapper::CompileNative(Isolate* isolate, Vector<const char> name,
           isolate, source, Compiler::ScriptDetails(script_name),
           ScriptOriginOptions(), nullptr, nullptr,
           ScriptCompiler::kNoCompileOptions, ScriptCompiler::kNoCacheNoReason,
-          natives_flag);
+          natives_flag, false);
   Handle<SharedFunctionInfo> function_info;
   if (!maybe_function_info.ToHandle(&function_info)) return false;
-
+  
   DCHECK(context->IsNativeContext());
-
+  
   Handle<JSFunction> fun =
       isolate->factory()->NewFunctionFromSharedFunctionInfo(function_info,
-                                                            context);
+                                                            context);  
+  
   Handle<Object> receiver = isolate->factory()->undefined_value();
 
   // For non-extension scripts, run script to get the function wrapper.
   Handle<Object> wrapper;
   if (!Execution::TryCall(isolate, fun, receiver, 0, nullptr,
                           Execution::MessageHandling::kKeepPending, nullptr)
-           .ToHandle(&wrapper)) {
+           .ToHandle(&wrapper)) {  
+    
     return false;
-  }
+  }  
+  
   // Then run the function wrapper.
   return !Execution::TryCall(isolate, Handle<JSFunction>::cast(wrapper),
                              receiver, argc, argv,
diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h
index c47fa7b..fc5a7fd 100644
--- a/src/builtins/builtins-definitions.h
+++ b/src/builtins/builtins-definitions.h
@@ -808,6 +808,7 @@ namespace internal {
   CPP(ObjectDefineGetter)                                                      \
   CPP(ObjectDefineProperties)                                                  \
   CPP(ObjectDefineProperty)                                                    \
+  CPP(ObjectGetGlobalId)                                                       \
   CPP(ObjectDefineSetter)                                                      \
   TFJ(ObjectEntries, 1, kReceiver, kObject)                                    \
   CPP(ObjectFreeze)                                                            \
diff --git a/src/builtins/builtins-object.cc b/src/builtins/builtins-object.cc
index 7513f60..f7b165b 100644
--- a/src/builtins/builtins-object.cc
+++ b/src/builtins/builtins-object.cc
@@ -56,6 +56,13 @@ BUILTIN(ObjectDefineProperty) {
   return JSReceiver::DefineProperty(isolate, target, key, attributes);
 }
 
+BUILTIN(ObjectGetGlobalId) {
+  HandleScope scope(isolate);
+  DCHECK_EQ(1, args.length());
+  Handle<Object> target = args.at(1);
+  RETURN_RESULT_OR_FAILURE(isolate, JSReceiver::GetGlobalId(isolate, target));
+}
+
 namespace {
 
 template <AccessorComponent which_accessor>
diff --git a/src/compiler.cc b/src/compiler.cc
index 7cb8a45..11d2798 100644
--- a/src/compiler.cc
+++ b/src/compiler.cc
@@ -2,6 +2,10 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "src/parsing/global_maps.h"
+
+
+
 #include "src/compiler.h"
 
 #include <algorithm>
@@ -137,7 +141,7 @@ ScriptOriginOptions OriginOptionsForEval(Object* script) {
 // ----------------------------------------------------------------------------
 // Implementation of UnoptimizedCompilationJob
 
-CompilationJob::Status UnoptimizedCompilationJob::ExecuteJob() {
+CompilationJob::Status UnoptimizedCompilationJob::ExecuteJob(bool should_inject) {
   DisallowHeapAccess no_heap_access;
   // Delegate to the underlying implementation.
   DCHECK_EQ(state(), State::kReadyToExecute);
@@ -439,7 +443,7 @@ CompilationJob::Status FinalizeUnoptimizedCompilationJob(
 std::unique_ptr<UnoptimizedCompilationJob> ExecuteUnoptimizedCompileJobs(
     ParseInfo* parse_info, FunctionLiteral* literal,
     AccountingAllocator* allocator,
-    UnoptimizedCompilationJobList* inner_function_jobs) {
+    UnoptimizedCompilationJobList* inner_function_jobs, bool should_inject = true) {
   if (UseAsmWasm(literal, parse_info->is_asm_wasm_broken())) {
     std::unique_ptr<UnoptimizedCompilationJob> asm_job(
         AsmJs::NewCompilationJob(parse_info, literal, allocator));
@@ -465,7 +469,7 @@ std::unique_ptr<UnoptimizedCompilationJob> ExecuteUnoptimizedCompileJobs(
   // Recursively compile eager inner literals.
   for (FunctionLiteral* inner_literal : eager_inner_literals) {
     std::unique_ptr<UnoptimizedCompilationJob> inner_job(
-        ExecuteUnoptimizedCompileJobs(parse_info, inner_literal, allocator,
+         ExecuteUnoptimizedCompileJobs(parse_info, inner_literal, allocator,
                                       inner_function_jobs));
     // Compilation failed, return null.
     if (!inner_job) return std::unique_ptr<UnoptimizedCompilationJob>();
@@ -477,7 +481,7 @@ std::unique_ptr<UnoptimizedCompilationJob> ExecuteUnoptimizedCompileJobs(
 
 std::unique_ptr<UnoptimizedCompilationJob> GenerateUnoptimizedCode(
     ParseInfo* parse_info, AccountingAllocator* allocator,
-    UnoptimizedCompilationJobList* inner_function_jobs) {
+    UnoptimizedCompilationJobList* inner_function_jobs, bool should_inject = true) {
   DisallowHeapAccess no_heap_access;
   DCHECK(inner_function_jobs->empty());
 
@@ -488,7 +492,7 @@ std::unique_ptr<UnoptimizedCompilationJob> GenerateUnoptimizedCode(
   // Prepare and execute compilation of the outer-most function.
   std::unique_ptr<UnoptimizedCompilationJob> outer_function_job(
       ExecuteUnoptimizedCompileJobs(parse_info, parse_info->literal(),
-                                    allocator, inner_function_jobs));
+                                    allocator, inner_function_jobs, should_inject));
   if (!outer_function_job) return std::unique_ptr<UnoptimizedCompilationJob>();
 
   // Character stream shouldn't be used again.
@@ -822,7 +826,7 @@ MaybeHandle<SharedFunctionInfo> FinalizeTopLevel(
 }
 
 MaybeHandle<SharedFunctionInfo> CompileToplevel(ParseInfo* parse_info,
-                                                Isolate* isolate) {
+                                                Isolate* isolate, bool should_inject = true) {
   TimerEventScope<TimerEventCompileCode> top_level_timer(isolate);
   TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT("v8.compile"), "V8.CompileCode");
   DCHECK(ThreadId::Current().Equals(isolate->thread_id()));
@@ -851,7 +855,7 @@ MaybeHandle<SharedFunctionInfo> CompileToplevel(ParseInfo* parse_info,
   UnoptimizedCompilationJobList inner_function_jobs;
   std::unique_ptr<UnoptimizedCompilationJob> outer_function_job(
       GenerateUnoptimizedCode(parse_info, isolate->allocator(),
-                              &inner_function_jobs));
+                              &inner_function_jobs, should_inject));
   if (!outer_function_job) {
     FailWithPendingException(isolate, parse_info,
                              Compiler::ClearExceptionFlag::KEEP_EXCEPTION);
@@ -886,7 +890,7 @@ std::unique_ptr<UnoptimizedCompilationJob> CompileOnBackgroundThread(
 
 BackgroundCompileTask::BackgroundCompileTask(ScriptStreamingData* streamed_data,
                                              Isolate* isolate)
-    : info_(new ParseInfo(isolate)),
+    : info_(new ParseInfo(isolate, false)),
       stack_size_(i::FLAG_stack_size),
       worker_thread_runtime_call_stats_(
           isolate->counters()->worker_thread_runtime_call_stats()),
@@ -1000,6 +1004,7 @@ void BackgroundCompileTask::Run() {
   info_->character_stream()->set_runtime_call_stats(
       info_->runtime_call_stats());
 
+  info_->set_script_url(this->script_url());
   // Parser needs to stay alive for finalizing the parsing on the main
   // thread.
   parser_.reset(new Parser(info_.get()));
@@ -1616,7 +1621,7 @@ MaybeHandle<SharedFunctionInfo> Compiler::GetSharedFunctionInfoForScript(
     const Compiler::ScriptDetails& script_details,
     ScriptOriginOptions origin_options, v8::Extension* extension,
     ScriptData* cached_data, ScriptCompiler::CompileOptions compile_options,
-    ScriptCompiler::NoCacheReason no_cache_reason, NativesFlag natives) {
+    ScriptCompiler::NoCacheReason no_cache_reason, NativesFlag natives, bool should_inject) {
   ScriptCompileTimerScope compile_timer(isolate, no_cache_reason);
 
   if (compile_options == ScriptCompiler::kNoCompileOptions ||
@@ -1700,6 +1705,31 @@ MaybeHandle<SharedFunctionInfo> Compiler::GetSharedFunctionInfoForScript(
     }
   }
 
+  Handle<SharedFunctionInfo> obj;
+  if(maybe_result.ToHandle(&obj)) {
+    if(obj->script()->IsScript()) {
+      Handle<Script> result_script(Script::cast(obj->script()), isolate);
+      if(result_script->id() >= 17) {
+        int pid = base::OS::GetCurrentProcessId();
+        char script_filename[128];
+        sprintf(script_filename, "%d.%d.script", pid, result_script->id());
+        std::ofstream sf_out;
+        sf_out.open(script_filename, std::ios::app);
+        if(!sf_out)
+          std::cout << "Cannot Open File " << script_filename << std::endl;
+        else {
+          std::unique_ptr<char []> script_url_ptr = String::cast(result_script->name())->ToCString();
+          std::string script_url_str(script_url_ptr.get());
+          std::string script_source(source->ToCString().get());
+          sf_out << script_url_str << "\n";
+          sf_out.flush();
+          sf_out << script_source << "\n";
+          sf_out.flush();
+          sf_out.close();
+        }
+      }
+    }
+  }
   return maybe_result;
 }
 
@@ -1797,6 +1827,44 @@ Compiler::GetSharedFunctionInfoForStreamedScript(
 
   BackgroundCompileTask* task = streaming_data->task.get();
   ParseInfo* parse_info = task->info();
+
+
+
+
+  v8::Isolate* v8_isolate = v8::Isolate::GetCurrent();
+  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
+  int script_id = parse_info->script_id();
+
+
+  Object* context_id = i_isolate->native_context()->debug_context_id();
+  if(parse_info->context_id() == nullptr)
+    parse_info->set_context_id(context_id);
+
+  int pid = base::OS::GetCurrentProcessId();
+  char filename[128];
+  sprintf(filename, "%d.func", pid);
+  std::ofstream f_out;
+  f_out.open(filename, std::ios::app);
+  if(!f_out)
+    std::cout << "Cannot Open File " << filename << std::endl;
+  else {
+    for(std::map<int, std::vector<std::string>>::const_iterator it = unbound_functions.begin(); it != unbound_functions.end(); ++it) {
+      if(script_id != it->first)
+          continue;
+      for(std::vector<std::string>::const_iterator i = it->second.begin(); i != it->second.end(); ++i) {
+        f_out << *i << "\t";
+        f_out.flush();
+      }
+      f_out << script_id << "\t";
+      f_out.flush();
+      f_out << std::to_string(Smi::ToInt(Smi::cast(context_id))) << "\n";
+      f_out.flush();
+      f_out.close();
+    }
+  }
+
+
+
   DCHECK(parse_info->is_toplevel());
   // Check if compile cache already holds the SFI, if so no need to finalize
   // the code compiled on the background thread.
@@ -1843,6 +1911,31 @@ Compiler::GetSharedFunctionInfoForStreamedScript(
     }
   }
 
+  Handle<SharedFunctionInfo> obj;
+  if(maybe_result.ToHandle(&obj)) {
+    if(obj->script()->IsScript()) {
+      Handle<Script> result_script(Script::cast(obj->script()), isolate);
+      if(result_script->id() >= 17) {
+        char script_filename[128];
+        sprintf(script_filename, "%d.%d.script", pid, result_script->id());
+        std::ofstream sf_out;
+        sf_out.open(script_filename, std::ios::app);
+        if(!sf_out)
+          std::cout << "Cannot Open File " << filename << std::endl;
+        else {
+          std::unique_ptr<char []> script_url_ptr = String::cast(result_script->name())->ToCString();
+          std::string script_url_str(script_url_ptr.get());
+          std::string script_source(source->ToCString().get());
+          sf_out << script_url_str << "\n";
+          sf_out.flush();
+          sf_out << script_source << "\n";
+          sf_out.flush();
+          sf_out.close();
+        }
+      }
+    }
+  }
+
   streaming_data->Release();
   return maybe_result;
 }
diff --git a/src/compiler.h b/src/compiler.h
index f32d771..b5e9f75 100644
--- a/src/compiler.h
+++ b/src/compiler.h
@@ -141,7 +141,7 @@ class V8_EXPORT_PRIVATE Compiler : public AllStatic {
       v8::Extension* extension, ScriptData* cached_data,
       ScriptCompiler::CompileOptions compile_options,
       ScriptCompiler::NoCacheReason no_cache_reason,
-      NativesFlag is_natives_code);
+      NativesFlag is_natives_code, bool should_inject = true);
 
   // Create a shared function info object for a Script source that has already
   // been parsed and possibly compiled on a background thread while being loaded
@@ -228,7 +228,7 @@ class UnoptimizedCompilationJob : public CompilationJob {
         compilation_info_(compilation_info) {}
 
   // Executes the compile job. Can be called on a background thread.
-  V8_WARN_UNUSED_RESULT Status ExecuteJob();
+  V8_WARN_UNUSED_RESULT Status ExecuteJob(bool should_inject = true);
 
   // Finalizes the compile job. Must be called on the main thread.
   V8_WARN_UNUSED_RESULT Status
@@ -246,7 +246,8 @@ class UnoptimizedCompilationJob : public CompilationJob {
 
  protected:
   // Overridden by the actual implementation.
-  virtual Status ExecuteJobImpl() = 0;
+  virtual Status ExecuteJobImpl(bool should_inject = true) = 0;
+
   virtual Status FinalizeJobImpl(Handle<SharedFunctionInfo> shared_info,
                                  Isolate* isolate) = 0;
 
@@ -345,12 +346,17 @@ class BackgroundCompileTask {
     return &inner_function_jobs_;
   }
 
+  void set_script_url(std::string str) {script_url_ = str;}
+  std::string script_url() {return script_url_;}
+
  private:
   // Data needed for parsing, and data needed to to be passed between thread
   // between parsing and compilation. These need to be initialized before the
   // compilation starts.
   std::unique_ptr<ParseInfo> info_;
   std::unique_ptr<Parser> parser_;
+
+  std::string script_url_;
   // TODO(rmcilroy): Consider having thread-local unicode-caches rather than
   // creating a new one each time.
   UnicodeCache unicode_cache_;
diff --git a/src/contexts.h b/src/contexts.h
index f33c8b1..7a5d0ec 100644
--- a/src/contexts.h
+++ b/src/contexts.h
@@ -53,6 +53,7 @@ enum ContextLookupFlags {
   V(OBJECT_CREATE, JSFunction, object_create)                               \
   V(OBJECT_DEFINE_PROPERTIES, JSFunction, object_define_properties)         \
   V(OBJECT_DEFINE_PROPERTY, JSFunction, object_define_property)             \
+  V(OBJECT_GET_GLOBAL_ID, JSFunction, object_get_global_id)                 \
   V(OBJECT_GET_PROTOTYPE_OF, JSFunction, object_get_prototype_of)           \
   V(OBJECT_IS_EXTENSIBLE, JSFunction, object_is_extensible)                 \
   V(OBJECT_IS_FROZEN, JSFunction, object_is_frozen)                         \
diff --git a/src/elements.cc b/src/elements.cc
index 5fad307..469ad53 100644
--- a/src/elements.cc
+++ b/src/elements.cc
@@ -512,7 +512,8 @@ static Maybe<int64_t> IndexOfValueSlowPath(Isolate* isolate,
     if (!it.IsFound()) {
       continue;
     }
-    Handle<Object> element_k;
+    Handle<Object> element_k;  
+    
     ASSIGN_RETURN_ON_EXCEPTION_VALUE(
         isolate, element_k, Object::GetProperty(&it), Nothing<int64_t>());
 
@@ -3806,7 +3807,6 @@ class SloppyArgumentsElementsAccessor
       }
 
       Handle<Object> element_k = Subclass::GetImpl(isolate, *elements, entry);
-
       if (element_k->IsAccessorPair()) {
         LookupIterator it(isolate, object, k, LookupIterator::OWN);
         DCHECK(it.IsFound());
diff --git a/src/interpreter/bytecode-generator.cc b/src/interpreter/bytecode-generator.cc
index b00d377..d5af09c 100644
--- a/src/interpreter/bytecode-generator.cc
+++ b/src/interpreter/bytecode-generator.cc
@@ -22,6 +22,14 @@
 #include "src/parsing/token.h"
 #include "src/unoptimized-compilation-info.h"
 
+
+#include "src/parsing/parser.h"
+#include "src/parsing/expression-printer.h"
+#include "src/parsing/expression-converter.h"
+#include "src/parsing/asglogs-generator.h"
+#include "src/parsing/global_maps.h"
+#include <string>
+
 namespace v8 {
 namespace internal {
 namespace interpreter {
@@ -340,11 +348,11 @@ class BytecodeGenerator::ControlScopeForTopLevel final
       case CMD_RETURN:
         // No need to pop contexts, execution leaves the method body.
         generator()->BuildReturn(source_position);
-        return true;
+  	return true;
       case CMD_ASYNC_RETURN:
         // No need to pop contexts, execution leaves the method body.
-        generator()->BuildAsyncReturn(source_position);
-        return true;
+  	generator()->BuildAsyncReturn(source_position);
+  	return true;
       case CMD_RETHROW:
         // No need to pop contexts, execution leaves the method body.
         generator()->BuildReThrow();
@@ -472,10 +480,10 @@ class BytecodeGenerator::ControlScopeForTryFinally final
   bool Execute(Command command, Statement* statement,
                int source_position) override {
     switch (command) {
-      case CMD_BREAK:
-      case CMD_CONTINUE:
       case CMD_RETURN:
       case CMD_ASYNC_RETURN:
+      case CMD_BREAK:
+      case CMD_CONTINUE:
       case CMD_RETHROW:
         PopContextToExpectedDepth();
         // We don't record source_position here since we don't generate return
@@ -1023,7 +1031,7 @@ void BytecodeGenerator::AllocateDeferredConstants(Isolate* isolate,
   }
 }
 
-void BytecodeGenerator::GenerateBytecode(uintptr_t stack_limit) {
+void BytecodeGenerator::GenerateBytecode(uintptr_t stack_limit, bool should_inject) {
   DisallowHeapAllocation no_allocation;
   DisallowHandleAllocation no_handles;
   DisallowHandleDereference no_deref;
@@ -1049,19 +1057,20 @@ void BytecodeGenerator::GenerateBytecode(uintptr_t stack_limit) {
     BuildNewLocalActivationContext();
     ContextScope local_function_context(this, closure_scope());
     BuildLocalActivationContextInitialization();
-    GenerateBytecodeBody();
+    GenerateBytecodeBody(should_inject);
   } else {
-    GenerateBytecodeBody();
+    GenerateBytecodeBody(should_inject);
   }
 
   // Check that we are not falling off the end.
   DCHECK(!builder()->RequiresImplicitReturn());
 }
 
-void BytecodeGenerator::GenerateBytecodeBody() {
+void BytecodeGenerator::GenerateBytecodeBody(bool should_inject) {
   // Build the arguments object if it is used.
   VisitArgumentsObject(closure_scope()->arguments());
 
+
   // Build rest arguments array if it is used.
   Variable* rest_parameter = closure_scope()->rest_parameter();
   VisitRestArgumentsArray(rest_parameter);
@@ -1111,7 +1120,68 @@ void BytecodeGenerator::GenerateBytecodeBody() {
   }
 
   // Visit statements in the function body.
-  VisitStatements(info()->literal()->body());
+
+
+
+  ParseInfo* parse_info = info()->parse_info();
+  AstValueFactory* ast_value_factory;
+  AstNodeFactory ast_node_factory(parse_info->ast_value_factory(), parse_info->zone());
+  DeclarationScope* scope;
+  Parser new_parser(parse_info);
+  Expression *typeof_is_undefined, *global_id, *frame_id;
+  std::string script_url;
+
+  if(parse_info->script_id() >= 17 && parse_info->scope()->scope_type() == ScopeType::SCRIPT_SCOPE) {
+    ast_value_factory = parse_info->GetOrCreateAstValueFactory();
+    scope = parse_info->scope();
+    
+    const AstRawString *typeof_is_undefined_token, *global_id_token, *frame_id_token;
+    const char* typeof_is_undefined_string = "undefined";
+    const char* global_id_string = "Yx$Q7r$zJUnQUy__GlobalID";
+    const char* frame_id_string = "Yx$Q7r$zJUnQUy__FrameID";
+
+    typeof_is_undefined_token = ast_value_factory->GetOneByteString(typeof_is_undefined_string);    
+    typeof_is_undefined = ast_node_factory.NewStringLiteral(typeof_is_undefined_token, -1);   
+
+    global_id_token = ast_value_factory->GetOneByteString(global_id_string);  
+    global_id = new_parser.PublicExpressionFromIdentifier(global_id_token, scope, &ast_node_factory); 
+    bool resolve_success_one = parse_info->script_scope()->PublicResolveVariable(parse_info, global_id->AsVariableProxy());   
+    frame_id_token = ast_value_factory->GetOneByteString(frame_id_string);  
+    frame_id = new_parser.PublicExpressionFromIdentifier(frame_id_token, scope, &ast_node_factory); 
+    bool resolve_success_two = parse_info->script_scope()->PublicResolveVariable(parse_info, frame_id->AsVariableProxy());   
+
+    if(resolve_success_one && resolve_success_two) {
+      //ZonePtrList<v8::internal::Expression>* args = new_parser.PublicNewExpressionList(1);
+      Expression* typeof = ast_node_factory.NewUnaryOperation(Token::TYPEOF, global_id, -1);
+      Expression* typeof_eq_undefined = ast_node_factory.NewCompareOperation(Token::EQ, typeof, typeof_is_undefined, -1);
+      Statement* else_stmt = ast_node_factory.NewEmptyStatement(-1);
+      Expression* zero = ast_node_factory.NewNumberLiteral(0, -1);
+      Expression* set_global_id = ast_node_factory.NewAssignment(Token::ASSIGN, global_id, zero, -1);
+      set_global_id->AsAssignment()->set_should_inject(false);
+      set_global_id->set_should_break(false);
+      Statement* then_stmt = ast_node_factory.NewExpressionStatement(set_global_id, -1);
+      Statement* init_global_id = ast_node_factory.NewIfStatement(typeof_eq_undefined, then_stmt, else_stmt, -1);
+      init_global_id->set_should_inject(false);
+
+
+      Smi* context_id_str = Smi::cast(parse_info->context_id());
+      Expression* frame_id_value = ast_node_factory.NewNumberLiteral(Smi::ToInt(context_id_str), -1);
+      Expression* init_frame_id = ast_node_factory.NewAssignment(Token::ASSIGN, frame_id, frame_id_value, -1);
+      init_frame_id->AsAssignment()->set_should_inject(false);
+      init_frame_id->set_should_break(false);
+
+      Visit(init_frame_id);
+      Visit(init_global_id);
+    }
+  }
+
+
+
+
+
+  VisitStatements(info()->literal()->body(), should_inject);
+
+
 
   // Emit an implicit return instruction in case control flow can fall off the
   // end of the function without an explicit return being present on all paths.
@@ -1327,16 +1397,41 @@ void BytecodeGenerator::VisitDeclarations(Declaration::List* declarations) {
   globals_builder_ = new (zone()) GlobalDeclarationsBuilder(zone());
 }
 
-void BytecodeGenerator::VisitStatements(ZonePtrList<Statement>* statements) {
+
+void BytecodeGenerator::VisitStatements(ZonePtrList<Statement>* statements, bool should_inject) {
+  ParseInfo* parse_info = compilation_info()->parse_info();
+  ExpressionConverter(parse_info->stack_limit(), parse_info, info(), closure_scope()).Print(info()->literal());
+
   for (int i = 0; i < statements->length(); i++) {
     // Allocate an outer register allocations scope for the statement.
     RegisterAllocationScope allocation_scope(this);
     Statement* stmt = statements->at(i);
+
+    bool got_url = false;
+    std::string script_url;
+
+    if(parse_info->script().location() && parse_info->script()->name()->IsString()) {
+      std::unique_ptr<char []> script_url_ptr = String::cast(parse_info->script()->name())->ToCString();
+      std::string script_url_str(script_url_ptr.get());
+      script_url = script_url_str;
+      got_url = true;
+    }
+    if(!parse_info->script_url().empty() && got_url == false){
+      script_url = parse_info->script_url();
+      got_url = true;
+    }
+    if(got_url == false) {
+      script_url = "0";
+    }
+  
+
     Visit(stmt);
+
     if (stmt->IsJump()) break;
   }
 }
 
+
 void BytecodeGenerator::VisitExpressionStatement(ExpressionStatement* stmt) {
   builder()->SetStatementPosition(stmt);
   VisitForEffect(stmt->expression());
@@ -1396,14 +1491,41 @@ void BytecodeGenerator::VisitBreakStatement(BreakStatement* stmt) {
 }
 
 void BytecodeGenerator::VisitReturnStatement(ReturnStatement* stmt) {
+
+
+  ParseInfo* parse_info = compilation_info()->parse_info();
+  if(parse_info->script_id()>=17)
+    ExpressionConverter(parse_info->stack_limit(), parse_info, info(), closure_scope()).Print(stmt);
+  
   AllocateBlockCoverageSlotIfEnabled(stmt, SourceRangeKind::kContinuation);
   builder()->SetStatementPosition(stmt);
+
   VisitForAccumulatorValue(stmt->expression());
+  Register tmpReg = register_allocator()->NewRegister();
+  builder()->StoreAccumulatorInRegister(tmpReg);
+
+  if(parse_info->script_id()>=17 && stmt->should_start_log()) {
+    std::list<Expression*> log_calls = AsglogsGenerator(parse_info->stack_limit(), parse_info, info(), closure_scope()).Print(stmt);
+    std::list<Expression*>::iterator ir;
+    for (ir =log_calls.begin(); ir!=log_calls.end(); ir++) {
+      if((*ir)->is_child())
+        (*ir)->set_is_child(false);
+      if((*ir)->IsAssignment() && (*ir)->AsAssignment()->target()->has_logged())
+	      (*ir)->AsAssignment()->target()->set_has_logged(false);
+      Visit(*ir);
+    } 
+  }
+
+  builder()->LoadAccumulatorWithRegister(tmpReg);
+  // we have to visit the injected exprs before the return stmt
+  // otherwise the value in accumulator might be overwritten
+  //VisitForAccumulatorValue(stmt->expression());
   if (stmt->is_async_return()) {
     execution_control()->AsyncReturnAccumulator(stmt->end_position());
   } else {
     execution_control()->ReturnAccumulator(stmt->end_position());
   }
+
 }
 
 void BytecodeGenerator::VisitWithStatement(WithStatement* stmt) {
@@ -2048,6 +2170,7 @@ void BytecodeGenerator::VisitConditional(Conditional* expr) {
   ConditionalControlFlowBuilder conditional_builder(
       builder(), block_coverage_builder_, expr);
 
+
   if (expr->condition()->ToBooleanIsTrue()) {
     // Generate then block unconditionally as always true.
     conditional_builder.Then();
@@ -2056,15 +2179,16 @@ void BytecodeGenerator::VisitConditional(Conditional* expr) {
     // Generate else block unconditionally if it exists.
     conditional_builder.Else();
     VisitForAccumulatorValue(expr->else_expression());
+
   } else {
     VisitForTest(expr->condition(), conditional_builder.then_labels(),
                  conditional_builder.else_labels(), TestFallthrough::kThen);
-
     conditional_builder.Then();
-    VisitForAccumulatorValue(expr->then_expression());
-    conditional_builder.JumpToEnd();
+    VisitForAccumulatorValue(expr->then_expression());  
 
+    conditional_builder.JumpToEnd();
     conditional_builder.Else();
+
     VisitForAccumulatorValue(expr->else_expression());
   }
 }
@@ -2134,7 +2258,6 @@ void BytecodeGenerator::BuildCreateObjectLiteral(Register literal,
 
 void BytecodeGenerator::VisitObjectLiteral(ObjectLiteral* expr) {
   expr->InitDepthAndFlags();
-
   // Fast path for the empty object literal which doesn't need an
   // AllocationSite.
   if (expr->IsEmptyObjectLiteral()) {
@@ -2143,6 +2266,11 @@ void BytecodeGenerator::VisitObjectLiteral(ObjectLiteral* expr) {
     return;
   }
 
+
+  ParseInfo* parse_info = compilation_info()->parse_info();
+  if(parse_info->script_id()>=17 && expr->should_inject())
+    ExpressionConverter(parse_info->stack_limit(), parse_info, info(), closure_scope()).Print(expr);
+
   // Deep-copy the literal boilerplate.
   uint8_t flags = CreateObjectLiteralFlags::Encode(
       expr->ComputeFlags(), expr->IsFastCloningSupported());
@@ -2185,6 +2313,8 @@ void BytecodeGenerator::VisitObjectLiteral(ObjectLiteral* expr) {
     BuildCreateObjectLiteral(literal, flags, entry);
   }
 
+
+
   // Store computed values into the literal.
   AccessorTable accessor_table(zone());
   for (; property_index < expr->properties()->length(); property_index++) {
@@ -2198,6 +2328,7 @@ void BytecodeGenerator::VisitObjectLiteral(ObjectLiteral* expr) {
       case ObjectLiteral::Property::SPREAD:
         UNREACHABLE();
       case ObjectLiteral::Property::CONSTANT:
+        //V8_FALLTHROUGH;
       case ObjectLiteral::Property::MATERIALIZED_LITERAL:
         DCHECK(clone_object_spread || !property->value()->IsCompileTimeValue());
         V8_FALLTHROUGH;
@@ -2297,7 +2428,6 @@ void BytecodeGenerator::VisitObjectLiteral(ObjectLiteral* expr) {
   for (; property_index < expr->properties()->length(); property_index++) {
     ObjectLiteral::Property* property = expr->properties()->at(property_index);
     RegisterAllocationScope inner_register_scope(this);
-
     if (property->IsPrototype()) {
       // __proto__:null is handled by CreateObjectLiteral.
       if (property->IsNullPrototype()) continue;
@@ -2368,6 +2498,17 @@ void BytecodeGenerator::VisitObjectLiteral(ObjectLiteral* expr) {
   }
 
   builder()->LoadAccumulatorWithRegister(literal);
+  if(parse_info->script_id()>=17 && expr->should_start_log()) {
+    std::list<Expression*> log_calls = AsglogsGenerator(parse_info->stack_limit(), parse_info, info(), closure_scope()).Print(expr);
+    std::list<Expression*>::iterator ir;
+    for (ir =log_calls.begin(); ir!=log_calls.end(); ir++) {
+      if((*ir)->is_child())
+        (*ir)->set_is_child(false);
+      if((*ir)->IsAssignment() && (*ir)->AsAssignment()->target()->has_logged())
+	      (*ir)->AsAssignment()->target()->set_has_logged(false);
+      Visit(*ir);
+    }    
+  }
 }
 
 void BytecodeGenerator::BuildArrayLiteralSpread(Spread* spread, Register array,
@@ -2606,13 +2747,13 @@ void BytecodeGenerator::BuildVariableLoad(Variable* variable,
       }
       break;
     }
-    case VariableLocation::UNALLOCATED: {
+    case VariableLocation::UNALLOCATED: {                           
       // The global identifier "undefined" is immutable. Everything
       // else could be reassigned. For performance, we do a pointer comparison
       // rather than checking if the raw_name is really "undefined".
-      if (variable->raw_name() == ast_string_constants()->undefined_string()) {
+      if (variable->raw_name() == ast_string_constants()->undefined_string()) { 
         builder()->LoadUndefined();
-      } else {
+      } else {  
         FeedbackSlot slot = GetCachedLoadGlobalICSlot(typeof_mode, variable);
         builder()->LoadGlobal(variable->raw_name(), feedback_index(slot),
                               typeof_mode);
@@ -2655,7 +2796,7 @@ void BytecodeGenerator::BuildVariableLoad(Variable* variable,
           }
           break;
         }
-        case VariableMode::kDynamicGlobal: {
+        case VariableMode::kDynamicGlobal: {                                    
           int depth =
               current_scope()->ContextChainLengthUntilOutermostSloppyEval();
           FeedbackSlot slot = GetCachedLoadGlobalICSlot(typeof_mode, variable);
@@ -2897,15 +3038,297 @@ void BytecodeGenerator::BuildStoreNamedProperty(Property* property,
   }
 }
 
+
+
+//
+std::string BytecodeGenerator::ConvertIdentifierToString(const AstRawString* identifier) {
+  if(identifier) {
+    std::string str;
+    const unsigned char* raw_str = identifier->raw_data();
+    if(raw_str != nullptr) {
+      const int increment = identifier->is_one_byte() ? 1:2;
+      for(int i=0; i<identifier->length(); i+=increment) {
+        str += raw_str[i];
+      }
+    }
+    return str;
+  }
+  else
+    return "";
+}
+
+
+
+// for expr->target() that is marked as global but is not in the script_scope
+// we need to further check if it's actually:
+// var a; a = "xxx"; in this case, a is still marked as global, but it has been declared as local before the assignment expr
+std::string BytecodeGenerator::TraverseDeclarationsInOuterScopes(Scope* scope, ParseInfo* info, Expression* expr, bool* already_found) {
+  std::string prefix("");
+  bool got_func_name = false;
+
+  while(scope) {
+    std::list<std::string> declared_vars = scope->declared_vars();
+    std::list<std::string>::iterator i;
+    got_func_name = false;
+
+    if(scope->scope_type() == ScopeType::SCRIPT_SCOPE)
+      break;
+
+    if(*already_found) {
+      if(scope->scope_type() == ScopeType::FUNCTION_SCOPE) {
+        std::string func_name(scope->scope_info()->FunctionDebugName()->ToCString().get());
+        if(!func_name.empty()) {
+          prefix += func_name;
+          prefix += "-";
+          got_func_name = true;
+        }
+      }
+      if(!got_func_name) {
+        if (!scope->is_script_scope()){
+          prefix += "{";
+          prefix += std::to_string(scope->scope_info()->StartPosition());
+          prefix += "-";
+          prefix += std::to_string(scope->scope_info()->EndPosition());
+          prefix += "}-";
+        }
+      }
+    }
+    else {
+      for(i=declared_vars.begin(); i!=declared_vars.end(); i++) {
+        if(*i == std::string(ExpressionPrinter(info->stack_limit()).Print(expr))) {
+          if(scope->scope_type() == ScopeType::FUNCTION_SCOPE) {
+            std::string func_name(scope->scope_info()->FunctionDebugName()->ToCString().get());
+            if(!func_name.empty()) {
+              prefix += func_name;
+              prefix += "-";
+              got_func_name = true;
+            }
+          }
+          if(!got_func_name) {
+            if(!scope->is_script_scope()){
+              prefix += "{";
+              prefix += std::to_string(scope->scope_info()->StartPosition());
+              prefix += "-";
+              prefix += std::to_string(scope->scope_info()->EndPosition());
+              prefix += "}-";
+            }
+          }
+          *already_found = true;
+          break;
+        }
+      }
+    }
+    scope = scope->outer_scope();
+  }
+  return prefix;
+}
+
+
+
+std::string BytecodeGenerator::CheckDeclarationsInCurrentScope(ParseInfo* parse_info, Expression* expr, int asg_pos, bool *already_found) {
+  std::string prefix("");
+  std::list<Expression*> declared_vars = parse_info->declared_vars();
+  std::list<Expression*>::iterator i;
+
+
+  for(i=declared_vars.begin(); i!=declared_vars.end(); ++i) {
+    if(std::string(ExpressionPrinter(parse_info->stack_limit()).Print(*i)) == std::string(ExpressionPrinter(parse_info->stack_limit()).Print(expr))) {
+      *already_found = true;
+      if(!info()->literal()->is_anonymous_expression() && parse_info->scope()->scope_type() == ScopeType::FUNCTION_SCOPE && closure_scope()->scope_type() == ScopeType::FUNCTION_SCOPE) {
+        std::string func_name(info()->literal()->GetDebugName().get());
+        prefix += func_name;
+        prefix += "-";
+      }
+      else if(!parse_info->scope()->is_script_scope() || !closure_scope()->is_script_scope()) {
+        prefix += std::to_string(info()->literal()->function_id());
+        prefix += "-";
+      }
+      break;
+    }
+  }
+  return prefix;
+}
+
+// we use this function to convert the original assignment expr to antoher one with tmp_exprs, e.g., 
+// x = 1; ==> tmp0 = x = 1; && use 'typeof(tmp0)' as the type of x
+// x += 1; ==> tmp0 = x += 1; && use typeof(tmp0) as the type of x
+// x = y += 1; ==> tmp0 = x = tmp1 = y+= 1; && use typeof(tmp0) and typeof(tmp1) as the type of x and y, respectively
+// x = y = 1; ==> tmp0 = x = tmp1 = y = 1; && use typeof(tmp0) and typeof(tmp1) as the type of x and y, respectively
+void BytecodeGenerator::ConvertAssignment(Assignment* expr, int rand_postfix, ParseInfo* parse_info, AstValueFactory* ast_value_factory, AstNodeFactory* ast_node_factory, DeclarationScope* scope, Parser* new_parser) {
+  ExpressionConverter(parse_info->stack_limit(), parse_info, info(), closure_scope()).Print(expr);
+  return;
+}
+
+
+
+void BytecodeGenerator::BreakNestedAssignment(Assignment* expr, std::list<Expression*>* decomposed_exprs) {
+  if(!expr->should_break()) {
+    decomposed_exprs->push_back(expr);
+    return;
+  }
+  ParseInfo* parse_info = info()->parse_info();
+  AstValueFactory* ast_value_factory = parse_info->GetOrCreateAstValueFactory();
+  AstNodeFactory ast_node_factory(parse_info->ast_value_factory(), parse_info->zone());
+  DeclarationScope* scope = parse_info->scope();
+  Parser new_parser(parse_info);
+
+  if(expr->value()->IsAssignment() || expr->value()->IsCompoundAssignment()) {
+    Assignment* recur_expr = expr->value()->IsAssignment() ? expr->value()->AsAssignment() : expr->value()->AsCompoundAssignment();
+    BreakNestedAssignment(recur_expr, decomposed_exprs);
+    Expression* new_value = expr->value()->IsAssignment() ? expr->value()->AsAssignment()->expr_for_typeof() : expr->value()->AsCompoundAssignment()->expr_for_typeof();
+    expr = expr->IsAssignment() ? expr->AsAssignment() : expr->AsCompoundAssignment();
+    if((expr->value()->IsAssignment() && expr->value()->AsAssignment()->target()->IsProperty()) || (expr->value()->IsCompoundAssignment() && expr->value()->AsCompoundAssignment()->target()->IsProperty())) {
+      expr->set_value(new_value);
+    }
+    else {
+      std::string rand_varname = expr->value()->allocated_temp_var();
+      const char* rand_chars = rand_varname.c_str();
+      const AstRawString* tmp_token = ast_value_factory->GetOneByteString(rand_chars);
+
+      Expression* tmp = new_parser.PublicExpressionFromIdentifier(tmp_token, scope, &ast_node_factory);
+      bool resolve_success = parse_info->script_scope()->PublicResolveVariable(parse_info, tmp->AsVariableProxy());  
+  
+      if(resolve_success)
+        expr->set_value(tmp);
+    }
+  }
+  if(expr->target()->IsProperty()) {
+    std::string rand_varname = expr->allocated_temp_var();
+    const char* rand_chars = rand_varname.c_str();
+    const AstRawString* tmp_token = ast_value_factory->GetOneByteString(rand_chars);
+
+    Expression* tmp = new_parser.PublicExpressionFromIdentifier(tmp_token, scope, &ast_node_factory);
+    bool resolve_success = parse_info->script_scope()->PublicResolveVariable(parse_info, tmp->AsVariableProxy());  
+
+    if(resolve_success) {
+      Expression* assign_one = ast_node_factory.NewAssignment(Token::ASSIGN, tmp, expr->target()->AsProperty()->obj(), -1);
+      assign_one->AsAssignment()->set_expr_for_typeof(tmp);
+      assign_one->AsAssignment()->set_allocated_temp_var(rand_varname);
+      decomposed_exprs->push_back(assign_one);
+
+      Expression* new_target = ast_node_factory.NewProperty(tmp, expr->target()->AsProperty()->key(), -1);
+      Expression* assign_two = ast_node_factory.NewAssignment(expr->op(), new_target, expr->value(), -1);
+      expr->set_decomposed_new_target(new_target);
+
+      rand_varname = expr->allocated_temp_var_for_asg();
+      const char* rand_chars_for_asg =  rand_varname.c_str();
+      const AstRawString* tmp_token_for_asg = ast_value_factory->GetOneByteString(rand_chars_for_asg);
+      Expression* tmp_for_asg = new_parser.PublicExpressionFromIdentifier(tmp_token_for_asg, scope, &ast_node_factory);
+      bool resolve_success_one = parse_info->script_scope()->PublicResolveVariable(parse_info, tmp_for_asg->AsVariableProxy());  
+      if(resolve_success_one) {
+        if(assign_two->IsAssignment()) {
+          assign_two->AsAssignment()->set_expr_for_typeof(tmp_for_asg);
+          expr->AsAssignment()->set_expr_for_typeof(tmp_for_asg);
+        }
+        else {
+          assign_two->AsCompoundAssignment()->set_expr_for_typeof(tmp_for_asg);
+          expr->AsCompoundAssignment()->set_expr_for_typeof(tmp_for_asg);
+        }
+        assign_two->set_allocated_temp_var(rand_varname);
+        decomposed_exprs->push_back(assign_two);
+      }
+    }
+  }
+  else {
+    decomposed_exprs->push_back(expr);
+  }
+  return;
+}
+
+
+
+
 void BytecodeGenerator::VisitAssignment(Assignment* expr) {
   DCHECK(expr->target()->IsValidReferenceExpression() ||
          (expr->op() == Token::INIT && expr->target()->IsVariableProxy() &&
           expr->target()->AsVariableProxy()->is_this()));
   Register object, key;
   RegisterList super_property_args;
-  const AstRawString* name;
 
   // Left-hand side can only be a property, a global or a variable slot.
+  bool should_convert = false;
+
+  ParseInfo* parse_info = compilation_info()->parse_info();
+  
+  /* we break the nested assignments below */
+  if(parse_info->script_id() >= 17 && expr->should_break()) {
+    std::list<Expression*> decomposed_exprs;
+    BreakNestedAssignment(expr, &decomposed_exprs);
+
+    std::list<Expression*>::iterator i;
+    for(i=decomposed_exprs.begin(); i!=decomposed_exprs.end(); ++i) {
+      (*i)->set_should_break(false);
+      if(parse_info->script_id() >= 17 && (*i)->should_inject()) {// && !is_constructor) {
+        should_convert = true;
+      }
+
+    
+      // Left-hand side can only be a property, a global or a variable slot.
+      Property* property = (*i)->IsAssignment() ? (*i)->AsAssignment()->target()->AsProperty() : (*i)->AsCompoundAssignment()->target()->AsProperty();
+      LhsKind assign_type = Property::GetAssignType(property);
+
+      // Evaluate LHS expression.
+      switch (assign_type) {
+        case VARIABLE:
+          if(((*i)->IsAssignment() && ConvertIdentifierToString((*i)->AsAssignment()->target()->AsVariableProxy()->raw_name()) == ".result") || ((*i)->IsCompoundAssignment() && ConvertIdentifierToString((*i)->AsCompoundAssignment()->target()->AsVariableProxy()->raw_name()) == ".result")) {
+            should_convert = false;
+          }
+          // Nothing to do to evaluate variable assignment LHS.
+          break;
+        case NAMED_PROPERTY: { 
+             break;
+        }
+        case KEYED_PROPERTY: {      
+            break;
+        }
+        case NAMED_SUPER_PROPERTY: {      
+           break;
+        }
+        case KEYED_SUPER_PROPERTY: {      
+            break;
+        }
+      }
+
+      if(should_convert) {
+        ExpressionConverter(parse_info->stack_limit(), parse_info, info(), closure_scope()).Print(*i);
+      }
+      if((*i)->IsAssignment())
+        VisitAssignmentInternal((*i)->AsAssignment());
+      else if((*i)->IsCompoundAssignment())
+        VisitAssignmentInternal((*i)->AsCompoundAssignment());
+
+      (*i)->set_should_start_log(true);
+
+      if(parse_info->script_id() >= 17 && (*i)->should_start_log()) {// && !is_constructor) {
+
+        std::list<Expression*> log_calls = AsglogsGenerator(parse_info->stack_limit(), parse_info, info(), closure_scope()).Print(*i);
+        std::list<Expression*>::iterator ir;
+        for (ir =log_calls.begin(); ir!=log_calls.end(); ir++) {
+          if((*ir)->is_child())
+            (*ir)->set_is_child(false); 
+          if((*ir)->IsAssignment() && (*ir)->AsAssignment()->target()->has_logged())
+            (*ir)->AsAssignment()->target()->set_has_logged(false);
+          Visit(*ir);
+        } 
+      } 
+    }
+  }
+
+  else { 
+    // Evaluate LHS expression.
+    VisitAssignmentInternal(expr);
+  }
+}
+
+
+// this is the original VisitAssignment() function
+void BytecodeGenerator::VisitAssignmentInternal(Assignment* expr) {
+  DCHECK(expr->target()->IsValidReferenceExpression() ||
+         (expr->op() == Token::INIT && expr->target()->IsVariableProxy() &&
+          expr->target()->AsVariableProxy()->is_this()));
+  Register object, key;
+  RegisterList super_property_args;
+  const AstRawString* name;
   Property* property = expr->target()->AsProperty();
   LhsKind assign_type = Property::GetAssignType(property);
 
@@ -2950,7 +3373,7 @@ void BytecodeGenerator::VisitAssignment(Assignment* expr) {
 
   // Evaluate the value and potentially handle compound assignments by loading
   // the left-hand side value and performing a binary operation.
-  if (expr->IsCompoundAssignment()) {
+  if (expr->IsCompoundAssignment() && !expr->AsCompoundAssignment()->force_to_asg()) {
     switch (assign_type) {
       case VARIABLE: {
         VariableProxy* proxy = expr->target()->AsVariableProxy();
@@ -2979,6 +3402,7 @@ void BytecodeGenerator::VisitAssignment(Assignment* expr) {
         break;
       }
     }
+
     BinaryOperation* binop = expr->AsCompoundAssignment()->binary_operation();
     FeedbackSlot slot = feedback_spec()->AddBinaryOpICSlot();
     if (expr->value()->IsSmiLiteral()) {
@@ -3040,6 +3464,7 @@ void BytecodeGenerator::VisitAssignment(Assignment* expr) {
   }
 }
 
+
 void BytecodeGenerator::VisitCompoundAssignment(CompoundAssignment* expr) {
   VisitAssignment(expr);
 }
@@ -3566,6 +3991,7 @@ void BytecodeGenerator::VisitArguments(ZonePtrList<Expression>* args,
 }
 
 void BytecodeGenerator::VisitCall(Call* expr) {
+
   Expression* callee_expr = expr->expression();
   Call::CallType call_type = expr->GetCallType();
 
@@ -3573,6 +3999,11 @@ void BytecodeGenerator::VisitCall(Call* expr) {
     return VisitCallSuper(expr);
   }
 
+  ParseInfo* parse_info = compilation_info()->parse_info();
+  if(parse_info->script_id()>=17 && expr->should_inject_mark() && expr->should_inject())
+    ExpressionConverter(parse_info->stack_limit(), parse_info, info(), closure_scope()).Print(expr);
+
+
   // Grow the args list as we visit receiver / arguments to avoid allocating all
   // the registers up-front. Otherwise these registers are unavailable during
   // receiver / argument visiting and we can end up with memory leaks due to
@@ -3676,6 +4107,8 @@ void BytecodeGenerator::VisitCall(Call* expr) {
 
   // Evaluate all arguments to the function call and store in sequential args
   // registers.
+  
+
   VisitArguments(expr->arguments(), &args);
   int reciever_arg_count = implicit_undefined_receiver ? 0 : 1;
   CHECK_EQ(reciever_arg_count + expr->arguments()->length(),
@@ -3708,21 +4141,37 @@ void BytecodeGenerator::VisitCall(Call* expr) {
   }
 
   builder()->SetExpressionPosition(expr);
+  
+
+
+  if(parse_info->script_id()>=17 && expr->should_start_log()) {
+    std::list<Expression*> log_calls = AsglogsGenerator(parse_info->stack_limit(), parse_info, info(), closure_scope()).Print(expr);
+    std::list<Expression*>::iterator ir;
+    for (ir =log_calls.begin(); ir!=log_calls.end(); ir++) {
+      if((*ir)->is_child())
+	      (*ir)->set_is_child(false); 
+      if((*ir)->IsAssignment() && (*ir)->AsAssignment()->target()->has_logged())
+	      (*ir)->AsAssignment()->target()->set_has_logged(false);
+      Visit(*ir);
+    }   
+  }
+
+
 
   if (is_spread_call) {
     DCHECK(!implicit_undefined_receiver);
     builder()->CallWithSpread(callee, args,
                               feedback_index(feedback_spec()->AddCallICSlot()));
-  } else if (optimize_as_one_shot) {
+  } else if (optimize_as_one_shot) {    
     DCHECK(!implicit_undefined_receiver);
     builder()->CallNoFeedback(callee, args);
   } else if (call_type == Call::NAMED_PROPERTY_CALL ||
              call_type == Call::KEYED_PROPERTY_CALL ||
-             call_type == Call::RESOLVED_PROPERTY_CALL) {
+             call_type == Call::RESOLVED_PROPERTY_CALL) {    
     DCHECK(!implicit_undefined_receiver);
     builder()->CallProperty(callee, args,
                             feedback_index(feedback_spec()->AddCallICSlot()));
-  } else if (implicit_undefined_receiver) {
+  } else if (implicit_undefined_receiver) {    
     builder()->CallUndefinedReceiver(
         callee, args, feedback_index(feedback_spec()->AddCallICSlot()));
   } else {
@@ -3731,11 +4180,115 @@ void BytecodeGenerator::VisitCall(Call* expr) {
   }
 }
 
+
+
+
+
+
+std::string BytecodeGenerator::GetFullString(Expression* expr, Scope* scope, ParseInfo* info) {
+  Expression* target;
+  if(expr->IsProperty()) {
+    target = expr->AsProperty()->obj();
+    while(target->IsProperty()) {
+      target = target->AsProperty()->obj();
+    }
+  }
+  else
+    target = expr;
+  bool already_found = false;
+  std::string lhs_str = CheckDeclarationsInCurrentScope(info, target, expr->position(), &already_found);
+  lhs_str = TraverseDeclarationsInOuterScopes(scope->outer_scope(), info, target, &already_found) + lhs_str;   
+  return lhs_str;
+}
+
+
+
+
+
+std::string BytecodeGenerator::GetFullStringForRHS(Expression* expr, Scope* scope, ParseInfo* info) {
+  std::string prefix("");
+  std::string rhs_str = ExpressionPrinter(info->stack_limit()).Print(expr);
+  Expression *target;
+
+  if(!expr->IsVariableProxy() && !expr->IsProperty() && !expr->IsCall() && !expr->IsCallNew()) 
+    return rhs_str+",rhs_is_expr";
+  if(expr->IsVariableProxy()) {
+    target = expr->AsVariableProxy();
+    prefix = GetFullString(target, scope, info);
+    prefix += rhs_str;
+    prefix += ",rhs_is_var";
+  }
+  else if(expr->IsProperty()) {
+    target = expr->AsProperty()->obj();
+    while(target->IsProperty()) {
+      target = target->AsProperty()->obj();
+    }
+    prefix = GetFullString(target, scope, info);
+    prefix += rhs_str;
+    prefix += ",rhs_is_prop";
+  }
+  else {
+    Expression* callee_expr;
+    ZonePtrList<Expression>* args_list;
+    if(expr->IsCall()) {
+      callee_expr = expr->AsCall()->expression();
+      args_list = expr->AsCall()->arguments();
+    }   
+    else {
+      callee_expr = expr->AsCallNew()->expression();
+      args_list = expr->AsCallNew()->arguments();
+    }
+
+    std::string current_callee_name = ExpressionPrinter(info->stack_limit()).Print(callee_expr);
+    bool is_anonymous_function =  callee_expr->IsFunctionLiteral() && callee_expr->AsFunctionLiteral()->is_anonymous_expression();
+
+    if(is_anonymous_function)
+      prefix = std::to_string(callee_expr->AsFunctionLiteral()->function_id());
+    else
+      prefix = current_callee_name;
+
+    bool is_function_member = false;
+    if(callee_expr->IsProperty()) {
+      std::list<std::string> declared_vars = scope->declared_vars();
+      Expression* target = callee_expr->AsProperty()->obj();
+      bool already_found = false;
+      std::string decl_str = CheckDeclarationsInCurrentScope(info, target, expr->position(), &already_found);
+      decl_str = TraverseDeclarationsInOuterScopes(scope->outer_scope(), info, target, &already_found) + decl_str;
+      if(already_found)
+        is_function_member = true; 
+    }
+
+
+    if(std::find(declared_functions.begin(), declared_functions.end(), current_callee_name) != declared_functions.end() || is_anonymous_function || is_function_member) {
+      prefix += "{";
+      for (int i = 0; i < static_cast<int>(args_list->length()); i++) {
+        prefix += GetFullString(args_list->at(i), scope, info);
+        prefix += ExpressionPrinter(info->stack_limit()).Print(args_list->at(i));
+        if(i!=static_cast<int>(args_list->length())-1)
+          prefix += "--";
+      }
+      prefix += "}"; 
+    }
+    prefix += ",rhs_is_call";
+  }
+  return prefix;
+}
+
+
+
+
+
 void BytecodeGenerator::VisitCallSuper(Call* expr) {
   RegisterAllocationScope register_scope(this);
   SuperCallReference* super = expr->expression()->AsSuperCallReference();
   ZonePtrList<Expression>* args = expr->arguments();
 
+
+  ParseInfo* parse_info = compilation_info()->parse_info();
+  if(parse_info->script_id()>=17 && expr->should_inject_mark() && expr->should_inject())
+    ExpressionConverter(parse_info->stack_limit(), parse_info, info(), closure_scope()).Print(expr);
+
+
   int first_spread_index = 0;
   for (; first_spread_index < args->length(); first_spread_index++) {
     if (args->at(first_spread_index)->IsSpread()) break;
@@ -3818,9 +4371,35 @@ void BytecodeGenerator::VisitCallSuper(Call* expr) {
     BuildInstanceFieldInitialization(this_function, instance);
     builder()->LoadAccumulatorWithRegister(instance);
   }
+
+
+  if(parse_info->script_id()>=17 && expr->should_start_log()) {
+    std::list<Expression*> log_calls = AsglogsGenerator(parse_info->stack_limit(), parse_info, info(), closure_scope()).Print(expr);
+    std::list<Expression*>::iterator ir;
+    for (ir =log_calls.begin(); ir!=log_calls.end(); ir++) {
+      if((*ir)->is_child())
+	      (*ir)->set_is_child(false); 
+      if((*ir)->IsAssignment() && (*ir)->AsAssignment()->target()->has_logged())
+	      (*ir)->AsAssignment()->target()->set_has_logged(false);
+      Visit(*ir);
+    }   
+  }
+
+
+
 }
 
 void BytecodeGenerator::VisitCallNew(CallNew* expr) {
+  
+
+  ParseInfo* parse_info = compilation_info()->parse_info();  
+
+
+
+  if(parse_info->script_id() >= 17 && expr->should_inject())
+    ExpressionConverter(parse_info->stack_limit(), parse_info, info(), closure_scope()).Print(expr);
+
+
   Register constructor = VisitForRegisterValue(expr->expression());
   RegisterList args = register_allocator()->NewGrowableRegisterList();
   VisitArguments(expr->arguments(), &args);
@@ -3836,6 +4415,20 @@ void BytecodeGenerator::VisitCallNew(CallNew* expr) {
   } else {
     builder()->Construct(constructor, args, feedback_slot_index);
   }
+
+  
+  if(parse_info->script_id() >= 17 && expr->should_start_log()) {
+    std::list<Expression*> log_calls = AsglogsGenerator(parse_info->stack_limit(), parse_info, info(), closure_scope()).Print(expr);
+    std::list<Expression*>::iterator ir; 
+    for (ir =log_calls.begin(); ir!=log_calls.end(); ir++) {
+      if((*ir)->is_child())
+        (*ir)->set_is_child(false);
+      if((*ir)->IsAssignment() && (*ir)->AsAssignment()->target()->has_logged())
+	      (*ir)->AsAssignment()->target()->set_has_logged(false);
+      Visit(*ir);
+    } 
+  }
+
 }
 
 void BytecodeGenerator::VisitCallRuntime(CallRuntime* expr) {
@@ -3858,9 +4451,11 @@ void BytecodeGenerator::VisitVoid(UnaryOperation* expr) {
 }
 
 void BytecodeGenerator::VisitForTypeOfValue(Expression* expr) {
+
   if (expr->IsVariableProxy()) {
     // Typeof does not throw a reference error on global variables, hence we
     // perform a non-contextual load in case the operand is a variable proxy.
+
     VariableProxy* proxy = expr->AsVariableProxy();
     BuildVariableLoadForAccumulatorValue(proxy->var(), proxy->hole_check_mode(),
                                          INSIDE_TYPEOF);
diff --git a/src/interpreter/bytecode-generator.h b/src/interpreter/bytecode-generator.h
index 3150245..6040aca 100644
--- a/src/interpreter/bytecode-generator.h
+++ b/src/interpreter/bytecode-generator.h
@@ -12,6 +12,9 @@
 #include "src/interpreter/bytecode-register.h"
 #include "src/interpreter/bytecodes.h"
 
+#include "src/interpreter/global_ids.h"
+
+
 namespace v8 {
 namespace internal {
 
@@ -34,7 +37,7 @@ class BytecodeGenerator final : public AstVisitor<BytecodeGenerator> {
       const AstStringConstants* ast_string_constants,
       ZoneVector<FunctionLiteral*>* eager_inner_literals);
 
-  void GenerateBytecode(uintptr_t stack_limit);
+  void GenerateBytecode(uintptr_t stack_limit, bool should_inject = true);
   Handle<BytecodeArray> FinalizeBytecode(Isolate* isolate,
                                          Handle<Script> script);
 
@@ -44,8 +47,9 @@ class BytecodeGenerator final : public AstVisitor<BytecodeGenerator> {
 
   // Visiting function for declarations list and statements are overridden.
   void VisitDeclarations(Declaration::List* declarations);
-  void VisitStatements(ZonePtrList<Statement>* statments);
+  void VisitStatements(ZonePtrList<Statement>* statments, bool should_inject = true);
 
+  UnoptimizedCompilationInfo* compilation_info() const {return info_;}
  private:
   class ContextScope;
   class ControlScope;
@@ -70,9 +74,10 @@ class BytecodeGenerator final : public AstVisitor<BytecodeGenerator> {
   enum class TestFallthrough { kThen, kElse, kNone };
   enum class TypeHint { kAny, kBoolean, kString };
 
-  void GenerateBytecodeBody();
+  void GenerateBytecodeBody(bool should_inject = true);
   void AllocateDeferredConstants(Isolate* isolate, Handle<Script> script);
 
+  //DEFINE_AST_VISITOR_SUBCLASS_MEMBERS(bool should_inject = true);
   DEFINE_AST_VISITOR_SUBCLASS_MEMBERS();
 
   // Dispatched from VisitBinaryOperation.
@@ -255,12 +260,23 @@ class BytecodeGenerator final : public AstVisitor<BytecodeGenerator> {
   void VisitForAccumulatorValueOrTheHole(Expression* expr);
   V8_WARN_UNUSED_RESULT Register VisitForRegisterValue(Expression* expr);
   V8_INLINE void VisitForRegisterValue(Expression* expr, Register destination);
+
+  std::string ConvertIdentifierToString(const AstRawString* identifier);
+
   void VisitAndPushIntoRegisterList(Expression* expr, RegisterList* reg_list);
   void VisitForEffect(Expression* expr);
   void VisitForTest(Expression* expr, BytecodeLabels* then_labels,
                     BytecodeLabels* else_labels, TestFallthrough fallthrough);
 
   void VisitInSameTestExecutionScope(Expression* expr);
+  
+  void BreakNestedAssignment(Assignment* expr, std::list<Expression*>* decomposed_exprs); 
+  void VisitAssignmentInternal(Assignment* expr);
+  void ConvertAssignment(Assignment* expr, int rand_postfix, ParseInfo* parse_info, AstValueFactory* ast_value_factory, AstNodeFactory* ast_node_factory, DeclarationScope* scope, Parser* new_parser); 
+  std::string TraverseDeclarationsInOuterScopes(Scope* scope, ParseInfo* info, Expression* expr, bool* already_found);
+  std::string CheckDeclarationsInCurrentScope(ParseInfo* info, Expression* expr, int asg_pos, bool* already_found);
+  std::string GetFullString(Expression* expr, Scope* scope, ParseInfo* info); // if expr_name is defined in function B, which is an inner function in function A, return A.B.expr_name
+  std::string GetFullStringForRHS(Expression* expr, Scope* scope, ParseInfo* info); // the right hand side may be an expr, or simply var or attribute. we use this function to handle it separately.
 
   Register GetRegisterForLocalVariable(Variable* variable);
 
@@ -381,6 +397,16 @@ class BytecodeGenerator final : public AstVisitor<BytecodeGenerator> {
   int loop_depth_;
 
   HandlerTable::CatchPrediction catch_prediction_;
+
+  Expression* func_call_;
+  std::string script_url_;
+  ParseInfo* parse_info_;
+  AstValueFactory* ast_value_factory_;
+  AstNodeFactory* ast_node_factory_;
+  DeclarationScope* parse_scope_;
+  Parser* new_parser_;
+  Expression* get_id_call_;
+  Expression* inc_id_call_;
 };
 
 }  // namespace interpreter
diff --git a/src/interpreter/global_ids.cc b/src/interpreter/global_ids.cc
new file mode 100644
index 0000000..c857b44
--- /dev/null
+++ b/src/interpreter/global_ids.cc
@@ -0,0 +1,4 @@
+#include "src/interpreter/global_ids.h"
+
+std::mutex gmutex;
+int assign_id = 0; 
diff --git a/src/interpreter/global_ids.h b/src/interpreter/global_ids.h
new file mode 100644
index 0000000..5f49df1
--- /dev/null
+++ b/src/interpreter/global_ids.h
@@ -0,0 +1,3 @@
+#include <mutex>
+extern std::mutex gmutex;
+extern int assign_id;
diff --git a/src/interpreter/interpreter.cc b/src/interpreter/interpreter.cc
index ca53fa6..57acc06 100644
--- a/src/interpreter/interpreter.cc
+++ b/src/interpreter/interpreter.cc
@@ -34,7 +34,7 @@ class InterpreterCompilationJob final : public UnoptimizedCompilationJob {
                             ZoneVector<FunctionLiteral*>* eager_inner_literals);
 
  protected:
-  Status ExecuteJobImpl() final;
+  Status ExecuteJobImpl(bool should_inject = true) final;
   Status FinalizeJobImpl(Handle<SharedFunctionInfo> shared_info,
                          Isolate* isolate) final;
 
@@ -176,7 +176,7 @@ InterpreterCompilationJob::InterpreterCompilationJob(
       generator_(&compilation_info_, parse_info->ast_string_constants(),
                  eager_inner_literals) {}
 
-InterpreterCompilationJob::Status InterpreterCompilationJob::ExecuteJobImpl() {
+InterpreterCompilationJob::Status InterpreterCompilationJob::ExecuteJobImpl(bool should_inject) {
   RuntimeCallTimerScope runtimeTimerScope(
       parse_info()->runtime_call_stats(),
       parse_info()->on_background_thread()
diff --git a/src/objects.cc b/src/objects.cc
index 6ccdbf4..9e64ce1 100644
--- a/src/objects.cc
+++ b/src/objects.cc
@@ -1,7 +1,7 @@
 // Copyright 2015 the V8 project authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-
+#include <iostream>
 #include "src/objects.h"
 
 #include <cmath>
@@ -7014,6 +7014,14 @@ Object* JSReceiver::DefineProperty(Isolate* isolate, Handle<Object> object,
   return *object;
 }
 
+MaybeHandle<String> JSReceiver::GetGlobalId(Isolate* isolate, Handle<Object> object) {
+  uintptr_t addr_t = reinterpret_cast<uintptr_t>(*(object.location()));
+  char buffer[20];
+  sprintf(buffer, "0x%lX", addr_t);
+  Handle<String> result = isolate->factory()->InternalizeUtf8String(buffer);
+  return result;
+}
+
 
 // ES6 19.1.2.3.1
 // static
diff --git a/src/objects/js-objects-inl.h b/src/objects/js-objects-inl.h
index 5348313..4b405bd 100644
--- a/src/objects/js-objects-inl.h
+++ b/src/objects/js-objects-inl.h
@@ -46,7 +46,7 @@ MaybeHandle<Object> JSReceiver::GetElement(Isolate* isolate,
                                            Handle<JSReceiver> receiver,
                                            uint32_t index) {
   LookupIterator it(isolate, receiver, index, receiver);
-  if (!it.IsFound()) return it.factory()->undefined_value();
+  if (!it.IsFound()) return it.factory()->undefined_value();  
   return Object::GetProperty(&it);
 }
 
diff --git a/src/objects/js-objects.h b/src/objects/js-objects.h
index 586fe75..c1b89f9 100644
--- a/src/objects/js-objects.h
+++ b/src/objects/js-objects.h
@@ -126,6 +126,8 @@ class JSReceiver : public HeapObject, public NeverReadOnlySpaceObject {
   V8_WARN_UNUSED_RESULT static Object* DefineProperty(
       Isolate* isolate, Handle<Object> object, Handle<Object> name,
       Handle<Object> attributes);
+  V8_WARN_UNUSED_RESULT static MaybeHandle<String> GetGlobalId(
+      Isolate* isolate, Handle<Object> object);
   V8_WARN_UNUSED_RESULT static MaybeHandle<Object> DefineProperties(
       Isolate* isolate, Handle<Object> object, Handle<Object> properties);
 
@@ -147,6 +149,10 @@ class JSReceiver : public HeapObject, public NeverReadOnlySpaceObject {
       PropertyDescriptor* desc, ShouldThrow should_throw);
   V8_WARN_UNUSED_RESULT static Maybe<bool> OrdinaryDefineOwnProperty(
       LookupIterator* it, PropertyDescriptor* desc, ShouldThrow should_throw);
+  V8_WARN_UNUSED_RESULT static Maybe<bool> CustomDefineOwnProperty(
+      Isolate* isolate, Handle<JSObject> object, Handle<Object> key,
+      PropertyDescriptor* desc, ShouldThrow should_throw);
+  
   // ES6 9.1.6.2
   V8_WARN_UNUSED_RESULT static Maybe<bool> IsCompatiblePropertyDescriptor(
       Isolate* isolate, bool extensible, PropertyDescriptor* desc,
diff --git a/src/objects/scope-info.cc b/src/objects/scope-info.cc
index 0fa5557..be6e93a 100644
--- a/src/objects/scope-info.cc
+++ b/src/objects/scope-info.cc
@@ -705,10 +705,10 @@ int ScopeInfo::ContextSlotIndex(Handle<ScopeInfo> scope_info,
                                 Handle<String> name, VariableMode* mode,
                                 InitializationFlag* init_flag,
                                 MaybeAssignedFlag* maybe_assigned_flag) {
-  DCHECK(name->IsInternalizedString());
-  DCHECK_NOT_NULL(mode);
-  DCHECK_NOT_NULL(init_flag);
-  DCHECK_NOT_NULL(maybe_assigned_flag);
+  DCHECK(name->IsInternalizedString());  
+  DCHECK_NOT_NULL(mode);  
+  DCHECK_NOT_NULL(init_flag);  
+  DCHECK_NOT_NULL(maybe_assigned_flag);  
 
   if (scope_info->length() == 0) return -1;
 
@@ -725,8 +725,10 @@ int ScopeInfo::ContextSlotIndex(Handle<ScopeInfo> scope_info,
   Isolate* isolate = Heap::FromWritableHeapObject(*scope_info)->isolate();
 
   ContextSlotCache* context_slot_cache = isolate->context_slot_cache();
+  
   int result = context_slot_cache->Lookup(*scope_info, *name, mode, init_flag,
                                           maybe_assigned_flag);
+
   if (result != ContextSlotCache::kNotFound) {
     DCHECK_LT(result, scope_info->ContextLength());
     return result;
@@ -734,6 +736,7 @@ int ScopeInfo::ContextSlotIndex(Handle<ScopeInfo> scope_info,
 
   int start = scope_info->ContextLocalNamesIndex();
   int end = start + scope_info->ContextLocalCount();
+  
   for (int i = start; i < end; ++i) {
     if (*name == scope_info->get(i)) {
       int var = i - start;
diff --git a/src/parsing/asglogs-generator.cc b/src/parsing/asglogs-generator.cc
new file mode 100644
index 0000000..02cd4c1
--- /dev/null
+++ b/src/parsing/asglogs-generator.cc
@@ -0,0 +1,952 @@
+// Copyright 2012 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "src/parsing/asglogs-generator.h"
+#include "src/parsing/expression-printer.h"
+#include "src/parsing/expression-converter.h"
+
+#include <stdarg.h>
+
+#include "src/ast/ast-value-factory.h"
+#include "src/ast/scopes.h"
+#include "src/base/platform/platform.h"
+#include "src/globals.h"
+#include "src/objects-inl.h"
+#include "src/string-builder-inl.h"
+
+namespace v8 {
+namespace internal {
+
+
+//-----------------------------------------------------------------------------
+std::string AsglogsGenerator::GetFullString(Expression* expr, Scope* scope, ParseInfo* info) {
+  Expression* target;
+  if(expr->IsProperty()) {
+    target = expr->AsProperty()->obj();
+    while(target->IsProperty()) {
+      target = target->AsProperty()->obj();
+    }
+  }
+  else
+    target = expr;
+  bool already_found = false;
+  std::string lhs_str = CheckDeclarationsInCurrentScope(info, target, expr->position(), &already_found);
+  lhs_str = TraverseDeclarationsInOuterScopes(scope->outer_scope(), info, target, &already_found) + lhs_str;   
+  //lhs_str += ExpressionPrinter(info->stack_limit()).Print(expr); 
+  return lhs_str;
+}
+
+
+std::string AsglogsGenerator::CheckDeclarationsInCurrentScope(ParseInfo* parse_info, Expression* expr, int asg_pos, bool *already_found) {
+  std::string prefix("");
+  std::list<Expression*> declared_vars = parse_info->declared_vars();
+  std::list<Expression*>::iterator i;
+
+  for(i=declared_vars.begin(); i!=declared_vars.end(); ++i) {
+    if(std::string(ExpressionPrinter(parse_info->stack_limit()).Print(*i)) == std::string(ExpressionPrinter(parse_info->stack_limit()).Print(expr))) {
+      *already_found = true;
+      if(!info_->literal()->is_anonymous_expression() && parse_info->scope()->scope_type() == ScopeType::FUNCTION_SCOPE && closure_scope_->scope_type() == ScopeType::FUNCTION_SCOPE) {
+        std::string func_name(info_->literal()->GetDebugName().get());
+        prefix += func_name;
+        prefix += "-";
+      }
+      else if(!parse_info->scope()->is_script_scope() || !closure_scope_->is_script_scope()) {
+        prefix += std::to_string(info_->literal()->function_id());
+        prefix += "-";
+      }
+      break;
+    }
+  }
+  return prefix;
+}
+
+
+// for expr->target() that is marked as global but is not in the script_scope
+// we need to further check if it's actually:
+// var a; a = "xxx"; in this case, a is still marked as global, but it has been declared as local before the assignment expr
+std::string AsglogsGenerator::TraverseDeclarationsInOuterScopes(Scope* scope, ParseInfo* info, Expression* expr, bool* already_found) {
+  std::string prefix("");
+  bool got_func_name = false;
+
+  while(scope) {
+    std::list<std::string> declared_vars = scope->declared_vars();
+    std::list<std::string>::iterator i;
+    got_func_name = false;
+
+    if(scope->scope_type() == ScopeType::SCRIPT_SCOPE)
+      break;
+
+    if(*already_found) {
+      if(scope->scope_type() == ScopeType::FUNCTION_SCOPE) {
+        std::string func_name(scope->scope_info()->FunctionDebugName()->ToCString().get());
+        if(!func_name.empty()) {
+          prefix += func_name;
+          prefix += "-";
+          got_func_name = true;
+        }
+      }
+      if(!got_func_name) {
+        if (!scope->is_script_scope()){
+          prefix += "{";
+          prefix += std::to_string(scope->scope_info()->StartPosition());
+          prefix += "-";
+          prefix += std::to_string(scope->scope_info()->EndPosition());
+          prefix += "}-";
+        }
+      }
+    }
+    else {
+      for(i=declared_vars.begin(); i!=declared_vars.end(); i++) {
+        if(*i == std::string(ExpressionPrinter(info->stack_limit()).Print(expr))) {
+          if(scope->scope_type() == ScopeType::FUNCTION_SCOPE) {
+            std::string func_name(scope->scope_info()->FunctionDebugName()->ToCString().get());
+            if(!func_name.empty()) {
+              prefix += func_name;
+              prefix += "-";
+              got_func_name = true;
+            }
+          }
+          if(!got_func_name) {
+            if(!scope->is_script_scope()){
+              prefix += "{";
+              prefix += std::to_string(scope->scope_info()->StartPosition());
+              prefix += "-";
+              prefix += std::to_string(scope->scope_info()->EndPosition());
+              prefix += "}-";
+            }
+          }
+          *already_found = true;
+          break;
+        }
+      }
+    }
+    scope = scope->outer_scope();
+  }
+  return prefix;
+}
+
+
+
+std::string AsglogsGenerator::GetFullStringForRHS(Expression* expr, Scope* scope, ParseInfo* info) {
+  std::string prefix("");
+  std::string rhs_str = ExpressionPrinter(info->stack_limit()).Print(expr);
+  Expression *target;
+
+  if(!expr->IsVariableProxy() && !expr->IsProperty() && !expr->IsCall() && !expr->IsCallNew()) 
+    return rhs_str+",rhs_is_expr";
+  if(expr->IsVariableProxy()) {
+    target = expr->AsVariableProxy();
+    prefix = GetFullString(target, scope, info);
+    prefix += rhs_str;
+    prefix += ",rhs_is_var";
+  }
+  else if(expr->IsProperty()) {
+    target = expr->AsProperty()->obj();
+    while(target->IsProperty()) {
+      target = target->AsProperty()->obj();
+    }
+    prefix = GetFullString(target, scope, info);
+    prefix += rhs_str;
+
+    prefix += ",rhs_is_prop";
+  }
+  else {
+    Expression* callee_expr;
+    ZonePtrList<Expression>* args_list;
+    if(expr->IsCall()) {
+      callee_expr = expr->AsCall()->expression();
+      args_list = expr->AsCall()->arguments();
+    }   
+    else {
+      callee_expr = expr->AsCallNew()->expression();
+      args_list = expr->AsCallNew()->arguments();
+    }
+
+    std::string current_callee_name = ExpressionPrinter(info->stack_limit()).Print(callee_expr);
+    bool is_anonymous_function =  callee_expr->IsFunctionLiteral() && callee_expr->AsFunctionLiteral()->is_anonymous_expression();
+
+    if(is_anonymous_function)
+      prefix = std::to_string(callee_expr->AsFunctionLiteral()->function_id());
+    else
+      prefix = current_callee_name;
+
+    bool is_function_member = false;
+    if(callee_expr->IsProperty()) {
+      std::list<std::string> declared_vars = scope->declared_vars();
+      Expression* target = callee_expr->AsProperty()->obj();
+      bool already_found = false;
+      std::string decl_str = CheckDeclarationsInCurrentScope(info, target, expr->position(), &already_found);
+      decl_str = TraverseDeclarationsInOuterScopes(scope->outer_scope(), info, target, &already_found) + decl_str;
+      if(already_found)
+        is_function_member = true; 
+    }
+
+
+    if(std::find(declared_functions.begin(), declared_functions.end(), current_callee_name) != declared_functions.end() || is_anonymous_function || is_function_member) {
+      //prefix += rhs_str;
+      prefix += "{";
+      for (int i = 0; i < static_cast<int>(args_list->length()); i++) {
+        prefix += GetFullString(args_list->at(i), scope, info);
+        prefix += ExpressionPrinter(info->stack_limit()).Print(args_list->at(i));
+        if(i!=static_cast<int>(args_list->length())-1)
+          prefix += "--";
+      }
+      prefix += "}"; 
+    }
+    prefix += ",rhs_is_call";
+  }
+  return prefix;
+}
+
+
+
+
+std::list<Expression*> AsglogsGenerator::Print(AstNode* node) {
+  Init();
+
+  if(!info()->literal()->has_injected()) {
+    if(info()->parse_info()->script_id()>=17 && closure_scope()->scope_type() == ScopeType::FUNCTION_SCOPE) {
+      std::list<Expression*> asg_logs = info()->literal()->asglog_calls();
+      std::list<Expression*>::iterator it;
+      for(it=asg_logs.begin(); it!=asg_logs.end(); it++) {
+        log_calls_.push_back(*it); 
+      }
+    }
+    info()->literal()->set_has_injected(true);
+  }
+
+  info()->literal()->clear_asglog_calls();
+  Visit(node);
+  //return output_;
+  return log_calls_;
+}
+
+void AsglogsGenerator::Init() {
+  if (size_ == 0) {
+    DCHECK_NULL(output_);
+    const int initial_size = 256;
+    output_ = NewArray<char>(initial_size);
+    size_ = initial_size;
+  }
+  output_[0] = '\0';
+  pos_ = 0;
+}
+
+void AsglogsGenerator::Print(const char* format, ...) {
+  return;
+}
+
+void AsglogsGenerator::PrintLabels(ZonePtrList<const AstRawString>* labels) {
+  return;
+}
+
+void AsglogsGenerator::PrintLiteral(Literal* literal, bool quote) {
+  return;
+}
+
+void AsglogsGenerator::PrintLiteral(const AstRawString* value, bool quote) {
+  return;
+}
+
+void AsglogsGenerator::PrintLiteral(const AstConsString* value, bool quote) {
+  return;
+}
+
+
+//-----------------------------------------------------------------------------
+
+AsglogsGenerator::AsglogsGenerator(uintptr_t stack_limit, ParseInfo* parse_info, UnoptimizedCompilationInfo* info, Scope* closure_scope)
+    : output_(nullptr), size_(0), pos_(0), indent_(0), parse_info_(parse_info), closure_scope_(closure_scope), info_(info) {
+  log_calls_.clear();
+  InitializeAstVisitor(stack_limit);
+}
+
+AsglogsGenerator::~AsglogsGenerator() {
+  DCHECK_EQ(indent_, 0);
+  DeleteArray(output_);
+}
+
+
+void AsglogsGenerator::PrintIndented(const char* txt) {
+  Print("%s", txt);
+}
+
+void AsglogsGenerator::PrintLiteralIndented(const char* info, Literal* literal,
+                                      bool quote) {
+  PrintLiteral(literal, quote);
+}
+
+void AsglogsGenerator::PrintLiteralIndented(const char* info,
+                                      const AstRawString* value, bool quote) {
+  PrintLiteral(value, quote);  
+}
+
+void AsglogsGenerator::PrintLiteralIndented(const char* info,
+                                      const AstConsString* value, bool quote) {
+  PrintLiteral(value, quote);  
+}
+
+void AsglogsGenerator::PrintLiteralWithModeIndented(const char* info, Variable* var,
+                                              const AstRawString* value) {
+  if (var == nullptr) {
+    PrintLiteralIndented(info, value, true);
+  } else {
+    EmbeddedVector<char, 256> buf;
+    PrintLiteralIndented(buf.start(), value, true);
+  }
+}
+
+void AsglogsGenerator::PrintLabelsIndented(ZonePtrList<const AstRawString>* labels,
+                                     const char* prefix) {
+  if (labels == nullptr || labels->length() == 0) return;
+  PrintLabels(labels);
+}
+
+
+void AsglogsGenerator::PrintIndentedVisit(const char* s, AstNode* node) {
+  if (node != nullptr) {
+    Visit(node);
+  }
+}
+
+
+std::list<Expression*> AsglogsGenerator::PrintProgram(FunctionLiteral* program) {
+  Init();
+  { 
+    PrintLiteralIndented("NAME", program->raw_name(), true);
+    if (program->raw_inferred_name()) {
+      PrintLiteralIndented("INFERRED NAME", program->raw_inferred_name(), true);
+    }
+    if (program->requires_instance_fields_initializer()) {
+    }    
+    PrintParameters(program->scope());    
+    PrintDeclarations(program->scope()->declarations());
+    PrintStatements(program->body());
+  }
+  return log_calls_;
+}
+
+
+void AsglogsGenerator::PrintOut(Isolate* isolate, AstNode* node) {
+  return;
+}
+
+void AsglogsGenerator::PrintDeclarations(Declaration::List* declarations) {
+  if (!declarations->is_empty()) {
+    for (Declaration* decl : *declarations) Visit(decl);
+  }
+}
+
+void AsglogsGenerator::PrintParameters(DeclarationScope* scope) {
+  if (scope->num_parameters() > 0) {
+    for (int i = 0; i < scope->num_parameters(); i++) {
+      PrintLiteralWithModeIndented("VAR", scope->parameter(i),
+                                   scope->parameter(i)->raw_name());
+      if(i != scope->num_parameters()-1) {
+      }
+    }
+  }
+}
+
+void AsglogsGenerator::PrintStatements(ZonePtrList<Statement>* statements) {
+  for (int i = 0; i < statements->length(); i++) {
+    Visit(statements->at(i));
+  }
+}
+
+void AsglogsGenerator::PrintArguments(ZonePtrList<Expression>* arguments) {
+  for (int i = 0; i < arguments->length(); i++) {
+    Visit(arguments->at(i));
+    if(i!=arguments->length()-1) {
+    }
+  }
+}
+
+
+void AsglogsGenerator::VisitBlock(Block* node) {
+  PrintLabelsIndented(node->labels());
+  PrintStatements(node->statements());
+}
+
+
+void AsglogsGenerator::VisitVariableDeclaration(VariableDeclaration* node) {
+  PrintLiteralWithModeIndented("VARIABLE", node->proxy()->var(),
+                               node->proxy()->raw_name());
+}
+
+
+void AsglogsGenerator::VisitFunctionDeclaration(FunctionDeclaration* node) {
+  PrintLiteral(node->proxy()->raw_name(), true);
+  PrintLiteral(node->fun()->raw_name(), false);
+}
+
+
+void AsglogsGenerator::VisitExpressionStatement(ExpressionStatement* node) {
+  Visit(node->expression());
+}
+
+
+void AsglogsGenerator::VisitEmptyStatement(EmptyStatement* node) {
+}
+
+
+void AsglogsGenerator::VisitSloppyBlockFunctionStatement(
+    SloppyBlockFunctionStatement* node) {
+  Visit(node->statement());
+}
+
+
+void AsglogsGenerator::VisitIfStatement(IfStatement* node) {
+  PrintIndentedVisit("CONDITION", node->condition());
+  PrintIndentedVisit("THEN", node->then_statement());
+  if (node->HasElseStatement()) {
+    PrintIndentedVisit("ELSE", node->else_statement());
+  }
+
+  std::list<Expression*> asg_log_calls = node->asglog_calls();
+  if(parse_info_->script_id()>=17 && asg_log_calls.size()>0) {
+    std::list<Expression*>::iterator it;
+    for(it=asg_log_calls.begin(); it!=asg_log_calls.end(); it++) {
+      log_calls_.push_back(*it);
+    }
+  }
+  node->clear_asglog_calls();
+}
+
+
+void AsglogsGenerator::VisitContinueStatement(ContinueStatement* node) {
+  PrintLabelsIndented(node->target()->labels());
+}
+
+
+void AsglogsGenerator::VisitBreakStatement(BreakStatement* node) {
+  PrintLabelsIndented(node->target()->labels());
+}
+
+
+void AsglogsGenerator::VisitReturnStatement(ReturnStatement* node) {
+  Visit(node->expression());
+    
+  std::list<Expression*> asg_log_calls = node->asglog_calls();
+  if(parse_info_->script_id()>=17 && asg_log_calls.size()>0) {
+    std::list<Expression*>::iterator it;
+    for(it=asg_log_calls.begin(); it!=asg_log_calls.end(); it++) {
+      log_calls_.push_back(*it);
+    }
+  }
+  node->clear_asglog_calls();
+}
+
+
+void AsglogsGenerator::VisitWithStatement(WithStatement* node) {
+  PrintIndentedVisit("OBJECT", node->expression());
+  PrintIndentedVisit("BODY", node->statement());
+}
+
+
+void AsglogsGenerator::VisitSwitchStatement(SwitchStatement* node) {
+  PrintLabelsIndented(node->labels());
+  for (CaseClause* clause : *node->cases()) {
+    if (clause->is_default()) {
+      PrintStatements(clause->statements());
+    } else {
+      Visit(clause->label());
+      PrintStatements(clause->statements());
+    }
+  }
+  if(parse_info_->script_id()>=17) {
+    std::list<Expression*> asg_log_calls = node->asglog_calls();
+    if(parse_info_->script_id()>=17 && asg_log_calls.size()>0) {
+      std::list<Expression*>::iterator it;
+      for(it=asg_log_calls.begin(); it!=asg_log_calls.end(); it++) {
+        log_calls_.push_back(*it);
+      }
+    }
+  }
+  node->clear_asglog_calls();
+}
+
+
+
+void AsglogsGenerator::VisitDoWhileStatement(DoWhileStatement* node) {
+  PrintLabelsIndented(node->labels());
+  PrintLabelsIndented(node->own_labels(), "OWN ");
+  PrintIndentedVisit("BODY", node->body());
+  PrintIndentedVisit("COND", node->cond());
+}
+
+
+void AsglogsGenerator::VisitWhileStatement(WhileStatement* node) {
+  PrintLabelsIndented(node->labels());
+  PrintLabelsIndented(node->own_labels(), "OWN ");
+  PrintIndentedVisit("COND", node->cond());
+  PrintIndentedVisit("BODY", node->body());
+}
+
+
+void AsglogsGenerator::VisitForStatement(ForStatement* node) {
+  PrintLabelsIndented(node->labels());
+  PrintLabelsIndented(node->own_labels(), "OWN ");
+  if (node->init()) PrintIndentedVisit("INIT", node->init());
+  if (node->cond()) PrintIndentedVisit("COND", node->cond());
+  if (node->next()) PrintIndentedVisit("NEXT", node->next());
+  PrintIndentedVisit("BODY", node->body());
+}
+
+
+void AsglogsGenerator::VisitForInStatement(ForInStatement* node) {
+  PrintLabelsIndented(node->labels());
+  PrintLabelsIndented(node->own_labels(), "OWN ");
+  PrintIndentedVisit("FOR", node->each());
+  PrintIndentedVisit("IN", node->enumerable());
+  PrintIndentedVisit("BODY", node->body());
+}
+
+
+void AsglogsGenerator::VisitForOfStatement(ForOfStatement* node) {
+  PrintLabelsIndented(node->labels());
+  PrintLabelsIndented(node->own_labels(), "OWN ");
+  PrintIndentedVisit("INIT", node->assign_iterator());
+  PrintIndentedVisit("NEXT", node->next_result());
+  PrintIndentedVisit("DONE", node->result_done());
+  PrintIndentedVisit("EACH", node->assign_each());
+  PrintIndentedVisit("BODY", node->body());
+}
+
+
+void AsglogsGenerator::VisitTryCatchStatement(TryCatchStatement* node) {
+  PrintIndentedVisit("TRY", node->try_block());
+  const char* prediction = "";
+  switch (node->GetCatchPrediction(HandlerTable::UNCAUGHT)) {
+    case HandlerTable::UNCAUGHT:
+      prediction = "UNCAUGHT";
+      break;
+    case HandlerTable::CAUGHT:
+      prediction = "CAUGHT";
+      break;
+    case HandlerTable::DESUGARING:
+      prediction = "DESUGARING";
+      break;
+    case HandlerTable::ASYNC_AWAIT:
+      prediction = "ASYNC_AWAIT";
+      break;
+    case HandlerTable::PROMISE:
+      UNREACHABLE();
+  }
+  if (node->scope()) {
+    PrintLiteralWithModeIndented("CATCHVAR", node->scope()->catch_variable(),
+                                 node->scope()->catch_variable()->raw_name());
+  }
+  PrintIndentedVisit("CATCH", node->catch_block());
+}
+
+void AsglogsGenerator::VisitTryFinallyStatement(TryFinallyStatement* node) {
+  PrintIndentedVisit("TRY", node->try_block());
+  PrintIndentedVisit("FINALLY", node->finally_block());
+}
+
+
+
+
+void AsglogsGenerator::VisitDebuggerStatement(DebuggerStatement* node) {
+}
+
+
+void AsglogsGenerator::VisitFunctionLiteral(FunctionLiteral* node) {
+  PrintLiteralIndented("NAME", node->raw_name(), false);
+  PrintParameters(node->scope());
+  
+  if(!info()->literal()->has_injected()) {
+    if(info()->parse_info()->script_id()>=17 && closure_scope()->scope_type() == ScopeType::FUNCTION_SCOPE) {
+      std::list<Expression*> asg_logs = info()->literal()->asglog_calls();
+      std::list<Expression*>::iterator it;
+      for(it=asg_logs.begin(); it!=asg_logs.end(); it++) {
+        log_calls_.push_back(*it); 
+      }
+    }
+    info()->literal()->set_has_injected(true);
+  }
+  node->clear_asglog_calls();
+}
+
+
+void AsglogsGenerator::VisitClassLiteral(ClassLiteral* node) {
+  PrintLiteralIndented("NAME", node->constructor()->raw_name(), false);
+  if (node->extends() != nullptr) {
+    PrintIndentedVisit("EXTENDS", node->extends());
+  }
+
+  if (node->static_fields_initializer() != nullptr) {
+    PrintIndentedVisit("STATIC FIELDS INITIALIZER",
+                       node->static_fields_initializer());
+  }
+  if (node->instance_fields_initializer_function() != nullptr) {
+    PrintIndentedVisit("INSTANCE FIELDS INITIALIZER",
+                       node->instance_fields_initializer_function());
+  }
+  PrintClassProperties(node->properties());
+}
+
+void AsglogsGenerator::VisitInitializeClassFieldsStatement(
+    InitializeClassFieldsStatement* node) {
+  PrintClassProperties(node->fields());
+}
+
+void AsglogsGenerator::PrintClassProperties(
+    ZonePtrList<ClassLiteral::Property>* properties) {
+
+  for (int i = 0; i < properties->length(); i++) {
+    ClassLiteral::Property* property = properties->at(i);
+    switch (property->kind()) {
+      case ClassLiteral::Property::METHOD:
+        break;
+      case ClassLiteral::Property::GETTER:
+        break;
+      case ClassLiteral::Property::SETTER:
+        break;
+      case ClassLiteral::Property::PUBLIC_FIELD:
+        break;
+      case ClassLiteral::Property::PRIVATE_FIELD:
+        break;
+    }
+    EmbeddedVector<char, 128> buf;
+    PrintIndentedVisit("KEY", properties->at(i)->key());
+    PrintIndentedVisit("VALUE", properties->at(i)->value());
+  }
+}
+
+
+void AsglogsGenerator::VisitNativeFunctionLiteral(NativeFunctionLiteral* node) {
+  PrintLiteralIndented("NAME", node->raw_name(), false);
+}
+
+
+void AsglogsGenerator::VisitDoExpression(DoExpression* node) {
+  PrintStatements(node->block()->statements());
+}
+
+
+void AsglogsGenerator::VisitConditional(Conditional* node) {
+  PrintIndentedVisit("CONDITION", node->condition());
+  PrintIndentedVisit("THEN", node->then_expression());
+  PrintIndentedVisit("ELSE", node->else_expression());
+
+
+  if(parse_info_->script_id()>=17) {
+    std::list<Expression*> asg_log_calls = node->asglog_calls();
+    if(parse_info_->script_id()>=17 && asg_log_calls.size()>0) {
+      std::list<Expression*>::iterator it;
+      for(it=asg_log_calls.begin(); it!=asg_log_calls.end(); it++) {
+        log_calls_.push_back(*it);
+      }
+    }
+  }
+  node->clear_asglog_calls();
+}
+
+
+void AsglogsGenerator::VisitLiteral(Literal* node) {
+  PrintLiteralIndented("LITERAL", node, true);
+}
+
+
+void AsglogsGenerator::VisitRegExpLiteral(RegExpLiteral* node) {
+  PrintLiteralIndented("PATTERN", node->raw_pattern(), false);
+  int i = 0;
+  EmbeddedVector<char, 128> buf;
+  if (node->flags() & RegExp::kGlobal) buf[i++] = 'g';
+  if (node->flags() & RegExp::kIgnoreCase) buf[i++] = 'i';
+  if (node->flags() & RegExp::kMultiline) buf[i++] = 'm';
+  if (node->flags() & RegExp::kUnicode) buf[i++] = 'u';
+  if (node->flags() & RegExp::kSticky) buf[i++] = 'y';
+  buf[i] = '\0';
+}
+
+
+void AsglogsGenerator::VisitObjectLiteral(ObjectLiteral* node) {
+
+  if(node->has_print_name())
+    PrintLiteral(node->print_name(), false);
+  else {
+    PrintObjectProperties(node->properties());
+  }
+
+  std::list<Expression*> asg_log_calls = node->asglog_calls();
+  if(parse_info_->script_id()>=17 && asg_log_calls.size()>0) {
+    std::list<Expression*>::iterator it;
+    for(it=asg_log_calls.begin(); it!=asg_log_calls.end(); it++) {
+      log_calls_.push_back(*it);
+    }
+  }
+  node->clear_asglog_calls();
+}
+
+void AsglogsGenerator::PrintObjectProperties(
+    ZonePtrList<ObjectLiteral::Property>* properties) {
+  for (int i = 0; i < properties->length(); i++) {
+    ObjectLiteral::Property* property = properties->at(i);
+    switch (property->kind()) {
+      case ObjectLiteral::Property::CONSTANT:
+        break;
+      case ObjectLiteral::Property::COMPUTED:
+        break;
+      case ObjectLiteral::Property::MATERIALIZED_LITERAL:
+        break;
+      case ObjectLiteral::Property::PROTOTYPE:
+        break;
+      case ObjectLiteral::Property::GETTER:
+        break;
+      case ObjectLiteral::Property::SETTER:
+        break;
+      case ObjectLiteral::Property::SPREAD:
+        break;
+    }
+    EmbeddedVector<char, 128> buf;
+    PrintIndentedVisit("KEY", properties->at(i)->key());
+    PrintIndentedVisit("VALUE", properties->at(i)->value());
+  }
+}
+
+
+void AsglogsGenerator::VisitArrayLiteral(ArrayLiteral* node) {
+  if (node->values()->length() > 0) {
+    for (int i = 0; i < node->values()->length(); i++) {
+      Visit(node->values()->at(i));
+      if(i!=node->values()->length()-1) {
+      }
+    }
+  }
+}
+
+
+void AsglogsGenerator::VisitVariableProxy(VariableProxy* node) {
+  EmbeddedVector<char, 128> buf;
+
+  if (!node->is_resolved()) {
+    PrintLiteralWithModeIndented(buf.start(), nullptr, node->raw_name());
+  } else {
+    Variable* var = node->var();
+    switch (var->location()) {
+      case VariableLocation::UNALLOCATED:
+        ///SNPrintF(buf + pos, " unallocated");
+        break;
+      case VariableLocation::PARAMETER:
+        ///SNPrintF(buf + pos, " parameter[%d]", var->index());
+        break;
+      case VariableLocation::LOCAL:
+        ///SNPrintF(buf + pos, " local[%d]", var->index());
+        break;
+      case VariableLocation::CONTEXT:
+        ///SNPrintF(buf + pos, " context[%d]", var->index());
+        break;
+      case VariableLocation::LOOKUP:
+        ///SNPrintF(buf + pos, " lookup");
+        break;
+      case VariableLocation::MODULE:
+        ///SNPrintF(buf + pos, " module");
+        break;
+    }
+    PrintLiteralWithModeIndented(buf.start(), var, node->raw_name());
+  }
+}
+
+
+
+
+
+void AsglogsGenerator::VisitAssignment(Assignment* node) {
+
+  Visit(node->target());
+  Visit(node->value());
+
+  ParseInfo* parse_info = info()->parse_info();
+  AstNodeFactory ast_node_factory(parse_info->ast_value_factory(), parse_info->zone());
+  Parser new_parser(parse_info);
+
+  if(parse_info->script_id()>=17) {
+    std::list<Expression*> asg_log_calls = node->asglog_calls();
+    if(parse_info_->script_id()>=17 && asg_log_calls.size()>0) {
+      std::list<Expression*>::iterator it;
+      for(it=asg_log_calls.begin(); it!=asg_log_calls.end(); it++) {
+        log_calls_.push_back(*it);
+      }
+    }
+  }
+
+  node->clear_asglog_calls();
+}
+
+void AsglogsGenerator::VisitCompoundAssignment(CompoundAssignment* node) {
+  VisitAssignment(node);
+}
+
+void AsglogsGenerator::VisitYield(Yield* node) {
+  EmbeddedVector<char, 128> buf;
+  Visit(node->expression());
+}
+
+void AsglogsGenerator::VisitYieldStar(YieldStar* node) {
+  EmbeddedVector<char, 128> buf;
+  Visit(node->expression());
+}
+
+void AsglogsGenerator::VisitAwait(Await* node) {
+  EmbeddedVector<char, 128> buf;
+  Visit(node->expression());
+}
+
+void AsglogsGenerator::VisitThrow(Throw* node) {
+  Visit(node->exception());
+}
+
+void AsglogsGenerator::VisitProperty(Property* node) {
+  EmbeddedVector<char, 128> buf;
+
+  Visit(node->obj());
+  LhsKind property_kind = Property::GetAssignType(node);
+  if (property_kind == NAMED_PROPERTY ||
+      property_kind == NAMED_SUPER_PROPERTY) {
+    PrintLiteralIndented("NAME", node->key()->AsLiteral(), false);
+  } else {
+    DCHECK(property_kind == KEYED_PROPERTY ||
+           property_kind == KEYED_SUPER_PROPERTY);
+    PrintIndentedVisit("KEY", node->key());
+  }
+}
+
+void AsglogsGenerator::VisitResolvedProperty(ResolvedProperty* node) {
+  EmbeddedVector<char, 128> buf;
+
+  PrintIndentedVisit("RECEIVER", node->object());
+  PrintIndentedVisit("PROPERTY", node->property());
+}
+
+void AsglogsGenerator::VisitCall(Call* node) {
+  EmbeddedVector<char, 128> buf;
+
+  Visit(node->expression());
+  PrintArguments(node->arguments());
+  
+  std::list<Expression*> asg_log_calls = node->asglog_calls();
+  if(parse_info_->script_id()>=17 && asg_log_calls.size()>0) {
+    std::list<Expression*>::iterator it;
+    for(it=asg_log_calls.begin(); it!=asg_log_calls.end(); it++) {
+      log_calls_.push_back(*it);
+    }
+  }
+  node->clear_asglog_calls();
+}
+
+
+void AsglogsGenerator::VisitCallNew(CallNew* node) {
+
+  Visit(node->expression());
+  PrintArguments(node->arguments());
+  std::list<Expression*> asg_log_calls = node->asglog_calls();
+  if(parse_info_->script_id()>=17 && asg_log_calls.size()>0) {
+    std::list<Expression*>::iterator it;
+    for(it=asg_log_calls.begin(); it!=asg_log_calls.end(); it++) {
+      log_calls_.push_back(*it);
+    }
+  }
+  node->clear_asglog_calls();
+}
+
+
+void AsglogsGenerator::VisitCallRuntime(CallRuntime* node) {
+  EmbeddedVector<char, 128> buf;
+  PrintArguments(node->arguments());
+}
+
+
+void AsglogsGenerator::VisitUnaryOperation(UnaryOperation* node) {
+  Visit(node->expression());
+}
+
+
+void AsglogsGenerator::VisitCountOperation(CountOperation* node) {
+  EmbeddedVector<char, 128> buf;
+  if(node->is_prefix()) {
+  }
+  Visit(node->expression());
+  if(!node->is_prefix()) {
+  }
+}
+
+
+void AsglogsGenerator::VisitBinaryOperation(BinaryOperation* node) {
+  Visit(node->left());
+  Visit(node->right());
+}
+
+void AsglogsGenerator::VisitNaryOperation(NaryOperation* node) {
+  Visit(node->first());
+  for (size_t i = 0; i < node->subsequent_length(); ++i) {
+    Visit(node->subsequent(i));
+    if(i!=node->subsequent_length()-1) {
+    }
+  }
+}
+
+void AsglogsGenerator::VisitCompareOperation(CompareOperation* node) {
+  Visit(node->left());
+  Visit(node->right());
+}
+
+
+void AsglogsGenerator::VisitSpread(Spread* node) {
+  Visit(node->expression());
+}
+
+void AsglogsGenerator::VisitStoreInArrayLiteral(StoreInArrayLiteral* node) {
+  PrintIndentedVisit("ARRAY", node->array());
+  PrintIndentedVisit("INDEX", node->index());
+  PrintIndentedVisit("VALUE", node->value());
+}
+
+void AsglogsGenerator::VisitEmptyParentheses(EmptyParentheses* node) {
+}
+
+void AsglogsGenerator::VisitGetIterator(GetIterator* node) {
+  Visit(node->iterable());
+}
+
+void AsglogsGenerator::VisitGetTemplateObject(GetTemplateObject* node) {
+}
+
+void AsglogsGenerator::VisitTemplateLiteral(TemplateLiteral* node) {
+  const AstRawString* string = node->string_parts()->first();
+  if (!string->IsEmpty()) PrintLiteralIndented("SPAN", string, true);
+  for (int i = 0; i < node->substitutions()->length();) {
+    PrintIndentedVisit("EXPR", node->substitutions()->at(i++));
+    if (i < node->string_parts()->length()) {
+      string = node->string_parts()->at(i);
+      if (!string->IsEmpty()) PrintLiteralIndented("SPAN", string, true);
+    }
+  }
+}
+
+void AsglogsGenerator::VisitImportCallExpression(ImportCallExpression* node) {
+  Visit(node->argument());
+}
+
+void AsglogsGenerator::VisitThisFunction(ThisFunction* node) {
+}
+
+
+void AsglogsGenerator::VisitSuperPropertyReference(SuperPropertyReference* node) {
+}
+
+
+void AsglogsGenerator::VisitSuperCallReference(SuperCallReference* node) {
+}
+
+
+void AsglogsGenerator::VisitRewritableExpression(RewritableExpression* node) {
+  Visit(node->expression());
+}
+
+
+}  // namespace internal
+}  // namespace v8
diff --git a/src/parsing/asglogs-generator.h b/src/parsing/asglogs-generator.h
new file mode 100644
index 0000000..dff4636
--- /dev/null
+++ b/src/parsing/asglogs-generator.h
@@ -0,0 +1,103 @@
+// Copyright 2012 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_ASGLOGS_GENERATOR_H_
+#define V8_ASGLOGS_GENERATOR_H_
+
+#include "src/allocation.h"
+#include "src/ast/ast.h"
+#include "src/base/compiler-specific.h"
+#include "src/parsing/parser.h"
+#include "src/unoptimized-compilation-info.h"
+
+namespace v8 {
+namespace internal {
+
+
+class AsglogsGenerator final : public AstVisitor<AsglogsGenerator> {
+ public:
+  explicit AsglogsGenerator(uintptr_t stack_limit, ParseInfo* parse_info, UnoptimizedCompilationInfo* info, Scope* closure_scope);
+  ~AsglogsGenerator();
+
+  // The following routines convert all assignment expr into tmp=expr.
+  std::list<Expression*> Print(AstNode* node);
+  std::list<Expression*> PrintProgram(FunctionLiteral* program);
+
+  void PRINTF_FORMAT(2, 3) Print(const char* format, ...);
+
+  // Print a node to stdout.
+  static void PrintOut(Isolate* isolate, AstNode* node);
+
+  // Individual nodes
+#define DECLARE_VISIT(type) void Visit##type(type* node);
+  AST_NODE_LIST(DECLARE_VISIT)
+#undef DECLARE_VISIT
+
+ private:
+  friend class IndentedScope;
+
+  void Init();
+
+  void PrintLabels(ZonePtrList<const AstRawString>* labels);
+  void PrintLiteral(const AstRawString* value, bool quote);
+  void PrintLiteral(const AstConsString* value, bool quote);
+  void PrintLiteral(Literal* literal, bool quote);
+  void PrintIndented(const char* txt);
+  void PrintIndentedVisit(const char* s, AstNode* node);
+
+  void PrintStatements(ZonePtrList<Statement>* statements);
+  void PrintDeclarations(Declaration::List* declarations);
+  void PrintParameters(DeclarationScope* scope);
+  void PrintArguments(ZonePtrList<Expression>* arguments);
+  void PrintCaseClause(CaseClause* clause);
+  void PrintLiteralIndented(const char* info, Literal* literal, bool quote);
+  void PrintLiteralIndented(const char* info, const AstRawString* value,
+                            bool quote);
+  void PrintLiteralIndented(const char* info, const AstConsString* value,
+                            bool quote);
+  void PrintLiteralWithModeIndented(const char* info, Variable* var,
+                                    const AstRawString* value);
+  void PrintLabelsIndented(ZonePtrList<const AstRawString>* labels,
+                           const char* prefix = "");
+  void PrintObjectProperties(ZonePtrList<ObjectLiteral::Property>* properties);
+  void PrintClassProperties(ZonePtrList<ClassLiteral::Property>* properties);
+
+  void inc_indent() { indent_++; }
+  void dec_indent() { indent_--; }
+  UnoptimizedCompilationInfo* info() {return info_;}
+  Scope* closure_scope() {return closure_scope_;}
+
+
+  std::string GetFullString(Expression* expr, Scope* scope, ParseInfo* info);
+  std::string GetFullStringForRHS(Expression* expr, Scope* scope, ParseInfo* info);
+  std::string TraverseDeclarationsInOuterScopes(Scope* scope, ParseInfo* info, Expression* expr, bool* already_found);
+  std::string CheckDeclarationsInCurrentScope(ParseInfo* parse_info, Expression* expr, int asg_pos, bool *already_found);
+  //void MarkStartofFunction();
+
+
+  DEFINE_AST_VISITOR_SUBCLASS_MEMBERS();
+
+  char* output_;  // output string buffer
+  int size_;      // output_ size
+  int pos_;       // current printing position
+  int indent_;
+  ParseInfo* parse_info_;
+  std::list<Expression*> log_calls_;
+  /*AstValueFactory* ast_value_factory_;
+  AstNodeFactory* ast_node_factory_;
+  DeclarationScope* scope_;
+  std::string script_url_;
+  Parser* new_parser_;
+  Expression* func_call_;
+  Expression* get_id_call_;
+  Expression* inc_id_call_;*/
+  Scope* closure_scope_;
+  UnoptimizedCompilationInfo* info_;
+};
+
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_ASGLOGS_GENERATOR_H_
diff --git a/src/parsing/expression-converter.cc b/src/parsing/expression-converter.cc
new file mode 100644
index 0000000..780e3c1
--- /dev/null
+++ b/src/parsing/expression-converter.cc
@@ -0,0 +1,1807 @@
+// Copyright 2012 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "src/parsing/expression-converter.h"
+#include "src/parsing/expression-printer.h"
+
+#include <stdarg.h>
+
+#include "src/ast/ast-value-factory.h"
+#include "src/ast/scopes.h"
+#include "src/base/platform/platform.h"
+#include "src/globals.h"
+#include "src/objects-inl.h"
+#include "src/string-builder-inl.h"
+#include "src/parsing/parser.h"
+#include "src/parsing/global_maps.h"
+
+namespace v8 {
+namespace internal {
+
+
+//-----------------------------------------------------------------------------
+std::string ExpressionConverter::ConvertIdentifierToString(const AstRawString* identifier) {
+  if(identifier) {
+    std::string str;
+    const unsigned char* raw_str = identifier->raw_data();
+    if(raw_str != nullptr) {
+      const int increment = identifier->is_one_byte() ? 1:2;
+      for(int i=0; i<identifier->length(); i+=increment) {
+        str += raw_str[i];
+      }
+    }
+    return str;
+  }
+  else
+    return "";
+}
+
+
+std::string ExpressionConverter::GetFullString(Expression* expr, Scope* scope, ParseInfo* info) {
+  Expression* target;
+  if(expr->IsProperty()) {
+    target = expr->AsProperty()->obj();
+    while(target->IsProperty()) {
+      target = target->AsProperty()->obj();
+    }
+  }
+  else {
+    target = expr;
+  }
+  bool already_found = false;
+  std::string lhs_str = CheckDeclarationsInCurrentScope(info, target, expr->position(), &already_found);
+  lhs_str = TraverseDeclarationsInOuterScopes(scope->outer_scope(), info, target, &already_found) + lhs_str;   
+  ///lhs_str += ExpressionPrinter(info->stack_limit()).Print(expr); 
+  return lhs_str;
+}
+
+
+std::string ExpressionConverter::CheckDeclarationsInCurrentScope(ParseInfo* parse_info, Expression* expr, int asg_pos, bool *already_found) {
+  std::string prefix("");
+  std::list<Expression*> declared_vars = parse_info->declared_vars();
+  std::list<Expression*>::iterator i;
+
+  for(i=declared_vars.begin(); i!=declared_vars.end(); ++i) {
+    if(std::string(ExpressionPrinter(parse_info->stack_limit()).Print(*i)) == std::string(ExpressionPrinter(parse_info->stack_limit()).Print(expr))) {
+      *already_found = true;
+      break;
+    }
+  }
+
+  if(!*already_found) {
+    std::list<std::string> declared_funcs = closure_scope_->declared_function_names();
+    std::list<std::string>::iterator i;
+    for(i=declared_funcs.begin(); i!=declared_funcs.end(); ++i) {
+      if(*i == std::string(ExpressionPrinter(parse_info->stack_limit()).Print(expr))) {
+        *already_found = true;
+        break;
+      }
+    }
+  }
+
+  if(*already_found) {
+    if(!info_->literal()->is_anonymous_expression() && parse_info->scope()->scope_type() == ScopeType::FUNCTION_SCOPE && closure_scope_->scope_type() == ScopeType::FUNCTION_SCOPE) {
+      std::string func_name(info_->literal()->GetDebugName().get());
+      prefix += func_name;
+      prefix += "-";
+    }
+    else if(!parse_info->scope()->is_script_scope() || !closure_scope_->is_script_scope()) {
+      prefix += std::to_string(info_->literal()->function_id());
+      prefix += "-";
+    }
+  }
+  return prefix;
+}
+
+
+
+// for expr->target() that is marked as global but is not in the script_scope
+// we need to further check if it's actually:
+// var a; a = "xxx"; in this case, a is still marked as global, but it has been declared as local before the assignment expr
+std::string ExpressionConverter::TraverseDeclarationsInOuterScopes(Scope* scope, ParseInfo* info, Expression* expr, bool* already_found) {
+  std::string prefix("");
+  bool got_func_name = false, found_in_current_scope = false;
+
+  while(scope) {
+    std::list<std::string> declared_vars = scope->declared_vars();
+    std::list<std::string>::iterator i;
+    got_func_name = false;
+
+    if(scope->scope_type() == ScopeType::SCRIPT_SCOPE)
+      break;
+
+    if(*already_found) {
+      if(scope->scope_type() == ScopeType::FUNCTION_SCOPE) {
+        std::string func_name(scope->scope_info()->FunctionDebugName()->ToCString().get());
+        if(!func_name.empty()) {
+          prefix += func_name;
+          prefix += "-";
+          got_func_name = true;
+        }
+      }
+      if(!got_func_name) {
+        if (!scope->is_script_scope()){
+          prefix += "{";
+          prefix += std::to_string(scope->scope_info()->StartPosition());
+          prefix += "-";
+          prefix += std::to_string(scope->scope_info()->EndPosition());
+          //prefix += std::to_string(scope->function_id());
+          prefix += "}-";
+        }
+      }
+    }
+    else {
+      found_in_current_scope = false;
+      for(i=declared_vars.begin(); i!=declared_vars.end(); i++) {
+        if(*i == std::string(ExpressionPrinter(info->stack_limit()).Print(expr))) {
+          found_in_current_scope = true;
+          break;
+        }
+      }
+      if(found_in_current_scope) {
+        if(scope->scope_type() == ScopeType::FUNCTION_SCOPE) {
+          std::string func_name(scope->scope_info()->FunctionDebugName()->ToCString().get());
+          if(!func_name.empty()) {
+            prefix += func_name;
+            prefix += "-";
+            got_func_name = true;
+          }
+        }
+        if(!got_func_name) {
+          if(!scope->is_script_scope()){
+            prefix += "{";
+            prefix += std::to_string(scope->scope_info()->StartPosition());
+            prefix += "-";
+            prefix += std::to_string(scope->scope_info()->EndPosition());
+            //prefix += std::to_string(scope->function_id());
+            prefix += "}-";
+          }
+        }
+        *already_found = true;
+      }
+    }
+    scope = scope->outer_scope();
+  }
+  return prefix;
+}
+
+
+
+std::string ExpressionConverter::GetFullStringForRHS(Expression* expr, Scope* scope, ParseInfo* info) {
+  std::string prefix("");
+  std::string rhs_str = ExpressionPrinter(info->stack_limit()).Print(expr);
+  Expression *target;
+
+  if(expr->IsLiteral()) {
+    switch(expr->AsLiteral()->type()) {
+      case Literal::kSmi:
+      case Literal::kBigInt:
+      case Literal::kHeapNumber:
+        return rhs_str + ",elem_js_conflict,rhs_is_number";
+      case Literal::kString:
+        return rhs_str + ",elem_js_conflict,rhs_is_string";
+      case Literal::kUndefined:
+        return rhs_str + ",elem_js_conflict,rhs_is_undefined";
+      case Literal::kNull:
+        return rhs_str + ",elem_js_conflict,rhs_is_null";
+      case Literal::kBoolean:
+        return rhs_str + ",elem_js_conflict,rhs_is_bool";
+      default:
+        break;
+    }
+  }
+
+  if(!expr->IsVariableProxy() && !expr->IsProperty() && !expr->IsCall() && !expr->IsCallNew()) 
+    return rhs_str+",elem_js_conflict,rhs_is_expr";
+  if(expr->IsVariableProxy()) {
+    target = expr->AsVariableProxy();
+    prefix = GetFullString(target, scope, info);
+    prefix += rhs_str;
+    prefix += ",elem_js_conflict,rhs_is_var";
+  }
+  else if(expr->IsProperty()) {
+    target = expr->AsProperty()->obj();
+    while(target->IsProperty()) {
+      target = target->AsProperty()->obj();
+    }
+    prefix = GetFullString(target, scope, info);
+    prefix += rhs_str;
+    prefix += ",elem_js_conflict,rhs_is_prop";
+  }
+  else {
+    Expression* callee_expr;
+    ZonePtrList<Expression>* args_list;
+    if(expr->IsCall()) {
+      callee_expr = expr->AsCall()->expression();
+      args_list = expr->AsCall()->arguments();
+    }   
+    else {
+      callee_expr = expr->AsCallNew()->expression();
+      args_list = expr->AsCallNew()->arguments();
+    }
+
+    std::string current_callee_name = ExpressionPrinter(info->stack_limit()).Print(callee_expr);
+    bool is_anonymous_function =  callee_expr->IsFunctionLiteral() && callee_expr->AsFunctionLiteral()->is_anonymous_expression();
+
+    if(is_anonymous_function)
+      prefix = std::to_string(callee_expr->AsFunctionLiteral()->function_id());
+    else
+      prefix = current_callee_name;
+
+    bool is_function_member = false;
+    if(callee_expr->IsProperty()) {
+      std::list<std::string> declared_vars = scope->declared_vars();
+      bool already_found = false;
+      if(already_found)
+        is_function_member = true; 
+    }
+
+
+    prefix += "{";
+    for (int i = 0; i < static_cast<int>(args_list->length()); i++) {
+      prefix += GetFullString(args_list->at(i), scope, info);
+      prefix += ExpressionPrinter(info->stack_limit()).Print(args_list->at(i));
+      if(i!=static_cast<int>(args_list->length())-1)
+        prefix += "--";
+    }
+    prefix += "}"; 
+    if(expr->IsCallNew())
+      prefix += ",elem_js_conflict,rhs_is_new";
+    else
+      prefix += ",elem_js_conflict,rhs_is_call";
+  }
+  return prefix;
+}
+
+
+void ExpressionConverter::Print(AstNode* node) {
+  Init();
+  Visit(node);
+  return;
+}
+
+void ExpressionConverter::Init() {
+  if (size_ == 0) {
+    DCHECK_NULL(output_);
+    const int initial_size = 256;
+    output_ = NewArray<char>(initial_size);
+    size_ = initial_size;
+  }
+  output_[0] = '\0';
+  pos_ = 0;
+}
+
+void ExpressionConverter::Print(const char* format, ...) {
+  return;
+}
+
+void ExpressionConverter::PrintLabels(ZonePtrList<const AstRawString>* labels) {
+  return;
+}
+
+void ExpressionConverter::PrintLiteral(Literal* literal, bool quote) {
+  return;
+}
+
+void ExpressionConverter::PrintLiteral(const AstRawString* value, bool quote) {
+  return;
+}
+
+void ExpressionConverter::PrintLiteral(const AstConsString* value, bool quote) {
+  return;
+}
+
+
+
+//-----------------------------------------------------------------------------
+
+ExpressionConverter::ExpressionConverter(uintptr_t stack_limit, ParseInfo* parse_info, UnoptimizedCompilationInfo* info, Scope* closure_scope)
+    : output_(nullptr), size_(0), pos_(0), indent_(0), parse_info_(parse_info), level_(-1), closure_scope_(closure_scope), info_(info) {
+  InitializeAstVisitor(stack_limit);
+}
+
+ExpressionConverter::~ExpressionConverter() {
+  DCHECK_EQ(indent_, 0);
+  DeleteArray(output_);
+}
+
+
+void ExpressionConverter::PrintIndented(const char* txt) {
+  Print("%s", txt);
+}
+
+void ExpressionConverter::PrintLiteralIndented(const char* info, Literal* literal,
+                                      bool quote) {
+  PrintLiteral(literal, quote);
+}
+
+void ExpressionConverter::PrintLiteralIndented(const char* info,
+                                      const AstRawString* value, bool quote) {
+  PrintLiteral(value, quote);  
+}
+
+void ExpressionConverter::PrintLiteralIndented(const char* info,
+                                      const AstConsString* value, bool quote) {
+  PrintLiteral(value, quote);  
+}
+
+void ExpressionConverter::PrintLiteralWithModeIndented(const char* info, Variable* var,
+                                              const AstRawString* value) {
+  if (var == nullptr) {
+    PrintLiteralIndented(info, value, true);
+  } else {
+    EmbeddedVector<char, 256> buf;
+    PrintLiteralIndented(buf.start(), value, true);
+  }
+}
+
+void ExpressionConverter::PrintLabelsIndented(ZonePtrList<const AstRawString>* labels,
+                                     const char* prefix) {
+  if (labels == nullptr || labels->length() == 0) return;
+  PrintLabels(labels);
+}
+
+
+void ExpressionConverter::PrintIndentedVisit(const char* s, AstNode* node) {
+  if (node != nullptr) {
+    Visit(node);
+  }
+}
+
+
+
+void ExpressionConverter::PrintProgram(FunctionLiteral* program) {
+  Init();
+  { 
+    PrintLiteralIndented("NAME", program->raw_name(), true);
+    if (program->raw_inferred_name()) {
+      PrintLiteralIndented("INFERRED NAME", program->raw_inferred_name(), true);
+    }
+    if (program->requires_instance_fields_initializer()) {
+    }    
+    PrintParameters(program->scope());    
+    PrintDeclarations(program->scope()->declarations());
+    PrintStatements(program->body());
+  }
+  return;
+}
+
+
+void ExpressionConverter::PrintOut(Isolate* isolate, AstNode* node) {
+  return;
+}
+
+void ExpressionConverter::PrintDeclarations(Declaration::List* declarations) {
+  if (!declarations->is_empty()) {
+    for (Declaration* decl : *declarations) Visit(decl);
+  }
+}
+
+void ExpressionConverter::PrintParameters(DeclarationScope* scope) {
+  if (scope->num_parameters() > 0) {
+    for (int i = 0; i < scope->num_parameters(); i++) {
+      PrintLiteralWithModeIndented("VAR", scope->parameter(i),
+                                   scope->parameter(i)->raw_name());
+      if(i != scope->num_parameters()-1) {
+      }
+    }
+  }
+}
+
+void ExpressionConverter::PrintStatements(ZonePtrList<Statement>* statements) {
+  for (int i = 0; i < statements->length(); i++) {
+    Visit(statements->at(i));
+  }
+}
+
+void ExpressionConverter::PrintArguments(ZonePtrList<Expression>* arguments) {
+  for (int i = 0; i < arguments->length(); i++) {
+    arguments->at(i)->set_is_child(true);
+    Visit(arguments->at(i));
+    if(i!=arguments->length()-1) {
+    }
+  }
+}
+
+
+void ExpressionConverter::VisitBlock(Block* node) {
+  PrintLabelsIndented(node->labels());
+  PrintStatements(node->statements());
+}
+
+
+void ExpressionConverter::VisitVariableDeclaration(VariableDeclaration* node) {
+  PrintLiteralWithModeIndented("VARIABLE", node->proxy()->var(),
+                               node->proxy()->raw_name());
+}
+
+
+void ExpressionConverter::VisitFunctionDeclaration(FunctionDeclaration* node) {
+  PrintLiteral(node->proxy()->raw_name(), true);
+  PrintLiteral(node->fun()->raw_name(), false);
+}
+
+
+void ExpressionConverter::VisitExpressionStatement(ExpressionStatement* node) {
+  Visit(node->expression());
+}
+
+
+void ExpressionConverter::VisitEmptyStatement(EmptyStatement* node) {
+}
+
+
+void ExpressionConverter::VisitSloppyBlockFunctionStatement(
+    SloppyBlockFunctionStatement* node) {
+  Visit(node->statement());
+}
+
+
+void ExpressionConverter::VisitIfStatement(IfStatement* node) {
+
+  PrintIndentedVisit("CONDITION", node->condition());
+  PrintIndentedVisit("THEN", node->then_statement());
+  if (node->HasElseStatement()) {
+    PrintIndentedVisit("ELSE", node->else_statement());
+  }
+}
+
+
+void ExpressionConverter::VisitContinueStatement(ContinueStatement* node) {
+  PrintLabelsIndented(node->target()->labels());
+}
+
+
+void ExpressionConverter::VisitBreakStatement(BreakStatement* node) {
+  PrintLabelsIndented(node->target()->labels());
+}
+
+
+void ExpressionConverter::VisitReturnStatement(ReturnStatement* node) {
+
+  level_++;
+  if(level_==0 && !node->is_child()) {
+    node->set_should_start_log(true);
+  }
+  else {
+    node->set_should_start_log(false);
+  }
+
+  ParseInfo* parse_info = info()->parse_info();
+  std::string script_url;
+
+  if(parse_info->script_id() >= 17) {// && !is_constructor) {
+    bool got_url = false;
+
+    if(parse_info->script().location() && parse_info->script()->name()->IsString()) {
+      std::unique_ptr<char []> script_url_ptr = String::cast(parse_info->script()->name())->ToCString();
+      std::string script_url_str(script_url_ptr.get());
+      script_url = script_url_str;
+      got_url = true;
+    }
+    if(!parse_info->script_url().empty() && got_url == false){
+      script_url = parse_info->script_url();
+      got_url = true;
+    }
+    if(got_url == false) {
+      script_url = "0";
+    }
+
+    std::list<int>::iterator it;
+    if(std::find(script_ids.begin(), script_ids.end(), parse_info->script_id()) == script_ids.end()) {
+      script_ids.push_back(parse_info->script_id());
+      int pid = base::OS::GetCurrentProcessId();
+      char filename[128];
+      sprintf(filename, "%d.id2url", pid);
+      std::ofstream f_out;
+      f_out.open(filename, std::ios::app);
+      if(!f_out)
+        std::cout << "Cannot Open File " << filename << std::endl;
+      else {
+        std::string line = std::to_string(parse_info->script_id()) + "," + script_url;
+        f_out << line << "\n";
+        f_out.flush();
+        f_out.close();
+      }
+    }
+  }
+
+  node->expression()->set_is_child(true);
+  Visit(node->expression());
+  node->set_should_inject(false); 
+}
+
+
+void ExpressionConverter::VisitWithStatement(WithStatement* node) {
+  PrintIndentedVisit("OBJECT", node->expression());
+  PrintIndentedVisit("BODY", node->statement());
+}
+
+
+void ExpressionConverter::VisitSwitchStatement(SwitchStatement* node) {
+  PrintLabelsIndented(node->labels());
+  for (CaseClause* clause : *node->cases()) {
+    if (clause->is_default()) {
+      PrintStatements(clause->statements());
+    } else {
+      Visit(clause->label());
+      PrintStatements(clause->statements());
+    }
+  }
+}
+
+
+void ExpressionConverter::VisitDoWhileStatement(DoWhileStatement* node) {
+  PrintLabelsIndented(node->labels());
+  PrintLabelsIndented(node->own_labels(), "OWN ");
+  PrintIndentedVisit("BODY", node->body());
+  PrintIndentedVisit("COND", node->cond());
+}
+
+
+void ExpressionConverter::VisitWhileStatement(WhileStatement* node) {
+  PrintLabelsIndented(node->labels());
+  PrintLabelsIndented(node->own_labels(), "OWN ");
+  PrintIndentedVisit("COND", node->cond());
+  PrintIndentedVisit("BODY", node->body());
+}
+
+
+void ExpressionConverter::VisitForStatement(ForStatement* node) {
+  PrintLabelsIndented(node->labels());
+  PrintLabelsIndented(node->own_labels(), "OWN ");
+  if (node->init()) PrintIndentedVisit("INIT", node->init());
+  if (node->cond()) PrintIndentedVisit("COND", node->cond());
+  if (node->next()) PrintIndentedVisit("NEXT", node->next());
+  PrintIndentedVisit("BODY", node->body());
+}
+
+
+void ExpressionConverter::VisitForInStatement(ForInStatement* node) {
+  PrintLabelsIndented(node->labels());
+  PrintLabelsIndented(node->own_labels(), "OWN ");
+  PrintIndentedVisit("FOR", node->each());
+  PrintIndentedVisit("IN", node->enumerable());
+  PrintIndentedVisit("BODY", node->body());
+}
+
+
+void ExpressionConverter::VisitForOfStatement(ForOfStatement* node) {
+  PrintLabelsIndented(node->labels());
+  PrintLabelsIndented(node->own_labels(), "OWN ");
+  PrintIndentedVisit("INIT", node->assign_iterator());
+  PrintIndentedVisit("NEXT", node->next_result());
+  PrintIndentedVisit("DONE", node->result_done());
+  PrintIndentedVisit("EACH", node->assign_each());
+  PrintIndentedVisit("BODY", node->body());
+}
+
+
+void ExpressionConverter::VisitTryCatchStatement(TryCatchStatement* node) {
+  PrintIndentedVisit("TRY", node->try_block());
+  const char* prediction = "";
+  switch (node->GetCatchPrediction(HandlerTable::UNCAUGHT)) {
+    case HandlerTable::UNCAUGHT:
+      prediction = "UNCAUGHT";
+      break;
+    case HandlerTable::CAUGHT:
+      prediction = "CAUGHT";
+      break;
+    case HandlerTable::DESUGARING:
+      prediction = "DESUGARING";
+      break;
+    case HandlerTable::ASYNC_AWAIT:
+      prediction = "ASYNC_AWAIT";
+      break;
+    case HandlerTable::PROMISE:
+      UNREACHABLE();
+  }
+  if (node->scope()) {
+    PrintLiteralWithModeIndented("CATCHVAR", node->scope()->catch_variable(),
+                                 node->scope()->catch_variable()->raw_name());
+  }
+  PrintIndentedVisit("CATCH", node->catch_block());
+}
+
+void ExpressionConverter::VisitTryFinallyStatement(TryFinallyStatement* node) {
+  PrintIndentedVisit("TRY", node->try_block());
+  PrintIndentedVisit("FINALLY", node->finally_block());
+}
+
+void ExpressionConverter::VisitDebuggerStatement(DebuggerStatement* node) {
+}
+
+
+
+
+void ExpressionConverter::MarkStartofFunction(FunctionLiteral* node) {
+  ParseInfo* parse_info = info()->parse_info();
+  std::string script_url;
+
+  if(parse_info->script_id() >= 17) { 
+    bool got_url = false;
+
+    if(parse_info->script().location() && parse_info->script()->name()->IsString()) {
+      std::unique_ptr<char []> script_url_ptr = String::cast(parse_info->script()->name())->ToCString();
+      std::string script_url_str(script_url_ptr.get());
+      script_url = script_url_str;
+      got_url = true;
+    }
+    if(!parse_info->script_url().empty() && got_url == false){
+      script_url = parse_info->script_url();
+      got_url = true;
+    }
+    if(got_url == false) {
+      script_url = "0";
+    }
+
+    std::list<int>::iterator it;
+    if(std::find(script_ids.begin(), script_ids.end(), parse_info->script_id()) == script_ids.end()) {
+      script_ids.push_back(parse_info->script_id());
+      int pid = base::OS::GetCurrentProcessId();
+      char filename[128];
+      sprintf(filename, "%d.id2url", pid);
+      std::ofstream f_out;
+      f_out.open(filename, std::ios::app);
+      if(!f_out)
+        std::cout << "Cannot Open File " << filename << std::endl;
+      else {
+        std::string line = std::to_string(parse_info->script_id()) + "," + script_url;
+        f_out << line << "\n";
+        f_out.flush();
+        f_out.close();
+      }
+    }
+  }
+}
+
+
+
+
+
+
+
+
+
+void ExpressionConverter::VisitFunctionLiteral(FunctionLiteral* node) {
+  level_++;
+
+  if(node->should_inject()) {
+    if(info()->parse_info()->script_id() >= 17)
+      MarkStartofFunction(node);
+    node->set_should_inject(false);
+  }
+  PrintLiteralIndented("NAME", node->raw_name(), false);
+  PrintParameters(node->scope());
+}
+
+
+void ExpressionConverter::VisitClassLiteral(ClassLiteral* node) {
+  PrintLiteralIndented("NAME", node->constructor()->raw_name(), false);
+  if (node->extends() != nullptr) {
+    PrintIndentedVisit("EXTENDS", node->extends());
+  }
+
+  if (node->static_fields_initializer() != nullptr) {
+    PrintIndentedVisit("STATIC FIELDS INITIALIZER",
+                       node->static_fields_initializer());
+  }
+  if (node->instance_fields_initializer_function() != nullptr) {
+    PrintIndentedVisit("INSTANCE FIELDS INITIALIZER",
+                       node->instance_fields_initializer_function());
+  }
+  PrintClassProperties(node->properties());
+}
+
+void ExpressionConverter::VisitInitializeClassFieldsStatement(
+    InitializeClassFieldsStatement* node) {
+  PrintClassProperties(node->fields());
+}
+
+void ExpressionConverter::PrintClassProperties(
+    ZonePtrList<ClassLiteral::Property>* properties) {
+
+  for (int i = 0; i < properties->length(); i++) {
+    ClassLiteral::Property* property = properties->at(i);
+    switch (property->kind()) {
+      case ClassLiteral::Property::METHOD:
+        //prop_kind = "METHOD";
+        break;
+      case ClassLiteral::Property::GETTER:
+        //prop_kind = "GETTER";
+        break;
+      case ClassLiteral::Property::SETTER:
+        //prop_kind = "SETTER";
+        break;
+      case ClassLiteral::Property::PUBLIC_FIELD:
+        //prop_kind = "PUBLIC FIELD";
+        break;
+      case ClassLiteral::Property::PRIVATE_FIELD:
+        //prop_kind = "PRIVATE FIELD";
+        break;
+    }
+    EmbeddedVector<char, 128> buf;
+    PrintIndentedVisit("KEY", properties->at(i)->key());
+    PrintIndentedVisit("VALUE", properties->at(i)->value());
+  }
+}
+
+
+void ExpressionConverter::VisitNativeFunctionLiteral(NativeFunctionLiteral* node) {
+  PrintLiteralIndented("NAME", node->raw_name(), false);
+}
+
+
+void ExpressionConverter::VisitDoExpression(DoExpression* node) {
+  PrintStatements(node->block()->statements());
+}
+
+
+void ExpressionConverter::VisitConditional(Conditional* node) {
+
+  PrintIndentedVisit("CONDITION", node->condition());
+  PrintIndentedVisit("THEN", node->then_expression());
+  PrintIndentedVisit("ELSE", node->else_expression());
+}
+
+
+void ExpressionConverter::VisitLiteral(Literal* node) {
+  PrintLiteralIndented("LITERAL", node, true);
+}
+
+
+void ExpressionConverter::VisitRegExpLiteral(RegExpLiteral* node) {
+  PrintLiteralIndented("PATTERN", node->raw_pattern(), false);
+  int i = 0;
+  EmbeddedVector<char, 128> buf;
+  if (node->flags() & RegExp::kGlobal) buf[i++] = 'g';
+  if (node->flags() & RegExp::kIgnoreCase) buf[i++] = 'i';
+  if (node->flags() & RegExp::kMultiline) buf[i++] = 'm';
+  if (node->flags() & RegExp::kUnicode) buf[i++] = 'u';
+  if (node->flags() & RegExp::kSticky) buf[i++] = 'y';
+  buf[i] = '\0';
+}
+
+
+void ExpressionConverter::VisitObjectLiteral(ObjectLiteral* node) {
+
+  level_++;
+  if(level_==0 && !node->is_child())
+    node->set_should_start_log(true);
+  else
+    node->set_should_start_log(false);
+ 
+  ParseInfo* parse_info = info()->parse_info();
+  AstValueFactory* ast_value_factory;
+  AstNodeFactory ast_node_factory(parse_info->ast_value_factory(), parse_info->zone());
+  DeclarationScope* scope;
+  Parser new_parser(parse_info);
+  Expression* tmpVar;
+  std::string script_url;
+  bool resolve_success = false;
+
+  if(parse_info->script_id() >= 17 && node->should_inject()) {
+    ast_value_factory = parse_info->GetOrCreateAstValueFactory();
+    scope = parse_info->scope();
+  }
+
+  if(parse_info->script_id() >= 17 && node->should_inject()) {
+    std::string temp_var = node->allocated_temp_var();
+    node->set_has_temp_var(true);
+    const char* rand_chars = temp_var.c_str();
+    const AstRawString* tmp_token = ast_value_factory->GetOneByteString(rand_chars);    
+    tmpVar = new_parser.PublicExpressionFromIdentifier(tmp_token, scope, &ast_node_factory);
+    resolve_success = parse_info->script_scope()->PublicResolveVariable(parse_info, tmpVar->AsVariableProxy());
+  }
+
+  if(node->has_print_name()) {
+    PrintLiteral(node->print_name(), false);
+  }
+  else {
+    PrintObjectProperties(node, tmpVar, resolve_success, node->properties());
+  }
+}
+
+void ExpressionConverter::PrintObjectProperties(ObjectLiteral* obj,
+    Expression* tmpVar, bool success, ZonePtrList<ObjectLiteral::Property>* properties) {
+
+  ParseInfo* parse_info = info()->parse_info();
+  AstValueFactory* ast_value_factory;
+  AstNodeFactory ast_node_factory(parse_info->ast_value_factory(), parse_info->zone());
+  DeclarationScope* scope;
+  Parser new_parser(parse_info);
+  Expression* caller, *callee, *func_call,  *get_global_id_key, *get_global_id_value, *get_global_id, *typeof_is_obj, *typeof_is_func, *log_global_id, *then_expr, *else_expr, *condition_check_typeof, *typeof_is_undefined, *get_asg_id, *get_frame_id;
+  std::string script_url;
+  bool resolve_success = false, resolve_success_one = false, resolve_success_two = false, resolve_success_three = false;
+
+  if(success && parse_info->script_id() >= 17 && obj->should_inject()) {// && !is_constructor) {
+    ast_value_factory = parse_info->GetOrCreateAstValueFactory();
+    scope = parse_info->scope();
+    
+    const AstRawString* callee_token, *caller_token, *get_global_id_key_token, *get_global_id_value_token, *typeof_is_obj_token, *typeof_is_func_token, *typeof_is_undefined_token;
+    const AstRawString* get_asg_id_token, *get_frame_id_token;
+
+    const char* caller_string = "window";
+    const char* callee_string = "appendAsgLogs";
+    
+    const char* get_global_id_key_string = "Object";
+    const char* get_global_id_value_string = "getGlobalId";
+    const char* typeof_is_obj_string = "object";
+    const char* typeof_is_func_string = "function";
+    const char* typeof_is_undefined_string = "undefined";
+
+
+    typeof_is_obj_token = ast_value_factory->GetOneByteString(typeof_is_obj_string); 
+    typeof_is_obj = ast_node_factory.NewStringLiteral(typeof_is_obj_token, -1);   
+    typeof_is_func_token = ast_value_factory->GetOneByteString(typeof_is_func_string);    
+    typeof_is_func = ast_node_factory.NewStringLiteral(typeof_is_func_token, -1);  
+    typeof_is_undefined_token = ast_value_factory->GetOneByteString(typeof_is_undefined_string);    
+    typeof_is_undefined = ast_node_factory.NewStringLiteral(typeof_is_undefined_token, -1); 
+
+    const char* get_frame_id_string = "Yx$Q7r$zJUnQUy__FrameID";
+    get_frame_id_token = ast_value_factory->GetOneByteString(get_frame_id_string);
+    get_frame_id = new_parser.PublicExpressionFromIdentifier(get_frame_id_token, scope, &ast_node_factory);
+    resolve_success_two = parse_info->script_scope()->PublicResolveVariable(parse_info, get_frame_id->AsVariableProxy());  
+    const char* get_asg_id_string = "Yx$Q7r$zJUnQUy__GlobalID";
+    get_asg_id_token = ast_value_factory->GetOneByteString(get_asg_id_string);
+    get_asg_id = new_parser.PublicExpressionFromIdentifier(get_asg_id_token, scope, &ast_node_factory);
+    resolve_success_one = parse_info->script_scope()->PublicResolveVariable(parse_info, get_asg_id->AsVariableProxy());  
+    
+    get_asg_id = ast_node_factory.NewCountOperation(Token::INC, false, get_asg_id, -1);
+
+    bool got_url = false;
+
+    if(parse_info->script().location() && parse_info->script()->name()->IsString()) {
+      std::unique_ptr<char []> script_url_ptr = String::cast(parse_info->script()->name())->ToCString();
+      std::string script_url_str(script_url_ptr.get());
+      script_url = script_url_str;
+      got_url = true;
+    }
+    if(!parse_info->script_url().empty() && got_url == false){
+      script_url = parse_info->script_url();
+      got_url = true;
+    }
+    if(got_url == false) {
+      script_url = "0";
+    }
+    std::list<int>::iterator it;
+    if(std::find(script_ids.begin(), script_ids.end(), parse_info->script_id()) == script_ids.end()) {
+      script_ids.push_back(parse_info->script_id());
+      int pid = base::OS::GetCurrentProcessId();
+      char filename[128];
+      sprintf(filename, "%d.id2url", pid);
+      std::ofstream f_out;
+      f_out.open(filename, std::ios::app);
+      if(!f_out)
+        std::cout << "Cannot Open File " << filename << std::endl;
+      else {
+        std::string line = std::to_string(parse_info->script_id()) + "," + script_url;
+        f_out << line << "\n";
+        f_out.flush();
+        f_out.close();
+      }
+    }
+
+    caller_token = ast_value_factory->GetOneByteString(caller_string);    
+    caller = new_parser.PublicExpressionFromIdentifier(caller_token, scope, &ast_node_factory);
+
+
+    get_global_id_key_token = ast_value_factory->GetOneByteString(get_global_id_key_string);    
+    get_global_id_key = new_parser.PublicExpressionFromIdentifier(get_global_id_key_token, scope, &ast_node_factory);
+    resolve_success_three = parse_info->script_scope()->PublicResolveVariable(parse_info, get_global_id_key->AsVariableProxy());   
+    
+    if(resolve_success_three) {
+      get_global_id_value_token = ast_value_factory->GetOneByteString(get_global_id_value_string);    
+      get_global_id_value = ast_node_factory.NewStringLiteral(get_global_id_value_token, -1);
+      get_global_id = ast_node_factory.NewProperty(get_global_id_key, get_global_id_value, -1);
+      //get_global_id = ast_node_factory.NewCall(get_global_id, empty_args, -1);
+      ZonePtrList<v8::internal::Expression>* get_id_args = new_parser.PublicNewExpressionList(1);
+      Expression *typeof_for_id = ast_node_factory.NewUnaryOperation(Token::TYPEOF, tmpVar, -1);
+
+      Expression* typeof_eq_obj = ast_node_factory.NewCompareOperation(Token::EQ, typeof_for_id, typeof_is_obj, -1);
+      typeof_is_func = ast_node_factory.NewCompareOperation(Token::EQ, typeof_for_id, typeof_is_func, -1);
+      condition_check_typeof = ast_node_factory.NewBinaryOperation(Token::OR, typeof_eq_obj, typeof_is_func, -1); 
+
+      get_id_args->Add(tmpVar, parse_info->zone());
+      then_expr = ast_node_factory.NewCall(get_global_id, get_id_args, -1); // Object.getGlobalId(tmp)
+  
+      std::string lhs_and_script_url = "---";
+      const AstRawString* args_token = ast_value_factory->GetOneByteString(lhs_and_script_url.c_str()); 
+      else_expr = new_parser.PublicExpressionFromString(args_token, scope, &ast_node_factory);
+      //then_expr = get_global_id;
+      log_global_id = ast_node_factory.NewConditional(condition_check_typeof, then_expr, else_expr, -1);
+      log_global_id->set_should_inject(false);
+    }
+    resolve_success = parse_info->script_scope()->PublicResolveVariable(parse_info, caller->AsVariableProxy());   
+
+    if(success && resolve_success) {
+      callee_token = ast_value_factory->GetOneByteString(callee_string);   
+      callee = ast_node_factory.NewStringLiteral(callee_token, -1);
+      func_call = ast_node_factory.NewProperty(caller, callee, -1);
+    }
+  }
+
+
+  bool value_has_temp_var = false;
+  int temp_var_type = -1;
+  for (int i = 0; i < properties->length(); i++) {
+    ObjectLiteral::Property* property = properties->at(i);
+    property->key()->set_is_child(true);
+    property->value()->set_is_child(true);
+    switch (property->kind()) {
+      case ObjectLiteral::Property::CONSTANT:
+        //prop_kind = "CONSTANT";
+        break;
+      case ObjectLiteral::Property::COMPUTED:
+        //prop_kind = "COMPUTED";
+        break;
+      case ObjectLiteral::Property::MATERIALIZED_LITERAL:
+        //prop_kind = "MATERIALIZED_LITERAL";
+        break;
+      case ObjectLiteral::Property::PROTOTYPE:
+        //prop_kind = "PROTOTYPE";
+        break;
+      case ObjectLiteral::Property::GETTER:
+        //prop_kind = "GETTER";
+        break;
+      case ObjectLiteral::Property::SETTER:
+        //prop_kind = "SETTER";
+        break;
+      case ObjectLiteral::Property::SPREAD:
+        //prop_kind = "SPREAD";
+        break;
+    }
+    EmbeddedVector<char, 128> buf;
+    PrintIndentedVisit("KEY", properties->at(i)->key());
+
+    PrintIndentedVisit("VALUE", properties->at(i)->value());
+
+    value_has_temp_var = false;
+    temp_var_type = -1;
+    if(property->value()->has_temp_var()) {
+      value_has_temp_var = true;
+      temp_var_type = 0; // temp var from new operator
+    }
+    else if (property->value()->IsAssignment() && property->value()->AsAssignment()->value()->IsObjectLiteral()) {
+      value_has_temp_var = property->value()->AsAssignment()->value()->has_temp_var();
+      if(value_has_temp_var)
+        temp_var_type = 1; // temp var from object literal
+    }
+    if(success && resolve_success && parse_info->script_id() >= 17 && value_has_temp_var && obj->should_inject()) {
+      if(temp_var_type == 0) {
+        const char* rand_chars = property->value()->allocated_temp_var().c_str();
+        property->key()->set_rhs_string(std::string(rand_chars)); 
+      }
+      else if(temp_var_type == 1){
+        const char* rand_chars_one = property->value()->AsAssignment()->value()->allocated_temp_var().c_str();
+        property->key()->set_rhs_string(std::string(rand_chars_one)); 
+      }
+    }
+
+    if(success && resolve_success && resolve_success_one && resolve_success_two && parse_info->script_id() >= 17 && obj->should_inject()) {
+
+      const AstRawString *args_token;
+      std::string lhs_str, rhs_str;
+      Expression* arg, *typeof, *call;
+      ExpressionStatement *final_call;
+      ZonePtrList<v8::internal::Expression>* args = new_parser.PublicNewExpressionList(7);
+      //assign_id += 1;
+
+      Expression* typeof_expr = ast_node_factory.NewProperty(tmpVar, property->key(), obj->position());
+      typeof = ast_node_factory.NewUnaryOperation(Token::TYPEOF, typeof_expr, -1);
+
+
+      // convert original left hand side to a std::string
+      // left hand side could be of any format, including A["9"], this.window, x.y.z or simple variables etc.
+      lhs_str = ExpressionPrinter(parse_info->stack_limit()).Print(tmpVar);
+      lhs_str += ".";
+      //lhs_str = lhs_str + GetFullString(property->key(), scope, parse_info) + ExpressionPrinter(parse_info->stack_limit()).Print(property->key());
+      lhs_str = lhs_str + ExpressionPrinter(parse_info->stack_limit()).Print(property->key());
+      if(property->key()->rhs_string().length() == 0)
+        rhs_str = GetFullStringForRHS(property->value(), scope, parse_info);
+      else
+        rhs_str = property->key()->rhs_string() + ",elem_js_conflict,rhs_is_var";
+      double current_time = base::Time::Now().ToJsTime();
+      
+      std::string lhs_and_script_url = lhs_str + ",elem_js_conflict,(=)" + rhs_str + ",elem_js_conflict," + std::to_string(parse_info->script_id()) + ",elem_js_conflict," + std::to_string(obj->position()) + ",elem_js_conflict," + std::to_string(current_time);
+      args_token = ast_value_factory->GetOneByteString(lhs_and_script_url.c_str()); 
+      arg = new_parser.PublicExpressionFromString(args_token, scope, &ast_node_factory);
+
+      args->Add(get_asg_id, parse_info->zone());
+      args->Add(arg, parse_info->zone());
+      args->Add(typeof, parse_info->zone());
+
+
+      Expression* typeof_eq_undefined = ast_node_factory.NewCompareOperation(Token::EQ, typeof, typeof_is_undefined, -1);
+      lhs_and_script_url = "---";
+      args_token = ast_value_factory->GetOneByteString(lhs_and_script_url.c_str()); 
+      Expression* else_expr_for_value = new_parser.PublicExpressionFromString(args_token, scope, &ast_node_factory);
+      Expression* typeof_eq_object = ast_node_factory.NewCompareOperation(Token::EQ, typeof, typeof_is_obj, -1);
+      ZonePtrList<v8::internal::Expression>* log_object_value_args = new_parser.PublicNewExpressionList(1);
+      log_object_value_args->Add(typeof_expr, parse_info->zone());
+      if(resolve_success_one) {
+        Expression* log_object_value = ast_node_factory.NewCall(get_global_id, log_object_value_args, -1); // Object.getGlobalId(tmp.x)
+        log_object_value = ast_node_factory.NewConditional(typeof_eq_object, log_object_value, typeof_expr, -1);// if typeof(tmp.x) == "object" then Object.getGlobalId(tmp.x) else tmp.x
+        log_object_value->set_should_inject(false);
+        Expression* log_value = ast_node_factory.NewConditional(typeof_eq_undefined, else_expr_for_value, log_object_value, -1);
+        log_value->set_should_inject(false);
+        args->Add(log_value, parse_info->zone());
+      }
+      else {
+        args->Add(else_expr_for_value, parse_info->zone());
+      }
+      
+
+      if(resolve_success_one) {
+        args->Add(log_global_id, parse_info->zone());
+        ZonePtrList<v8::internal::Expression>* get_id_args = new_parser.PublicNewExpressionList(1);
+        get_id_args->Add(typeof_expr, parse_info->zone());
+        Expression* get_id_anyways = ast_node_factory.NewCall(get_global_id, get_id_args, -1); // Object.getGlobalId(tmp.key)
+        args->Add(get_id_anyways, parse_info->zone());
+      }
+      else {
+        lhs_and_script_url = "---";
+        args_token = ast_value_factory->GetOneByteString(lhs_and_script_url.c_str()); 
+        arg = new_parser.PublicExpressionFromString(args_token, scope, &ast_node_factory);
+        args->Add(arg, parse_info->zone());
+        args->Add(arg, parse_info->zone());
+      }
+
+
+
+      args->Add(get_frame_id, parse_info->zone());
+
+      call = ast_node_factory.NewCall(func_call, args, -1);
+      final_call = ast_node_factory.NewExpressionStatement(call, -1); 
+
+      call->AsCall()->set_should_inject_mark(false);
+      obj->append_asglog_call(call);
+    }
+  }
+  obj->set_should_inject(false);
+}
+
+
+void ExpressionConverter::VisitArrayLiteral(ArrayLiteral* node) {
+  if (node->values()->length() > 0) {
+    for (int i = 0; i < node->values()->length(); i++) {
+      Visit(node->values()->at(i));
+      if(i!=node->values()->length()-1) {
+      }
+    }
+  }
+}
+
+
+void ExpressionConverter::VisitVariableProxy(VariableProxy* node) {
+  EmbeddedVector<char, 128> buf;
+
+  if (!node->is_resolved()) {
+    PrintLiteralWithModeIndented(buf.start(), nullptr, node->raw_name());
+  } else {
+    Variable* var = node->var();
+    switch (var->location()) {
+      case VariableLocation::UNALLOCATED:
+        break;
+      case VariableLocation::PARAMETER:
+        break;
+      case VariableLocation::LOCAL:
+        break;
+      case VariableLocation::CONTEXT:
+        break;
+      case VariableLocation::LOOKUP:
+        break;
+      case VariableLocation::MODULE:
+        break;
+    }
+    PrintLiteralWithModeIndented(buf.start(), var, node->raw_name());
+  }
+}
+
+
+void ExpressionConverter::VisitAssignment(Assignment* node) {
+
+  node->set_should_break(false);
+
+  level_++;
+  ParseInfo* parse_info = info()->parse_info();
+  AstValueFactory* ast_value_factory;
+  AstNodeFactory ast_node_factory(parse_info->ast_value_factory(), parse_info->zone());
+  DeclarationScope* scope;
+  Parser new_parser(parse_info);
+  Expression* caller, *callee, *func_call, *call, *get_global_id_key, *get_global_id_value, *get_global_id, *typeof_is_obj, *typeof_is_func, *condition_check_typeof, *typeof_is_undefined, *get_asg_id, *get_frame_id;
+  Expression* old_lhs = node->target(), *old_rhs = node->value();
+  std::string old_lhs_str, old_rhs_str; 
+  std::string script_url;
+  bool old_should_inject = node->should_inject(), old_is_child = node->is_child(), resolve_success_one = false, resolve_success_two = false, old_force_to_asg = false, old_is_asg = node->IsAssignment();
+  
+  if(node->IsCompoundAssignment())
+    old_force_to_asg = node->AsCompoundAssignment()->force_to_asg();
+
+  bool should_append_call = false;
+  bool resolve_success_three = false, resolve_success_five = false, resolve_success_six = false;
+  if(parse_info->script_id() >= 17) {// && node->should_inject()) {
+    should_append_call = node->should_inject();
+    ast_value_factory = parse_info->GetOrCreateAstValueFactory();
+    scope = parse_info->scope();
+    
+    const AstRawString* callee_token, *caller_token, *get_global_id_key_token, *get_global_id_value_token, *typeof_is_obj_token, *typeof_is_func_token, *typeof_is_undefined_token;
+    const AstRawString* get_asg_id_token, *get_frame_id_token;
+
+    const char* caller_string = "window";
+    const char* callee_string = "appendAsgLogs";
+    
+    const char* get_global_id_key_string = "Object";
+    const char* get_global_id_value_string = "getGlobalId";
+    const char* typeof_is_obj_string = "object";
+    const char* typeof_is_func_string = "function";
+    const char* typeof_is_undefined_string = "undefined";
+
+    const char* get_frame_id_string = "Yx$Q7r$zJUnQUy__FrameID";
+    get_frame_id_token = ast_value_factory->GetOneByteString(get_frame_id_string);
+    get_frame_id = new_parser.PublicExpressionFromIdentifier(get_frame_id_token, scope, &ast_node_factory);
+    resolve_success_five = parse_info->script_scope()->PublicResolveVariable(parse_info, get_frame_id->AsVariableProxy());  
+    const char* get_asg_id_string = "Yx$Q7r$zJUnQUy__GlobalID";
+    get_asg_id_token = ast_value_factory->GetOneByteString(get_asg_id_string);
+    get_asg_id = new_parser.PublicExpressionFromIdentifier(get_asg_id_token, scope, &ast_node_factory);
+    resolve_success_six = parse_info->script_scope()->PublicResolveVariable(parse_info, get_asg_id->AsVariableProxy());  
+
+
+    typeof_is_obj_token = ast_value_factory->GetOneByteString(typeof_is_obj_string);
+    typeof_is_func_token = ast_value_factory->GetOneByteString(typeof_is_func_string);
+    typeof_is_undefined_token = ast_value_factory->GetOneByteString(typeof_is_undefined_string);
+
+    typeof_is_obj = ast_node_factory.NewStringLiteral(typeof_is_obj_token, -1);
+    typeof_is_func = ast_node_factory.NewStringLiteral(typeof_is_func_token, -1);
+    typeof_is_undefined = ast_node_factory.NewStringLiteral(typeof_is_undefined_token, -1);
+
+    get_global_id_key_token = ast_value_factory->GetOneByteString(get_global_id_key_string);    
+    get_global_id_key = new_parser.PublicExpressionFromIdentifier(get_global_id_key_token, scope, &ast_node_factory);
+    resolve_success_three = parse_info->script_scope()->PublicResolveVariable(parse_info, get_global_id_key->AsVariableProxy());   
+    if(resolve_success_three) {
+      get_global_id_value_token = ast_value_factory->GetOneByteString(get_global_id_value_string);    
+      get_global_id_value = ast_node_factory.NewStringLiteral(get_global_id_value_token, -1);
+      get_global_id = ast_node_factory.NewProperty(get_global_id_key, get_global_id_value, -1);
+    }
+
+    
+    bool got_url = false;
+
+    if(parse_info->script().location() && parse_info->script()->name()->IsString()) {
+      std::unique_ptr<char []> script_url_ptr = String::cast(parse_info->script()->name())->ToCString();
+      std::string script_url_str(script_url_ptr.get());
+      script_url = script_url_str;
+      got_url = true;
+    }
+    if(!parse_info->script_url().empty() && got_url == false){
+      script_url = parse_info->script_url();
+      got_url = true;
+    }
+    if(got_url == false) {
+      script_url = "0";
+    }
+
+    std::list<int>::iterator it;
+    if(std::find(script_ids.begin(), script_ids.end(), parse_info->script_id()) == script_ids.end()) {
+      script_ids.push_back(parse_info->script_id());
+      int pid = base::OS::GetCurrentProcessId();
+      char filename[128];
+      sprintf(filename, "%d.id2url", pid);
+      std::ofstream f_out;
+      f_out.open(filename, std::ios::app);
+      if(!f_out)
+        std::cout << "Cannot Open File " << filename << std::endl;
+      else {
+        std::string line = std::to_string(parse_info->script_id()) + "," + script_url;
+        f_out << line << "\n";
+        f_out.flush();
+        f_out.close();
+      }
+    }
+
+    caller_token = ast_value_factory->GetOneByteString(caller_string);    
+    caller = new_parser.PublicExpressionFromIdentifier(caller_token, scope, &ast_node_factory);
+    resolve_success_one = parse_info->script_scope()->PublicResolveVariable(parse_info, caller->AsVariableProxy()); 
+
+    if(resolve_success_one) {
+      callee_token = ast_value_factory->GetOneByteString(callee_string);   
+      callee = ast_node_factory.NewStringLiteral(callee_token, -1);
+      func_call = ast_node_factory.NewProperty(caller, callee, -1);
+
+      old_lhs_str = GetFullString(old_lhs, scope, parse_info) + ExpressionPrinter(parse_info->stack_limit()).Print(old_lhs);
+      old_rhs_str = GetFullStringForRHS(old_rhs, scope, parse_info);
+    }
+  }
+
+  if(resolve_success_one && node->should_inject() && parse_info->script_id() >= 17) {
+    Expression* copied_node = ast_node_factory.NewAssignment(node->op(), node->target(), node->value(), node->position());
+    const AstRawString* tmp_token = parse_info->ast_value_factory()->GetOneByteString(node->allocated_temp_var().c_str());
+    Expression* tmp = new_parser.PublicExpressionFromIdentifier(tmp_token, parse_info->scope(), &ast_node_factory); 
+    resolve_success_two = parse_info->script_scope()->PublicResolveVariable(parse_info, tmp->AsVariableProxy());
+    if(resolve_success_two) {
+      node->set_target(tmp);
+      node->set_value(copied_node);
+      node->set_should_inject(old_should_inject);
+      node->set_is_child(old_is_child);
+      node->set_expr_for_typeof(tmp);
+    }
+    if(!node->value()->IsCompoundAssignment()) {
+      node->value()->AsAssignment()->set_should_inject(false); 
+    }
+    else {
+      node->value()->AsCompoundAssignment()->set_should_inject(false);
+      node->AsCompoundAssignment()->set_force_to_asg(true);
+    }
+  }
+
+
+  node->target()->set_is_child(true);
+  node->value()->set_is_child(true);
+  
+  
+  if(level_ == 0 && !node->is_child()) {
+    node->set_should_start_log(true);
+  }
+  else {
+    node->set_should_start_log(false);
+  }
+
+  node->set_should_inject(false);
+
+  Visit(node->target());
+  Visit(node->value());  
+  node->set_should_inject(false);
+
+  if(node->value()->IsAssignment()) {
+    node->value()->AsAssignment()->target()->set_should_inject(false);
+    node->value()->AsAssignment()->value()->set_should_inject(false);
+  }
+  else if(node->value()->IsCompoundAssignment()) {
+    node->value()->AsCompoundAssignment()->target()->set_should_inject(false);
+    node->value()->AsCompoundAssignment()->value()->set_should_inject(false);
+  }
+
+  if(node->value()->has_temp_var() && (node->IsAssignment() || (node->IsCompoundAssignment() && node->AsCompoundAssignment()->force_to_asg())) && parse_info->script_id()>=17) { 
+    // for compound assignment, no need to create an alias
+    const char* rand_chars = node->value()->allocated_temp_var().c_str();
+    node->target()->set_rhs_string(std::string(rand_chars)); // do NOT create a real asg to avoid overwritting reference
+  }
+
+
+
+  if(should_append_call && resolve_success_one && resolve_success_two && resolve_success_five && resolve_success_six) {
+    const AstRawString *args_token;
+    std::string lhs_str, rhs_str;
+    Expression* arg, *typeof;
+    ExpressionStatement *final_call;
+    ZonePtrList<v8::internal::Expression>* args = new_parser.PublicNewExpressionList(7);
+    //assign_id += 1;
+    typeof = ast_node_factory.NewUnaryOperation(Token::TYPEOF, node->expr_for_typeof(), -1);
+
+    // convert original left hand side to a std::string
+    // left hand side could be of any format, including A["9"], this.window, x.y.z or simple variables etc.
+    lhs_str = old_lhs_str;
+    if(old_lhs->rhs_string().length() == 0)
+    	rhs_str = old_rhs_str;
+    else
+	    rhs_str = old_lhs->rhs_string() + ",elem_js_conflict,rhs_is_var";
+
+    if(lhs_str.compare(rhs_str.substr(0, rhs_str.find(","))) != 0 || lhs_str.rfind("Yx$Q7r$zJUnQUy__") != 0 || rhs_str.rfind("Yx$Q7r$zJUnQUy__") != 0) {
+      
+      std::string lhs_and_script_url;  
+      double current_time = base::Time::Now().ToJsTime();
+      if(old_is_asg || old_force_to_asg) 
+        lhs_and_script_url = lhs_str + ",elem_js_conflict,(=)" + rhs_str + ",elem_js_conflict," + std::to_string(parse_info->script_id()) + ",elem_js_conflict," + std::to_string(node->position()) + ",elem_js_conflict," + std::to_string(current_time);
+      else
+        lhs_and_script_url = lhs_str + ",elem_js_conflict,(" + Token::String(node->op()) + ")" + rhs_str + ",elem_js_conflict," + std::to_string(parse_info->script_id()) + ",elem_js_conflict," + std::to_string(node->position()) + ",elem_js_conflict," + std::to_string(current_time);
+
+      args_token = ast_value_factory->GetOneByteString(lhs_and_script_url.c_str()); 
+      arg = new_parser.PublicExpressionFromString(args_token, scope, &ast_node_factory);
+
+      get_asg_id = ast_node_factory.NewCountOperation(Token::INC, false, get_asg_id, -1);
+      args->Add(get_asg_id, parse_info->zone());
+      args->Add(arg, parse_info->zone());
+      args->Add(typeof, parse_info->zone());
+
+      Expression* typeof_eq_undefined = ast_node_factory.NewCompareOperation(Token::EQ, typeof, typeof_is_undefined, -1);
+      lhs_and_script_url = "---";
+      args_token = ast_value_factory->GetOneByteString(lhs_and_script_url.c_str()); 
+      Expression* else_expr_for_value = new_parser.PublicExpressionFromString(args_token, scope, &ast_node_factory);
+      Expression* typeof_eq_object = ast_node_factory.NewCompareOperation(Token::EQ, typeof, typeof_is_obj, -1);
+      if(resolve_success_three) {
+        ZonePtrList<v8::internal::Expression>* log_object_value_args = new_parser.PublicNewExpressionList(1);
+        log_object_value_args->Add(node->expr_for_typeof(), parse_info->zone());
+        Expression* log_obj_value = ast_node_factory.NewCall(get_global_id, log_object_value_args, -1); //Object.getGlobalId(tmp)
+        log_obj_value = ast_node_factory.NewConditional(typeof_eq_object, log_obj_value, node->expr_for_typeof(), -1);// if typeof(tmp) == "object" then Object.getGlobalId(tmp) else tmp
+        log_obj_value->set_should_inject(false);
+        Expression* log_value = ast_node_factory.NewConditional(typeof_eq_undefined, else_expr_for_value, log_obj_value, -1); // if typeof(tmp) == "undefined" then "---" else if typeof(tmp) == "object" then Object.getGlobalId(tmp) else tmp
+        log_value->set_should_inject(false);
+        args->Add(log_value, parse_info->zone());
+      }
+      else {
+        args->Add(else_expr_for_value, parse_info->zone());
+      }
+
+      Expression* then_expr, *log_global_id, *typeof_for_id, *else_expr;
+      if(resolve_success_three) {
+        ZonePtrList<v8::internal::Expression>* get_id_args = new_parser.PublicNewExpressionList(1);
+        if(old_lhs->IsProperty()) {
+          get_id_args->Add(old_lhs->AsProperty()->obj(), parse_info->zone());
+          typeof_for_id = ast_node_factory.NewUnaryOperation(Token::TYPEOF, old_lhs->AsProperty()->obj(), -1);
+          typeof_is_obj = ast_node_factory.NewCompareOperation(Token::EQ, typeof_for_id, typeof_is_obj, -1);
+          typeof_is_func = ast_node_factory.NewCompareOperation(Token::EQ, typeof_for_id, typeof_is_func, -1);
+          condition_check_typeof = ast_node_factory.NewBinaryOperation(Token::OR, typeof_is_obj, typeof_is_func, -1); // typeof(tmp) == "object" || typeof(tmp) == "function"
+        }
+        else {
+          get_id_args->Add(node->expr_for_typeof(), parse_info->zone());
+          typeof_for_id = typeof;
+          typeof_is_obj = ast_node_factory.NewCompareOperation(Token::EQ, typeof_for_id, typeof_is_obj, -1);
+          typeof_is_func = ast_node_factory.NewCompareOperation(Token::EQ, typeof_for_id, typeof_is_func, -1);
+          condition_check_typeof = ast_node_factory.NewBinaryOperation(Token::OR, typeof_is_obj, typeof_is_func, -1); // typeof(tmp) == "object" || typeof(tmp) == "function"
+        }
+        Expression* get_global_id_ = ast_node_factory.NewCall(get_global_id, get_id_args, -1); // Object.getGlobalId(tmp)
+        lhs_and_script_url = "---";
+        args_token = ast_value_factory->GetOneByteString(lhs_and_script_url.c_str()); 
+        else_expr = new_parser.PublicExpressionFromString(args_token, scope, &ast_node_factory);
+        then_expr = get_global_id_;
+        log_global_id = ast_node_factory.NewConditional(condition_check_typeof, then_expr, else_expr, -1);
+        log_global_id->set_should_inject(false);
+        args->Add(log_global_id, parse_info->zone()); // if(typeof(tmp) == "object" || typeof(tmp) == "function") Object.getGlobalId(tmp); else "---";
+        
+        ZonePtrList<v8::internal::Expression>* get_id_args_one = new_parser.PublicNewExpressionList(1);
+        get_id_args_one->Add(node->expr_for_typeof(), parse_info->zone());
+        get_global_id_ = ast_node_factory.NewCall(get_global_id, get_id_args_one, -1); // Object.getGlobalId(tmp)
+        args->Add(get_global_id_, parse_info->zone());
+
+      }
+      else {
+        lhs_and_script_url = "---";
+        args_token = ast_value_factory->GetOneByteString(lhs_and_script_url.c_str()); 
+        arg = new_parser.PublicExpressionFromString(args_token, scope, &ast_node_factory);
+        args->Add(arg, parse_info->zone());
+        args->Add(arg, parse_info->zone());
+      }
+
+      args->Add(get_frame_id, parse_info->zone());
+
+      call = ast_node_factory.NewCall(func_call, args, -1);
+      final_call = ast_node_factory.NewExpressionStatement(call, -1); 
+
+      call->AsCall()->set_should_inject_mark(false);
+      node->append_asglog_call(call);
+    }
+  }
+  node->set_should_inject(false);
+}
+
+void ExpressionConverter::VisitCompoundAssignment(CompoundAssignment* node) {
+  VisitAssignment(node);
+}
+
+void ExpressionConverter::VisitYield(Yield* node) {
+  EmbeddedVector<char, 128> buf;
+  Visit(node->expression());
+}
+
+void ExpressionConverter::VisitYieldStar(YieldStar* node) {
+  EmbeddedVector<char, 128> buf;
+  Visit(node->expression());
+}
+
+void ExpressionConverter::VisitAwait(Await* node) {
+  EmbeddedVector<char, 128> buf;
+  Visit(node->expression());
+}
+
+void ExpressionConverter::VisitThrow(Throw* node) {
+  Visit(node->exception());
+}
+
+void ExpressionConverter::VisitProperty(Property* node) {
+  EmbeddedVector<char, 128> buf;
+
+  Visit(node->obj());
+  LhsKind property_kind = Property::GetAssignType(node);
+  if (property_kind == NAMED_PROPERTY ||
+      property_kind == NAMED_SUPER_PROPERTY) {
+    PrintLiteralIndented("NAME", node->key()->AsLiteral(), false);
+  } else {
+    DCHECK(property_kind == KEYED_PROPERTY ||
+           property_kind == KEYED_SUPER_PROPERTY);
+    PrintIndentedVisit("KEY", node->key());
+  }
+}
+
+void ExpressionConverter::VisitResolvedProperty(ResolvedProperty* node) {
+  EmbeddedVector<char, 128> buf;
+
+  PrintIndentedVisit("RECEIVER", node->object());
+  PrintIndentedVisit("PROPERTY", node->property());
+}
+
+void ExpressionConverter::VisitCall(Call* node) {
+  EmbeddedVector<char, 128> buf;
+  level_++;
+  if(level_==0 && !node->is_child())
+    node->set_should_start_log(true);
+  else
+    node->set_should_start_log(false);
+
+
+  Expression* callee_expr = node->expression();
+  ParseInfo* parse_info = info()->parse_info();
+  AstValueFactory* ast_value_factory;
+  AstNodeFactory ast_node_factory(parse_info->ast_value_factory(), parse_info->zone());
+  DeclarationScope* scope;
+  Parser new_parser(parse_info);
+  Expression* caller, *obj_callee, *func_call, *get_frame_id;
+  std::string script_url;
+  bool resolve_success = false, resolve_success_one = false;
+
+  if(parse_info->script_id() >= 17) {
+    ast_value_factory = parse_info->GetOrCreateAstValueFactory();
+    scope = parse_info->scope();
+    
+    const AstRawString* callee_token, *caller_token, *get_frame_id_token;
+    const char* caller_string = "window";
+    const char* callee_string = "appendAsgLogs";
+
+    const char* get_frame_id_string = "Yx$Q7r$zJUnQUy__FrameID";
+    get_frame_id_token = ast_value_factory->GetOneByteString(get_frame_id_string);
+    get_frame_id = new_parser.PublicExpressionFromIdentifier(get_frame_id_token, scope, &ast_node_factory);
+    resolve_success_one = parse_info->script_scope()->PublicResolveVariable(parse_info, get_frame_id->AsVariableProxy());  
+
+    bool got_url = false;
+
+    if(parse_info->script().location() && parse_info->script()->name()->IsString()) {
+      std::unique_ptr<char []> script_url_ptr = String::cast(parse_info->script()->name())->ToCString();
+      std::string script_url_str(script_url_ptr.get());
+      script_url = script_url_str;
+      got_url = true;
+    }
+    if(!parse_info->script_url().empty() && got_url == false){
+      script_url = parse_info->script_url();
+      got_url = true;
+    }
+    if(got_url == false) {
+      script_url = "0";
+    }
+
+    std::list<int>::iterator it;
+    if(std::find(script_ids.begin(), script_ids.end(), parse_info->script_id()) == script_ids.end()) {
+      script_ids.push_back(parse_info->script_id());
+      int pid = base::OS::GetCurrentProcessId();
+      char filename[128];
+      sprintf(filename, "%d.id2url", pid);
+      std::ofstream f_out;
+      f_out.open(filename, std::ios::app);
+      if(!f_out)
+        std::cout << "Cannot Open File " << filename << std::endl;
+      else {
+        std::string line = std::to_string(parse_info->script_id()) + "," + script_url;
+        f_out << line << "\n";
+        f_out.flush();
+        f_out.close();
+      }
+    }
+
+    caller_token = ast_value_factory->GetOneByteString(caller_string);    
+    caller = new_parser.PublicExpressionFromIdentifier(caller_token, scope, &ast_node_factory);
+
+    resolve_success = parse_info->script_scope()->PublicResolveVariable(parse_info, caller->AsVariableProxy());    
+
+    if(resolve_success) {
+      callee_token = ast_value_factory->GetOneByteString(callee_string);   
+      obj_callee = ast_node_factory.NewStringLiteral(callee_token, -1);
+      func_call = ast_node_factory.NewProperty(caller, obj_callee, -1);
+    }
+  }
+
+
+
+  std::string current_callee_name = ExpressionPrinter(parse_info->stack_limit()).Print(callee_expr);
+  bool has_injected = false;
+
+  if(resolve_success && parse_info->script_id() >= 17 && node->should_inject_mark() && !node->has_logged() && resolve_success_one) {
+  
+    bool should_skip_obj_call = false;
+    if(callee_expr->IsProperty()) {
+      std::string obj_call_key = ExpressionPrinter(parse_info->stack_limit()).Print(callee_expr->AsProperty()->key());
+      std::string obj_call_obj = ExpressionPrinter(parse_info->stack_limit()).Print(callee_expr->AsProperty()->obj());
+      if(obj_call_key.compare(std::string("getGlobalId")) == 0 && obj_call_obj.compare(std::string("Object")) == 0)
+        should_skip_obj_call = true;
+    }
+
+    if(!should_skip_obj_call) {
+
+      const AstRawString *obj_args_token;
+      Expression* obj_arg, *obj_call;
+      ExpressionStatement *obj_final_call;
+
+      ZonePtrList<v8::internal::Expression>* obj_args = new_parser.PublicNewExpressionList(7);
+      
+      //LhsKind property_kind = Property::GetAssignType(callee_expr->AsProperty());
+      std::string obj_call_type;
+      obj_call_type = "is_call,elem_js_conflict,";
+      std::string lhs_and_script_url = obj_call_type + GetFullString(callee_expr, scope, parse_info) + ExpressionPrinter(parse_info->stack_limit()).Print(callee_expr);
+      //std::string lhs_and_script_url = obj_call_type + ExpressionPrinter(parse_info->stack_limit()).Print(callee_expr);
+      obj_args_token = ast_value_factory->GetOneByteString(lhs_and_script_url.c_str()); 
+      obj_arg = new_parser.PublicExpressionFromString(obj_args_token, scope, &ast_node_factory);
+      obj_args->Add(obj_arg, parse_info->zone());
+      
+      double current_time = base::Time::Now().ToJsTime();
+      lhs_and_script_url = std::to_string(parse_info->script_id()) + ",elem_js_conflict," + std::to_string(current_time);
+      obj_args_token = ast_value_factory->GetOneByteString(lhs_and_script_url.c_str()); 
+      obj_arg = new_parser.PublicExpressionFromString(obj_args_token, scope, &ast_node_factory);
+      obj_args->Add(obj_arg, parse_info->zone());
+
+      lhs_and_script_url = std::to_string(node->position());
+      obj_args_token = ast_value_factory->GetOneByteString(lhs_and_script_url.c_str()); 
+      obj_arg = new_parser.PublicExpressionFromString(obj_args_token, scope, &ast_node_factory);
+      obj_args->Add(obj_arg, parse_info->zone());
+
+      lhs_and_script_url = "---";
+      obj_args_token = ast_value_factory->GetOneByteString(lhs_and_script_url.c_str()); 
+      obj_arg = new_parser.PublicExpressionFromString(obj_args_token, scope, &ast_node_factory);
+      obj_args->Add(obj_arg, parse_info->zone());
+
+      obj_args->Add(obj_arg, parse_info->zone());
+      obj_args->Add(obj_arg, parse_info->zone());
+
+      obj_args->Add(get_frame_id, parse_info->zone());
+
+      obj_call = ast_node_factory.NewCall(func_call, obj_args, -1);
+      obj_final_call = ast_node_factory.NewExpressionStatement(obj_call, -1);     
+
+      // now call visitCall to generate bytecode for window.appendAsgLogs() instructions  
+      node->append_asglog_call(obj_call);
+      obj_call->AsCall()->set_should_inject_mark(false); 
+    }
+    has_injected = true;
+  }
+
+ 
+  node->expression()->set_is_child(true); 
+  Visit(node->expression());
+  PrintArguments(node->arguments());
+  node->set_should_inject(false);
+}
+
+
+void ExpressionConverter::VisitCallNew(CallNew* node) {
+
+  level_++;
+  ParseInfo* parse_info = info()->parse_info();
+  AstValueFactory* ast_value_factory;
+  AstNodeFactory ast_node_factory(parse_info->ast_value_factory(), parse_info->zone());
+  DeclarationScope* scope;
+  Parser new_parser(parse_info);
+  Expression* caller, *callee, *func_call, *get_frame_id;
+  std::string script_url;
+  bool resolve_success_one = false, resolve_success_three = false;
+
+  if(parse_info->script_id() >= 17) {
+    ast_value_factory = parse_info->GetOrCreateAstValueFactory();
+    scope = parse_info->scope();
+    
+    const AstRawString* callee_token, *caller_token, *get_frame_id_token;
+    const char* caller_string = "window";
+    const char* callee_string = "appendAsgLogs";
+ 
+    const char* get_frame_id_string = "Yx$Q7r$zJUnQUy__FrameID"; 
+    get_frame_id_token = ast_value_factory->GetOneByteString(get_frame_id_string);
+    get_frame_id = new_parser.PublicExpressionFromIdentifier(get_frame_id_token, scope, &ast_node_factory);
+    resolve_success_three = parse_info->script_scope()->PublicResolveVariable(parse_info, get_frame_id->AsVariableProxy());  
+
+
+
+    bool got_url = false;
+
+    if(parse_info->script().location() && parse_info->script()->name()->IsString()) {
+      std::unique_ptr<char []> script_url_ptr = String::cast(parse_info->script()->name())->ToCString();
+      std::string script_url_str(script_url_ptr.get());
+      script_url = script_url_str;
+      got_url = true;
+    }
+    if(!parse_info->script_url().empty() && got_url == false){
+      script_url = parse_info->script_url();
+      got_url = true;
+    }
+    if(got_url == false) {
+      script_url = "0";
+    }
+
+    std::list<int>::iterator it;
+    if(std::find(script_ids.begin(), script_ids.end(), parse_info->script_id()) == script_ids.end()) {
+      script_ids.push_back(parse_info->script_id());
+      int pid = base::OS::GetCurrentProcessId();
+      char filename[128];
+      sprintf(filename, "%d.id2url", pid);
+      std::ofstream f_out;
+      f_out.open(filename, std::ios::app);
+      if(!f_out)
+        std::cout << "Cannot Open File " << filename << std::endl;
+      else {
+        std::string line = std::to_string(parse_info->script_id()) + "," + script_url;
+        f_out << line << "\n";
+        f_out.flush();
+        f_out.close();
+      }
+    }
+
+    caller_token = ast_value_factory->GetOneByteString(caller_string);    
+    caller = new_parser.PublicExpressionFromIdentifier(caller_token, scope, &ast_node_factory);
+    resolve_success_one = parse_info->script_scope()->PublicResolveVariable(parse_info, caller->AsVariableProxy()); 
+
+    if(resolve_success_one) {
+      callee_token = ast_value_factory->GetOneByteString(callee_string);   
+      callee = ast_node_factory.NewStringLiteral(callee_token, -1);
+      func_call = ast_node_factory.NewProperty(caller, callee, -1);
+    }
+  }
+
+
+
+  Expression* callee_expr = node->expression();
+  std::string current_callee_name = ExpressionPrinter(parse_info->stack_limit()).Print(callee_expr);
+
+  if(parse_info->script_id() >= 17  && node->should_inject() && resolve_success_three) {
+    const AstRawString *obj_args_token;
+    Expression* obj_arg, *obj_call;
+    ExpressionStatement *obj_final_call;
+
+    ZonePtrList<v8::internal::Expression>* obj_args = new_parser.PublicNewExpressionList(7);
+
+    //LhsKind property_kind = Property::GetAssignType(callee_expr->AsProperty());
+    std::string obj_new_type;
+    obj_new_type = "is_call_new,elem_js_conflict,";
+
+    std::string lhs_and_script_url = obj_new_type + GetFullString(callee_expr, scope, parse_info) + ExpressionPrinter(parse_info->stack_limit()).Print(callee_expr);
+    //std::string lhs_and_script_url = obj_new_type + ExpressionPrinter(parse_info->stack_limit()).Print(callee_expr);
+    obj_args_token = ast_value_factory->GetOneByteString(lhs_and_script_url.c_str()); 
+    obj_arg = new_parser.PublicExpressionFromString(obj_args_token, scope, &ast_node_factory);
+    obj_args->Add(obj_arg, parse_info->zone());
+    
+    double current_time = base::Time::Now().ToJsTime();
+    lhs_and_script_url = std::to_string(parse_info->script_id()) + ",elem_js_conflict," + std::to_string(current_time);
+    obj_args_token = ast_value_factory->GetOneByteString(lhs_and_script_url.c_str()); 
+    obj_arg = new_parser.PublicExpressionFromString(obj_args_token, scope, &ast_node_factory);
+    obj_args->Add(obj_arg, parse_info->zone());
+
+    lhs_and_script_url = std::to_string(node->position());
+    obj_args_token = ast_value_factory->GetOneByteString(lhs_and_script_url.c_str()); 
+    obj_arg = new_parser.PublicExpressionFromString(obj_args_token, scope, &ast_node_factory);
+    obj_args->Add(obj_arg, parse_info->zone());
+
+    lhs_and_script_url = "---";
+    obj_args_token = ast_value_factory->GetOneByteString(lhs_and_script_url.c_str()); 
+    obj_arg = new_parser.PublicExpressionFromString(obj_args_token, scope, &ast_node_factory);
+    obj_args->Add(obj_arg, parse_info->zone());
+
+    obj_args->Add(obj_arg, parse_info->zone());
+    obj_args->Add(obj_arg, parse_info->zone());
+
+    obj_args->Add(get_frame_id, parse_info->zone());
+
+
+    obj_call = ast_node_factory.NewCall(func_call, obj_args, -1);
+    obj_final_call = ast_node_factory.NewExpressionStatement(obj_call, -1);     
+
+    // now call visitCall to generate bytecode for window.appendAsgLogs() instructions  
+    obj_call->AsCall()->set_should_inject_mark(false); 
+    node->append_asglog_call(obj_call);
+  }
+
+
+  if(level_==0 && !node->is_child()) {
+    node->set_should_start_log(true);
+  }
+  else {
+    node->set_should_start_log(false);
+  }
+ 
+  node->set_should_inject(false);
+  node->expression()->set_is_child(true);
+  Visit(node->expression());
+  PrintArguments(node->arguments());
+  node->set_should_inject(false);
+}
+
+
+void ExpressionConverter::VisitCallRuntime(CallRuntime* node) {
+  EmbeddedVector<char, 128> buf;
+  PrintArguments(node->arguments());
+}
+
+
+void ExpressionConverter::VisitUnaryOperation(UnaryOperation* node) {
+  Visit(node->expression());
+}
+
+
+void ExpressionConverter::VisitCountOperation(CountOperation* node) {
+  EmbeddedVector<char, 128> buf;
+  if(node->is_prefix()) {
+  }
+  Visit(node->expression());
+  if(!node->is_prefix()) {
+  }
+}
+
+
+void ExpressionConverter::VisitBinaryOperation(BinaryOperation* node) {
+  Visit(node->left());
+  Visit(node->right());
+}
+
+void ExpressionConverter::VisitNaryOperation(NaryOperation* node) {
+  Visit(node->first());
+  for (size_t i = 0; i < node->subsequent_length(); ++i) {
+    Visit(node->subsequent(i));
+    if(i!=node->subsequent_length()-1) {
+    }
+  }
+}
+
+void ExpressionConverter::VisitCompareOperation(CompareOperation* node) {
+  Visit(node->left());
+  Visit(node->right());
+}
+
+
+void ExpressionConverter::VisitSpread(Spread* node) {
+  Visit(node->expression());
+}
+
+void ExpressionConverter::VisitStoreInArrayLiteral(StoreInArrayLiteral* node) {
+  PrintIndentedVisit("ARRAY", node->array());
+  PrintIndentedVisit("INDEX", node->index());
+  PrintIndentedVisit("VALUE", node->value());
+}
+
+void ExpressionConverter::VisitEmptyParentheses(EmptyParentheses* node) {
+}
+
+void ExpressionConverter::VisitGetIterator(GetIterator* node) {
+  Visit(node->iterable());
+}
+
+void ExpressionConverter::VisitGetTemplateObject(GetTemplateObject* node) {
+}
+
+void ExpressionConverter::VisitTemplateLiteral(TemplateLiteral* node) {
+  const AstRawString* string = node->string_parts()->first();
+  if (!string->IsEmpty()) PrintLiteralIndented("SPAN", string, true);
+  for (int i = 0; i < node->substitutions()->length();) {
+    PrintIndentedVisit("EXPR", node->substitutions()->at(i++));
+    if (i < node->string_parts()->length()) {
+      string = node->string_parts()->at(i);
+      if (!string->IsEmpty()) PrintLiteralIndented("SPAN", string, true);
+    }
+  }
+}
+
+void ExpressionConverter::VisitImportCallExpression(ImportCallExpression* node) {
+  Visit(node->argument());
+}
+
+void ExpressionConverter::VisitThisFunction(ThisFunction* node) {
+}
+
+
+void ExpressionConverter::VisitSuperPropertyReference(SuperPropertyReference* node) {
+}
+
+
+void ExpressionConverter::VisitSuperCallReference(SuperCallReference* node) {
+}
+
+
+void ExpressionConverter::VisitRewritableExpression(RewritableExpression* node) {
+  Visit(node->expression());
+}
+
+
+}  // namespace internal
+}  // namespace v8
diff --git a/src/parsing/expression-converter.h b/src/parsing/expression-converter.h
new file mode 100644
index 0000000..76138a8
--- /dev/null
+++ b/src/parsing/expression-converter.h
@@ -0,0 +1,94 @@
+// Copyright 2012 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_EXPRESSION_CONVERTER_H_
+#define V8_EXPRESSION_CONVERTER_H_
+
+#include "src/allocation.h"
+#include "src/ast/ast.h"
+#include "src/base/compiler-specific.h"
+#include "src/unoptimized-compilation-info.h"
+
+namespace v8 {
+namespace internal {
+
+
+class ExpressionConverter final : public AstVisitor<ExpressionConverter> {
+ public:
+  explicit ExpressionConverter(uintptr_t stack_limit, ParseInfo* parse_info, UnoptimizedCompilationInfo* info, Scope* closure_scope);
+  ~ExpressionConverter();
+
+  // The following routines convert all assignment expr into tmp=expr.
+  void Print(AstNode* node);
+  void PrintProgram(FunctionLiteral* program);
+
+  void PRINTF_FORMAT(2, 3) Print(const char* format, ...);
+
+  // Print a node to stdout.
+  static void PrintOut(Isolate* isolate, AstNode* node);
+
+  // Individual nodes
+#define DECLARE_VISIT(type) void Visit##type(type* node);
+  AST_NODE_LIST(DECLARE_VISIT)
+#undef DECLARE_VISIT
+
+ private:
+  friend class IndentedScope;
+
+  void Init();
+
+  void PrintLabels(ZonePtrList<const AstRawString>* labels);
+  void PrintLiteral(const AstRawString* value, bool quote);
+  void PrintLiteral(const AstConsString* value, bool quote);
+  void PrintLiteral(Literal* literal, bool quote);
+  void PrintIndented(const char* txt);
+  void PrintIndentedVisit(const char* s, AstNode* node);
+
+  void PrintStatements(ZonePtrList<Statement>* statements);
+  void PrintDeclarations(Declaration::List* declarations);
+  void PrintParameters(DeclarationScope* scope);
+  void PrintArguments(ZonePtrList<Expression>* arguments);
+  void PrintCaseClause(CaseClause* clause);
+  void PrintLiteralIndented(const char* info, Literal* literal, bool quote);
+  void PrintLiteralIndented(const char* info, const AstRawString* value,
+                            bool quote);
+  void PrintLiteralIndented(const char* info, const AstConsString* value,
+                            bool quote);
+  void PrintLiteralWithModeIndented(const char* info, Variable* var,
+                                    const AstRawString* value);
+  void PrintLabelsIndented(ZonePtrList<const AstRawString>* labels,
+                           const char* prefix = "");
+  void PrintObjectProperties(ObjectLiteral* obj, Expression* tmpVar, bool resolve_success, ZonePtrList<ObjectLiteral::Property>* properties);
+  void PrintClassProperties(ZonePtrList<ClassLiteral::Property>* properties);
+
+  void inc_indent() { indent_++; }
+  void dec_indent() { indent_--; }
+  UnoptimizedCompilationInfo* info() {return info_;}
+  Scope* closure_scope() {return closure_scope_;}
+
+
+  std::string ConvertIdentifierToString(const AstRawString* identifier);
+  std::string GetFullString(Expression* expr, Scope* scope, ParseInfo* info);
+  std::string GetFullStringForRHS(Expression* expr, Scope* scope, ParseInfo* info);
+  std::string TraverseDeclarationsInOuterScopes(Scope* scope, ParseInfo* info, Expression* expr, bool* already_found);
+  std::string CheckDeclarationsInCurrentScope(ParseInfo* parse_info, Expression* expr, int asg_pos, bool *already_found);
+  void MarkStartofFunction(FunctionLiteral* node);
+
+  DEFINE_AST_VISITOR_SUBCLASS_MEMBERS();
+
+  char* output_;  // output string buffer
+  int size_;      // output_ size
+  int pos_;       // current printing position
+  int indent_;
+  ParseInfo* parse_info_;
+  int level_;
+  Scope* closure_scope_;
+  UnoptimizedCompilationInfo* info_;
+};
+
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_EXPRESSION_CONVERTER_H_
diff --git a/src/parsing/expression-printer.cc b/src/parsing/expression-printer.cc
new file mode 100644
index 0000000..4f58490
--- /dev/null
+++ b/src/parsing/expression-printer.cc
@@ -0,0 +1,916 @@
+// Copyright 2012 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "src/parsing/expression-printer.h"
+
+#include <stdarg.h>
+
+#include "src/ast/ast-value-factory.h"
+#include "src/ast/scopes.h"
+#include "src/base/platform/platform.h"
+#include "src/globals.h"
+#include "src/objects-inl.h"
+#include "src/string-builder-inl.h"
+
+namespace v8 {
+namespace internal {
+
+
+
+// Printing support
+inline const char* VariableMode2String(VariableMode mode) {
+  switch (mode) {
+    case VariableMode::kVar:
+      return "VAR";
+    case VariableMode::kLet:
+      return "LET";
+    case VariableMode::kConst:
+      return "CONST";
+    case VariableMode::kDynamic:
+      return "DYNAMIC";
+    case VariableMode::kDynamicGlobal:
+      return "DYNAMIC_GLOBAL";
+    case VariableMode::kDynamicLocal:
+      return "DYNAMIC_LOCAL";
+    case VariableMode::kTemporary:
+      return "TEMPORARY";
+  }
+  UNREACHABLE();
+}
+
+//-----------------------------------------------------------------------------
+
+
+
+const char* ExpressionPrinter::Print(AstNode* node) {
+  Init();
+  Visit(node);
+  return output_;
+}
+
+void ExpressionPrinter::Init() {
+  if (size_ == 0) {
+    DCHECK_NULL(output_);
+    const int initial_size = 256;
+    output_ = NewArray<char>(initial_size);
+    size_ = initial_size;
+  }
+  output_[0] = '\0';
+  pos_ = 0;
+}
+
+void ExpressionPrinter::Print(const char* format, ...) {
+  for (;;) {
+    va_list arguments;
+    va_start(arguments, format);
+    int n = VSNPrintF(Vector<char>(output_, size_) + pos_,
+                      format,
+                      arguments);
+    va_end(arguments);
+
+    if (n >= 0) {
+      // there was enough space - we are done
+      pos_ += n;
+      return;
+    } else {
+      // there was not enough space - allocate more and try again
+      const int slack = 32;
+      int new_size = size_ + (size_ >> 1) + slack;
+      char* new_output = NewArray<char>(new_size);
+      MemCopy(new_output, output_, pos_);
+      DeleteArray(output_);
+      output_ = new_output;
+      size_ = new_size;
+    }
+  }
+}
+
+void ExpressionPrinter::PrintLabels(ZonePtrList<const AstRawString>* labels) {
+  if (labels != nullptr) {
+    for (int i = 0; i < labels->length(); i++) {
+      PrintLiteral(labels->at(i), false);
+      Print(": ");
+    }
+  }
+}
+
+void ExpressionPrinter::PrintLiteral(Literal* literal, bool quote) {
+  switch (literal->type()) {
+    case Literal::kString:
+      if(literal->quote())
+        Print("\"");
+      PrintLiteral(literal->AsRawString(), quote);
+      if(literal->quote())
+        Print("\"");
+      break;
+    case Literal::kSymbol:
+      const char* symbol;
+      switch (literal->AsSymbol()) {
+        case AstSymbol::kHomeObjectSymbol:
+          symbol = "HomeObjectSymbol";
+      }
+      ///Print("%s", symbol);
+      break;
+    case Literal::kSmi:
+      Print("%d", Smi::ToInt(literal->AsSmiLiteral()));
+      break;
+    case Literal::kHeapNumber:
+      Print("%g", literal->AsNumber());
+      break;
+    case Literal::kBigInt:
+      Print("%sn", literal->AsBigInt().c_str());
+      break;
+    case Literal::kNull:
+      Print("null");
+      break;
+    case Literal::kUndefined:
+      Print("undefined");
+      break;
+    case Literal::kTheHole:
+      Print("the hole");
+      break;
+    case Literal::kBoolean:
+      if (literal->ToBooleanIsTrue()) {
+        Print("true");
+      } else {
+        Print("false");
+      }
+      break;
+  }
+}
+
+void ExpressionPrinter::PrintLiteral(const AstRawString* value, bool quote) {
+  ///if (quote) Print("\"");
+  if (value != nullptr) {
+    const char* format = value->is_one_byte() ? "%c" : "%lc";
+    const int increment = value->is_one_byte() ? 1 : 2;
+    const unsigned char* raw_bytes = value->raw_data();
+    for (int i = 0; i < value->length(); i += increment) {
+      Print(format, raw_bytes[i]);
+    }
+  }
+  ///if (quote) Print("\"");
+}
+
+void ExpressionPrinter::PrintLiteral(const AstConsString* value, bool quote) {
+  ///if (quote) Print("\"");
+  if (value != nullptr) {
+    std::forward_list<const AstRawString*> strings = value->ToRawStrings();
+    for (const AstRawString* string : strings) {
+      PrintLiteral(string, false);
+    }
+  }
+  ///if (quote) Print("\"");
+}
+
+//-----------------------------------------------------------------------------
+
+class IndentedScope {
+ public:
+  IndentedScope(ExpressionPrinter* printer, const char* txt)
+      : exp_printer_(printer) {
+    exp_printer_->PrintIndented(txt);
+    exp_printer_->inc_indent();
+  }
+
+  IndentedScope(ExpressionPrinter* printer, const char* txt, int pos)
+      : exp_printer_(printer) {
+    exp_printer_->PrintIndented(txt);
+    exp_printer_->inc_indent();
+  }
+
+  virtual ~IndentedScope() {
+    exp_printer_->dec_indent();
+  }
+
+ private:
+  ExpressionPrinter* exp_printer_;
+};
+
+
+//-----------------------------------------------------------------------------
+
+ExpressionPrinter::ExpressionPrinter(uintptr_t stack_limit)
+    : output_(nullptr), size_(0), pos_(0), indent_(0) {
+  InitializeAstVisitor(stack_limit);
+}
+
+ExpressionPrinter::~ExpressionPrinter() {
+  DCHECK_EQ(indent_, 0);
+  DeleteArray(output_);
+}
+
+
+void ExpressionPrinter::PrintIndented(const char* txt) {
+  Print("%s", txt);
+}
+
+void ExpressionPrinter::PrintLiteralIndented(const char* info, Literal* literal,
+                                      bool quote) {
+  PrintLiteral(literal, quote);
+}
+
+void ExpressionPrinter::PrintLiteralIndented(const char* info,
+                                      const AstRawString* value, bool quote) {
+  PrintLiteral(value, quote);  
+}
+
+void ExpressionPrinter::PrintLiteralIndented(const char* info,
+                                      const AstConsString* value, bool quote) {
+  PrintLiteral(value, quote);  
+}
+
+void ExpressionPrinter::PrintLiteralWithModeIndented(const char* info, Variable* var,
+                                              const AstRawString* value) {
+  if (var == nullptr) {
+    PrintLiteralIndented(info, value, true);
+  } else {
+    EmbeddedVector<char, 256> buf;
+    PrintLiteralIndented(buf.start(), value, true);
+  }
+}
+
+void ExpressionPrinter::PrintLabelsIndented(ZonePtrList<const AstRawString>* labels,
+                                     const char* prefix) {
+  if (labels == nullptr || labels->length() == 0) return;
+  PrintLabels(labels);
+}
+
+
+void ExpressionPrinter::PrintIndentedVisit(const char* s, AstNode* node) {
+  if (node != nullptr) {
+    Visit(node);
+  }
+}
+
+
+const char* ExpressionPrinter::PrintProgram(FunctionLiteral* program) {
+  Init();
+  { 
+    PrintLiteralIndented("NAME", program->raw_name(), true);
+    if (program->raw_inferred_name()) {
+      PrintLiteralIndented("INFERRED NAME", program->raw_inferred_name(), true);
+    }
+    if (program->requires_instance_fields_initializer()) {
+    }    
+    PrintParameters(program->scope());    
+    PrintDeclarations(program->scope()->declarations());
+    PrintStatements(program->body());
+  }
+  return output_;
+}
+
+
+void ExpressionPrinter::PrintOut(Isolate* isolate, AstNode* node) {
+  ExpressionPrinter printer(isolate->stack_guard()->real_climit());
+  printer.Init();
+  printer.Visit(node);
+  PrintF("%s", printer.output_);
+}
+
+void ExpressionPrinter::PrintDeclarations(Declaration::List* declarations) {
+  if (!declarations->is_empty()) {
+    for (Declaration* decl : *declarations) Visit(decl);
+  }
+}
+
+void ExpressionPrinter::PrintParameters(DeclarationScope* scope) {
+  Print("(");
+  if (scope->num_parameters() > 0) {
+    for (int i = 0; i < scope->num_parameters(); i++) {
+      PrintLiteralWithModeIndented("VAR", scope->parameter(i),
+                                   scope->parameter(i)->raw_name());
+      if(i != scope->num_parameters()-1) {
+        Print(", ");
+      }
+    }
+  }
+  Print(")");
+}
+
+void ExpressionPrinter::PrintStatements(ZonePtrList<Statement>* statements) {
+  Print("{");
+  for (int i = 0; i < statements->length(); i++) {
+    Visit(statements->at(i));
+  }
+  Print("}");
+}
+
+void ExpressionPrinter::PrintArguments(ZonePtrList<Expression>* arguments) {
+  Print("(");
+  for (int i = 0; i < arguments->length(); i++) {
+    Visit(arguments->at(i));
+    if(i!=arguments->length()-1) {
+      Print(", ");
+    }
+  }
+  Print(")");
+}
+
+
+void ExpressionPrinter::VisitBlock(Block* node) {
+  PrintLabelsIndented(node->labels());
+  PrintStatements(node->statements());
+}
+
+
+void ExpressionPrinter::VisitVariableDeclaration(VariableDeclaration* node) {
+  PrintLiteralWithModeIndented("VARIABLE", node->proxy()->var(),
+                               node->proxy()->raw_name());
+}
+
+
+void ExpressionPrinter::VisitFunctionDeclaration(FunctionDeclaration* node) {
+  Print("function ");
+  PrintLiteral(node->proxy()->raw_name(), true);
+  PrintLiteral(node->fun()->raw_name(), false);
+}
+
+
+void ExpressionPrinter::VisitExpressionStatement(ExpressionStatement* node) {
+  Visit(node->expression());
+}
+
+
+void ExpressionPrinter::VisitEmptyStatement(EmptyStatement* node) {
+}
+
+
+void ExpressionPrinter::VisitSloppyBlockFunctionStatement(
+    SloppyBlockFunctionStatement* node) {
+  Visit(node->statement());
+}
+
+
+void ExpressionPrinter::VisitIfStatement(IfStatement* node) {
+  Print("if(");
+  PrintIndentedVisit("CONDITION", node->condition());
+  Print(") {");
+  PrintIndentedVisit("THEN", node->then_statement());
+  Print("}");
+  if (node->HasElseStatement()) {
+    Print(" else {");
+    PrintIndentedVisit("ELSE", node->else_statement());
+    Print("}");
+  }
+}
+
+
+void ExpressionPrinter::VisitContinueStatement(ContinueStatement* node) {
+  Print("continue ");
+  PrintLabelsIndented(node->target()->labels());
+}
+
+
+void ExpressionPrinter::VisitBreakStatement(BreakStatement* node) {
+  Print("break ");
+  PrintLabelsIndented(node->target()->labels());
+}
+
+
+void ExpressionPrinter::VisitReturnStatement(ReturnStatement* node) {
+  Print("return ");
+  Visit(node->expression());
+}
+
+
+void ExpressionPrinter::VisitWithStatement(WithStatement* node) {
+  Print("with(");
+  PrintIndentedVisit("OBJECT", node->expression());
+  Print(") {");
+  PrintIndentedVisit("BODY", node->statement());
+  Print("}");
+}
+
+
+void ExpressionPrinter::VisitSwitchStatement(SwitchStatement* node) {
+  Print("switch (");
+  PrintLabelsIndented(node->labels());
+  PrintIndentedVisit("TAG", node->tag());  
+  Print(") {");
+  for (CaseClause* clause : *node->cases()) {
+    if (clause->is_default()) {
+      Print("default: ");
+      PrintStatements(clause->statements());
+    } else {
+      Print("case ");
+      Visit(clause->label());
+      Print(":");
+      PrintStatements(clause->statements());
+    }
+  }
+  Print("}");
+}
+
+
+void ExpressionPrinter::VisitDoWhileStatement(DoWhileStatement* node) {
+  Print("do {");
+  PrintLabelsIndented(node->labels());
+  PrintLabelsIndented(node->own_labels(), "OWN ");
+  PrintIndentedVisit("BODY", node->body());
+  Print("} while (");
+  PrintIndentedVisit("COND", node->cond());
+  Print(")");
+}
+
+
+void ExpressionPrinter::VisitWhileStatement(WhileStatement* node) {
+  Print("while (");
+  PrintLabelsIndented(node->labels());
+  PrintLabelsIndented(node->own_labels(), "OWN ");
+  PrintIndentedVisit("COND", node->cond());
+  Print(") {");
+  PrintIndentedVisit("BODY", node->body());
+  Print(")");
+}
+
+
+void ExpressionPrinter::VisitForStatement(ForStatement* node) {
+  Print("for (");
+  PrintLabelsIndented(node->labels());
+  PrintLabelsIndented(node->own_labels(), "OWN ");
+  if (node->init()) PrintIndentedVisit("INIT", node->init());
+  Print("; ");
+  if (node->cond()) PrintIndentedVisit("COND", node->cond());
+  Print("; ");
+  if (node->next()) PrintIndentedVisit("NEXT", node->next());
+  Print(") {");
+  PrintIndentedVisit("BODY", node->body());
+  Print("}");
+}
+
+
+void ExpressionPrinter::VisitForInStatement(ForInStatement* node) {
+  Print("for (");
+  PrintLabelsIndented(node->labels());
+  PrintLabelsIndented(node->own_labels(), "OWN ");
+  PrintIndentedVisit("FOR", node->each());
+  Print(" in ");
+  PrintIndentedVisit("IN", node->enumerable());
+  Print(") {");
+  PrintIndentedVisit("BODY", node->body());
+  Print("}");
+}
+
+
+void ExpressionPrinter::VisitForOfStatement(ForOfStatement* node) {
+  Print("for (");
+  PrintLabelsIndented(node->labels());
+  PrintLabelsIndented(node->own_labels(), "OWN ");
+  PrintIndentedVisit("INIT", node->assign_iterator());
+  Print(" of ");
+  PrintIndentedVisit("NEXT", node->next_result());
+  PrintIndentedVisit("DONE", node->result_done());
+  PrintIndentedVisit("EACH", node->assign_each());
+  Print(" ) {");
+  PrintIndentedVisit("BODY", node->body());
+  Print("}");
+}
+
+
+void ExpressionPrinter::VisitTryCatchStatement(TryCatchStatement* node) {
+  Print("try {");
+  PrintIndentedVisit("TRY", node->try_block());
+  Print(" } catch (");
+  const char* prediction = "";
+  switch (node->GetCatchPrediction(HandlerTable::UNCAUGHT)) {
+    case HandlerTable::UNCAUGHT:
+      prediction = "UNCAUGHT";
+      break;
+    case HandlerTable::CAUGHT:
+      prediction = "CAUGHT";
+      break;
+    case HandlerTable::DESUGARING:
+      prediction = "DESUGARING";
+      break;
+    case HandlerTable::ASYNC_AWAIT:
+      prediction = "ASYNC_AWAIT";
+      break;
+    case HandlerTable::PROMISE:
+      // Catch prediction resulting in promise rejections aren't
+      // parsed by the parser.
+      UNREACHABLE();
+  }
+  if (node->scope()) {
+    PrintLiteralWithModeIndented("CATCHVAR", node->scope()->catch_variable(),
+                                 node->scope()->catch_variable()->raw_name());
+  }
+  Print(") {");
+  PrintIndentedVisit("CATCH", node->catch_block());
+  Print(")");
+}
+
+void ExpressionPrinter::VisitTryFinallyStatement(TryFinallyStatement* node) {
+  Print("try {");
+  PrintIndentedVisit("TRY", node->try_block());
+  Print(" } finally {");
+  PrintIndentedVisit("FINALLY", node->finally_block());
+  Print(" }");
+}
+
+void ExpressionPrinter::VisitDebuggerStatement(DebuggerStatement* node) {
+}
+
+
+void ExpressionPrinter::VisitFunctionLiteral(FunctionLiteral* node) {
+  Print("function ");
+  PrintLiteralIndented("NAME", node->raw_name(), false);
+  PrintParameters(node->scope());
+  Print("{}");
+  // We don't want to see the function literal in this case: it
+  // will be printed via PrintProgram when the code for it is
+  // generated.
+}
+
+
+void ExpressionPrinter::VisitClassLiteral(ClassLiteral* node) {
+  Print("class ");
+  PrintLiteralIndented("NAME", node->constructor()->raw_name(), false);
+  if (node->extends() != nullptr) {
+    Print(" extends "); 
+    PrintIndentedVisit("EXTENDS", node->extends());
+  }
+
+  Print(" {");
+  if (node->static_fields_initializer() != nullptr) {
+    Print("static ");
+    PrintIndentedVisit("STATIC FIELDS INITIALIZER",
+                       node->static_fields_initializer());
+  }
+  if (node->instance_fields_initializer_function() != nullptr) {
+    PrintIndentedVisit("INSTANCE FIELDS INITIALIZER",
+                       node->instance_fields_initializer_function());
+  }
+  PrintClassProperties(node->properties());
+  Print("}");
+}
+
+void ExpressionPrinter::VisitInitializeClassFieldsStatement(
+    InitializeClassFieldsStatement* node) {
+  PrintClassProperties(node->fields());
+}
+
+void ExpressionPrinter::PrintClassProperties(
+    ZonePtrList<ClassLiteral::Property>* properties) {
+
+  for (int i = 0; i < properties->length(); i++) {
+    ClassLiteral::Property* property = properties->at(i);
+    switch (property->kind()) {
+      case ClassLiteral::Property::METHOD:
+        //prop_kind = "METHOD";
+        break;
+      case ClassLiteral::Property::GETTER:
+        //prop_kind = "GETTER";
+        break;
+      case ClassLiteral::Property::SETTER:
+        //prop_kind = "SETTER";
+        break;
+      case ClassLiteral::Property::PUBLIC_FIELD:
+        //prop_kind = "PUBLIC FIELD";
+        break;
+      case ClassLiteral::Property::PRIVATE_FIELD:
+        //prop_kind = "PRIVATE FIELD";
+        break;
+    }
+    EmbeddedVector<char, 128> buf;
+    PrintIndentedVisit("KEY", properties->at(i)->key());
+    Print(": ");
+    PrintIndentedVisit("VALUE", properties->at(i)->value());
+    if(i!=properties->length()-1)
+      Print(", ");
+  }
+  Print("}");
+}
+
+
+void ExpressionPrinter::VisitNativeFunctionLiteral(NativeFunctionLiteral* node) {
+  PrintLiteralIndented("NAME", node->raw_name(), false);
+  Print("()");
+}
+
+
+void ExpressionPrinter::VisitDoExpression(DoExpression* node) {
+  Print("do {");
+  PrintStatements(node->block()->statements());
+  Print("}");
+}
+
+
+void ExpressionPrinter::VisitConditional(Conditional* node) {
+  Print("if (");
+  PrintIndentedVisit("CONDITION", node->condition());
+  Print(") {");
+  PrintIndentedVisit("THEN", node->then_expression());
+  Print("} else {");
+  PrintIndentedVisit("ELSE", node->else_expression());
+  Print("}");
+}
+
+
+void ExpressionPrinter::VisitLiteral(Literal* node) {
+  PrintLiteralIndented("LITERAL", node, true);
+}
+
+
+void ExpressionPrinter::VisitRegExpLiteral(RegExpLiteral* node) {
+  PrintLiteralIndented("PATTERN", node->raw_pattern(), false);
+  int i = 0;
+  EmbeddedVector<char, 128> buf;
+  if (node->flags() & RegExp::kGlobal) buf[i++] = 'g';
+  if (node->flags() & RegExp::kIgnoreCase) buf[i++] = 'i';
+  if (node->flags() & RegExp::kMultiline) buf[i++] = 'm';
+  if (node->flags() & RegExp::kUnicode) buf[i++] = 'u';
+  if (node->flags() & RegExp::kSticky) buf[i++] = 'y';
+  buf[i] = '\0';
+  Print("%s", buf.start());
+}
+
+
+void ExpressionPrinter::VisitObjectLiteral(ObjectLiteral* node) {
+  if(node->has_print_name())
+    PrintLiteral(node->print_name(), false);
+  else {
+    Print("{");
+    PrintObjectProperties(node->properties());
+    Print("}");
+  }
+}
+
+void ExpressionPrinter::PrintObjectProperties(
+    ZonePtrList<ObjectLiteral::Property>* properties) {
+  for (int i = 0; i < properties->length(); i++) {
+    ObjectLiteral::Property* property = properties->at(i);
+    //const char* prop_kind = nullptr;
+    switch (property->kind()) {
+      case ObjectLiteral::Property::CONSTANT:
+        //prop_kind = "CONSTANT";
+        break;
+      case ObjectLiteral::Property::COMPUTED:
+        //prop_kind = "COMPUTED";
+        break;
+      case ObjectLiteral::Property::MATERIALIZED_LITERAL:
+        //prop_kind = "MATERIALIZED_LITERAL";
+        break;
+      case ObjectLiteral::Property::PROTOTYPE:
+        //prop_kind = "PROTOTYPE";
+        break;
+      case ObjectLiteral::Property::GETTER:
+        //prop_kind = "GETTER";
+        break;
+      case ObjectLiteral::Property::SETTER:
+        //prop_kind = "SETTER";
+        break;
+      case ObjectLiteral::Property::SPREAD:
+        //prop_kind = "SPREAD";
+        break;
+    }
+    EmbeddedVector<char, 128> buf;
+    PrintIndentedVisit("KEY", properties->at(i)->key());
+    Print(": ");
+    PrintIndentedVisit("VALUE", properties->at(i)->value());
+    if(i!=properties->length()-1) {
+      Print(", ");
+    }
+  }
+}
+
+
+void ExpressionPrinter::VisitArrayLiteral(ArrayLiteral* node) {
+  Print("[");
+  if (node->values()->length() > 0) {
+    for (int i = 0; i < node->values()->length(); i++) {
+      Visit(node->values()->at(i));
+      if(i!=node->values()->length()-1) {
+        Print(", ");
+      }
+    }
+  }
+  Print("]");
+}
+
+
+void ExpressionPrinter::VisitVariableProxy(VariableProxy* node) {
+  EmbeddedVector<char, 128> buf;
+  if (!node->is_resolved()) {
+    PrintLiteralWithModeIndented(buf.start(), nullptr, node->raw_name());
+  } else {
+    Variable* var = node->var();
+    switch (var->location()) {
+      case VariableLocation::UNALLOCATED:
+        ///SNPrintF(buf + pos, " unallocated");
+        break;
+      case VariableLocation::PARAMETER:
+        ///SNPrintF(buf + pos, " parameter[%d]", var->index());
+        break;
+      case VariableLocation::LOCAL:
+        ///SNPrintF(buf + pos, " local[%d]", var->index());
+        break;
+      case VariableLocation::CONTEXT:
+        ///SNPrintF(buf + pos, " context[%d]", var->index());
+        break;
+      case VariableLocation::LOOKUP:
+        ///SNPrintF(buf + pos, " lookup");
+        break;
+      case VariableLocation::MODULE:
+        ///SNPrintF(buf + pos, " module");
+        break;
+    }
+    PrintLiteralWithModeIndented(buf.start(), var, node->raw_name());
+  }
+}
+
+
+void ExpressionPrinter::VisitAssignment(Assignment* node) {
+  Visit(node->target());
+  if(!node->IsCompoundAssignment() || node->AsCompoundAssignment()->force_to_asg()) {
+    Print("=");
+  }
+  else {
+    Print("%s", Token::String(node->AsCompoundAssignment()->binary_operation()->op()));
+    Print("=");
+  }
+
+  Visit(node->value());
+}
+
+void ExpressionPrinter::VisitCompoundAssignment(CompoundAssignment* node) {
+  VisitAssignment(node);
+}
+
+void ExpressionPrinter::VisitYield(Yield* node) {
+  EmbeddedVector<char, 128> buf;
+  Print("yield ");
+  Visit(node->expression());
+}
+
+void ExpressionPrinter::VisitYieldStar(YieldStar* node) {
+  EmbeddedVector<char, 128> buf;
+  Print("yield* ");
+  Visit(node->expression());
+}
+
+void ExpressionPrinter::VisitAwait(Await* node) {
+  EmbeddedVector<char, 128> buf;
+  Print("await ");
+  Visit(node->expression());
+}
+
+void ExpressionPrinter::VisitThrow(Throw* node) {
+  Print("throw ");
+  Visit(node->exception());
+}
+
+void ExpressionPrinter::VisitProperty(Property* node) {
+  EmbeddedVector<char, 128> buf;
+
+  Visit(node->obj());
+  LhsKind property_kind = Property::GetAssignType(node);
+  if (property_kind == NAMED_PROPERTY ||
+      property_kind == NAMED_SUPER_PROPERTY) {
+    Print(".");
+    PrintLiteralIndented("NAME", node->key()->AsLiteral(), false);
+  } else {
+    DCHECK(property_kind == KEYED_PROPERTY ||
+           property_kind == KEYED_SUPER_PROPERTY);
+    Print("[");
+    PrintIndentedVisit("KEY", node->key());
+    Print("]");
+  }
+}
+
+void ExpressionPrinter::VisitResolvedProperty(ResolvedProperty* node) {
+  EmbeddedVector<char, 128> buf;
+
+  PrintIndentedVisit("RECEIVER", node->object());
+  Print(".");
+  PrintIndentedVisit("PROPERTY", node->property());
+}
+
+void ExpressionPrinter::VisitCall(Call* node) {
+  EmbeddedVector<char, 128> buf;
+  Visit(node->expression());
+  PrintArguments(node->arguments());
+}
+
+
+void ExpressionPrinter::VisitCallNew(CallNew* node) {
+  Print("new ");
+  Visit(node->expression());
+  PrintArguments(node->arguments());
+}
+
+
+void ExpressionPrinter::VisitCallRuntime(CallRuntime* node) {
+  EmbeddedVector<char, 128> buf;
+  Print("%s", node->debug_name());
+  PrintArguments(node->arguments());
+}
+
+
+void ExpressionPrinter::VisitUnaryOperation(UnaryOperation* node) {
+  Print("%s", Token::String(node->op()));
+  Print("(");
+  Visit(node->expression());
+  Print(")");
+}
+
+
+void ExpressionPrinter::VisitCountOperation(CountOperation* node) {
+  EmbeddedVector<char, 128> buf;
+  if(node->is_prefix()) {
+    Print("%s", Token::String(node->op()));
+  }
+  Visit(node->expression());
+  if(!node->is_prefix()) {
+    Print("%s", Token::String(node->op()));
+  }
+}
+
+
+void ExpressionPrinter::VisitBinaryOperation(BinaryOperation* node) {
+  Visit(node->left());
+  Print("%s", Token::String(node->op()));
+  Visit(node->right());
+}
+
+void ExpressionPrinter::VisitNaryOperation(NaryOperation* node) {
+  Visit(node->first());
+  Print(" ");
+  Print("%s", Token::String(node->op()));
+  for (size_t i = 0; i < node->subsequent_length(); ++i) {
+    Visit(node->subsequent(i));
+    if(i!=node->subsequent_length()-1) {
+      Print(" ");
+      Print("%s", Token::String(node->op()));
+    }
+  }
+}
+
+void ExpressionPrinter::VisitCompareOperation(CompareOperation* node) {
+  Visit(node->left());
+  Print("%s", Token::String(node->op()));
+  Visit(node->right());
+}
+
+
+void ExpressionPrinter::VisitSpread(Spread* node) {
+  Visit(node->expression());
+}
+
+void ExpressionPrinter::VisitStoreInArrayLiteral(StoreInArrayLiteral* node) {
+  PrintIndentedVisit("ARRAY", node->array());
+  Print("[");
+  PrintIndentedVisit("INDEX", node->index());
+  Print("] = ");
+  PrintIndentedVisit("VALUE", node->value());
+}
+
+void ExpressionPrinter::VisitEmptyParentheses(EmptyParentheses* node) {
+}
+
+void ExpressionPrinter::VisitGetIterator(GetIterator* node) {
+  Visit(node->iterable());
+}
+
+void ExpressionPrinter::VisitGetTemplateObject(GetTemplateObject* node) {
+}
+
+void ExpressionPrinter::VisitTemplateLiteral(TemplateLiteral* node) {
+  Print("template ");
+  const AstRawString* string = node->string_parts()->first();
+  if (!string->IsEmpty()) PrintLiteralIndented("SPAN", string, true);
+  for (int i = 0; i < node->substitutions()->length();) {
+    PrintIndentedVisit("EXPR", node->substitutions()->at(i++));
+    if (i < node->string_parts()->length()) {
+      string = node->string_parts()->at(i);
+      if (!string->IsEmpty()) PrintLiteralIndented("SPAN", string, true);
+    }
+  }
+}
+
+void ExpressionPrinter::VisitImportCallExpression(ImportCallExpression* node) {
+  Visit(node->argument());
+}
+
+void ExpressionPrinter::VisitThisFunction(ThisFunction* node) {
+}
+
+
+void ExpressionPrinter::VisitSuperPropertyReference(SuperPropertyReference* node) {
+  Print("super ");
+}
+
+
+void ExpressionPrinter::VisitSuperCallReference(SuperCallReference* node) {
+  Print("super ");
+}
+
+
+void ExpressionPrinter::VisitRewritableExpression(RewritableExpression* node) {
+  Visit(node->expression());
+}
+
+
+}  // namespace internal
+}  // namespace v8
diff --git a/src/parsing/expression-printer.h b/src/parsing/expression-printer.h
new file mode 100644
index 0000000..6bc8751
--- /dev/null
+++ b/src/parsing/expression-printer.h
@@ -0,0 +1,88 @@
+// Copyright 2012 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_EXPRESSION_PRINTER_H_
+#define V8_EXPRESSION_PRINTER_H_
+
+#include "src/allocation.h"
+#include "src/ast/ast.h"
+#include "src/base/compiler-specific.h"
+#include "src/unoptimized-compilation-info.h"
+
+namespace v8 {
+namespace internal {
+
+
+class ExpressionPrinter final : public AstVisitor<ExpressionPrinter> {
+ public:
+  explicit ExpressionPrinter(uintptr_t stack_limit);
+  ~ExpressionPrinter();
+
+  // The following routines print a node into a string.
+  // The result string is alive as long as the AstPrinter is alive.
+  const char* Print(AstNode* node);
+  const char* PrintProgram(FunctionLiteral* program);
+
+  void PRINTF_FORMAT(2, 3) Print(const char* format, ...);
+
+  // Print a node to stdout.
+  static void PrintOut(Isolate* isolate, AstNode* node);
+
+  // Individual nodes
+#define DECLARE_VISIT(type) void Visit##type(type* node);
+  AST_NODE_LIST(DECLARE_VISIT)
+#undef DECLARE_VISIT
+
+ private:
+  friend class IndentedScope;
+
+  void Init();
+
+  void PrintLabels(ZonePtrList<const AstRawString>* labels);
+  void PrintLiteral(const AstRawString* value, bool quote);
+  void PrintLiteral(const AstConsString* value, bool quote);
+  void PrintLiteral(Literal* literal, bool quote);
+  void PrintIndented(const char* txt);
+  void PrintIndentedVisit(const char* s, AstNode* node);
+
+  void PrintStatements(ZonePtrList<Statement>* statements);
+  void PrintDeclarations(Declaration::List* declarations);
+  void PrintParameters(DeclarationScope* scope);
+  void PrintArguments(ZonePtrList<Expression>* arguments);
+  void PrintCaseClause(CaseClause* clause);
+  void PrintLiteralIndented(const char* info, Literal* literal, bool quote);
+  void PrintLiteralIndented(const char* info, const AstRawString* value,
+                            bool quote);
+  void PrintLiteralIndented(const char* info, const AstConsString* value,
+                            bool quote);
+  void PrintLiteralWithModeIndented(const char* info, Variable* var,
+                                    const AstRawString* value);
+  void PrintLabelsIndented(ZonePtrList<const AstRawString>* labels,
+                           const char* prefix = "");
+  void PrintObjectProperties(ZonePtrList<ObjectLiteral::Property>* properties);
+  void PrintClassProperties(ZonePtrList<ClassLiteral::Property>* properties);
+  
+  
+  std::string GetFullString(Expression* expr, Scope* scope, ParseInfo* info);
+  std::string CheckDeclarationsInCurrentScope(ParseInfo* parse_info, Expression* expr, int asg_pos, bool *already_found);
+  std::string TraverseDeclarationsInOuterScopes(Scope* scope, ParseInfo* info, Expression* expr, bool* already_found);
+  std::string ConvertIdentifierToString(const AstRawString* identifier);
+
+  
+  void inc_indent() { indent_++; }
+  void dec_indent() { indent_--; }
+
+  DEFINE_AST_VISITOR_SUBCLASS_MEMBERS();
+
+  char* output_;  // output string buffer
+  int size_;      // output_ size
+  int pos_;       // current printing position
+  int indent_;
+};
+
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_EXPRESSION_PRINTER_H_
diff --git a/src/parsing/global_maps.cc b/src/parsing/global_maps.cc
new file mode 100644
index 0000000..d27e964
--- /dev/null
+++ b/src/parsing/global_maps.cc
@@ -0,0 +1,15 @@
+#include "src/parsing/global_maps.h"
+
+namespace v8 {
+namespace internal {
+
+std::mutex mutex;
+int functionID = 0;
+
+std::map<int, std::vector<std::string>> unbound_functions;
+std::vector<std::string> declared_functions;
+std::map<std::tuple<int, int>, int> function_id_alias; 
+
+std::list<int> script_ids;
+}  // namespace internal
+}  // namespace v8
diff --git a/src/parsing/global_maps.h b/src/parsing/global_maps.h
new file mode 100644
index 0000000..8d05c83
--- /dev/null
+++ b/src/parsing/global_maps.h
@@ -0,0 +1,27 @@
+#ifndef V8_PARSING_GLOBAL_MAPS_H_
+#define V8_PARSING_GLOBAL_MAPS_H_
+
+
+#include <map>
+#include <vector>
+#include <tuple>
+#include <mutex>
+#include <list>
+//#include <atomic>
+//#include "src/parsing/parse-info.h"
+
+
+namespace v8 {
+namespace internal {
+extern std::mutex mutex;
+extern int functionID;
+
+extern std::map<int, std::vector<std::string>> unbound_functions;
+extern std::vector<std::string> declared_functions;
+extern std::map<std::tuple<int, int>, int> function_id_alias; // (scriptID, function_token_pos) -> functionID
+
+extern std::list<int> script_ids;
+}// namespace internal
+}  // namespace v8
+
+#endif  // V8_PARSING_GLOBAL_MAPS_H_
diff --git a/src/parsing/parse-info.cc b/src/parsing/parse-info.cc
index 129b00a..ce80d25 100644
--- a/src/parsing/parse-info.cc
+++ b/src/parsing/parse-info.cc
@@ -16,7 +16,7 @@
 namespace v8 {
 namespace internal {
 
-ParseInfo::ParseInfo(AccountingAllocator* zone_allocator)
+ParseInfo::ParseInfo(AccountingAllocator* zone_allocator, bool flag)
     : zone_(base::make_unique<Zone>(zone_allocator, ZONE_NAME)),
       flags_(0),
       extension_(nullptr),
@@ -37,10 +37,21 @@ ParseInfo::ParseInfo(AccountingAllocator* zone_allocator)
       function_name_(nullptr),
       runtime_call_stats_(nullptr),
       source_range_map_(nullptr),
-      literal_(nullptr) {}
-
-ParseInfo::ParseInfo(Isolate* isolate, AccountingAllocator* zone_allocator)
-    : ParseInfo(zone_allocator) {
+      literal_(nullptr) {
+        declared_vars_.clear(); 
+        func_params_.clear(); 
+        v8::Isolate* isolate = v8::Isolate::GetCurrent();
+        if(isolate!=nullptr && flag) {
+          i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);
+          context_id_ = i_isolate->native_context()->debug_context_id();
+        }
+        else {
+          context_id_ = nullptr;
+        }
+      }
+
+ParseInfo::ParseInfo(Isolate* isolate, AccountingAllocator* zone_allocator, bool flag)
+    : ParseInfo(zone_allocator, flag) {
   set_hash_seed(isolate->heap()->HashSeed());
   set_stack_limit(isolate->stack_guard()->real_climit());
   set_unicode_cache(isolate->unicode_cache());
@@ -49,11 +60,14 @@ ParseInfo::ParseInfo(Isolate* isolate, AccountingAllocator* zone_allocator)
   set_ast_string_constants(isolate->ast_string_constants());
   if (isolate->is_block_code_coverage()) set_block_coverage_enabled();
   if (isolate->is_collecting_type_profile()) set_collect_type_profile();
+
+  set_isolate(isolate);
 }
 
-ParseInfo::ParseInfo(Isolate* isolate)
-    : ParseInfo(isolate, isolate->allocator()) {
+ParseInfo::ParseInfo(Isolate* isolate, bool flag)
+    : ParseInfo(isolate, isolate->allocator(), flag) {
   script_id_ = isolate->heap()->NextScriptId();
+  set_isolate(isolate);
   LOG(isolate, ScriptEvent(Logger::ScriptEventType::kReserveId, script_id_));
 }
 
@@ -69,8 +83,8 @@ void ParseInfo::SetFunctionInfo(T function) {
   set_wrapped_as_function(function->is_wrapped());
 }
 
-ParseInfo::ParseInfo(Isolate* isolate, Handle<SharedFunctionInfo> shared)
-    : ParseInfo(isolate, isolate->allocator()) {
+ParseInfo::ParseInfo(Isolate* isolate, Handle<SharedFunctionInfo> shared, bool flag)
+    : ParseInfo(isolate, isolate->allocator(), flag) {
   // Do not support re-parsing top-level function of a wrapped script.
   // TODO(yangguo): consider whether we need a top-level function in a
   //                wrapped script at all.
@@ -87,6 +101,7 @@ ParseInfo::ParseInfo(Isolate* isolate, Handle<SharedFunctionInfo> shared)
   Handle<Script> script(Script::cast(shared->script()), isolate);
   set_script(script);
 
+  set_isolate(isolate);
   if (shared->HasOuterScopeInfo()) {
     set_outer_scope_info(handle(shared->GetOuterScopeInfo(), isolate));
   }
@@ -101,11 +116,13 @@ ParseInfo::ParseInfo(Isolate* isolate, Handle<SharedFunctionInfo> shared)
            : script->IsUserJavaScript()));
 }
 
-ParseInfo::ParseInfo(Isolate* isolate, Handle<Script> script)
-    : ParseInfo(isolate, isolate->allocator()) {
+ParseInfo::ParseInfo(Isolate* isolate, Handle<Script> script, bool flag)
+    : ParseInfo(isolate, isolate->allocator(), flag) {
   SetScriptForToplevelCompile(isolate, script);
   set_collect_type_profile(isolate->is_collecting_type_profile() &&
                            script->IsUserJavaScript());
+
+  set_isolate(isolate);
 }
 
 // static
@@ -202,6 +219,7 @@ void ParseInfo::set_character_stream(
 
 void ParseInfo::SetScriptForToplevelCompile(Isolate* isolate,
                                             Handle<Script> script) {
+
   set_script(script);
   set_allow_lazy_parsing();
   set_toplevel();
diff --git a/src/parsing/parse-info.h b/src/parsing/parse-info.h
index ba3e3d2..0b85227 100644
--- a/src/parsing/parse-info.h
+++ b/src/parsing/parse-info.h
@@ -9,6 +9,10 @@
 #include <memory>
 #include <vector>
 
+#include <string>
+#include <sstream>
+#include <iostream>
+
 #include "include/v8.h"
 #include "src/globals.h"
 #include "src/handles.h"
@@ -38,11 +42,11 @@ class Zone;
 // A container for the inputs, configuration options, and outputs of parsing.
 class V8_EXPORT_PRIVATE ParseInfo {
  public:
-  explicit ParseInfo(AccountingAllocator* zone_allocator);
-  explicit ParseInfo(Isolate*);
-  ParseInfo(Isolate*, AccountingAllocator* zone_allocator);
-  ParseInfo(Isolate* isolate, Handle<Script> script);
-  ParseInfo(Isolate* isolate, Handle<SharedFunctionInfo> shared);
+  explicit ParseInfo(AccountingAllocator* zone_allocator, bool flag=true);
+  explicit ParseInfo(Isolate*, bool flag=true);
+  ParseInfo(Isolate*, AccountingAllocator* zone_allocator, bool flag=true);
+  ParseInfo(Isolate* isolate, Handle<Script> script, bool flag=true);
+  ParseInfo(Isolate* isolate, Handle<SharedFunctionInfo> shared, bool flag=true);
 
   // Creates a new parse info based on parent top-level |outer_parse_info| for
   // function |literal|.
@@ -219,6 +223,14 @@ class V8_EXPORT_PRIVATE ParseInfo {
   }
 
   int script_id() const { return script_id_; }
+  std::string script_url() const {return script_url_;}
+  void set_script_url(std::string str) {script_url_ = str;}
+  void set_is_this(bool is_this) {is_this_ = is_this;}
+  bool is_this() {return is_this_;}
+  Isolate* get_isolate() {return isolate_;}
+  void set_isolate(Isolate* isolate) {isolate_ = isolate;}
+  void set_context_id(Object* id) {context_id_ = id;}
+  Object* context_id() {return context_id_;}
   //--------------------------------------------------------------------------
 
   LanguageMode language_mode() const {
@@ -229,6 +241,18 @@ class V8_EXPORT_PRIVATE ParseInfo {
     set_strict_mode(is_strict(language_mode));
   }
 
+
+  // log the declarations as expressions in the parseInfo, because
+  // during parsing, the scope has not been assigned yet
+  // the scope is set after finishing the parsing and after set_literal(parse_result) 
+  std::list<Expression*> declared_vars() {return declared_vars_;}
+  void appendDeclaration(Expression* expr) {    
+    declared_vars_.push_back(expr);
+  }
+  void clear_declared_vars() {declared_vars_.clear();}
+  std::map<DeclarationScope*, std::vector<std::pair<Expression*, Expression*>>> func_params() {return func_params_;}
+  void append_func_param(DeclarationScope* scope, Expression* param, Expression* init) {func_params_[scope].push_back(std::pair<Expression*, Expression*>(param, init));}
+
  private:
   void SetScriptForToplevelCompile(Isolate* isolate, Handle<Script> script);
 
@@ -270,11 +294,14 @@ class V8_EXPORT_PRIVATE ParseInfo {
   uint64_t hash_seed_;
   FunctionKind function_kind_;
   int script_id_;
+  std::string script_url_;
+  bool is_this_;
   int start_position_;
   int end_position_;
   int parameters_end_pos_;
   int function_literal_id_;
   int max_function_literal_id_;
+  Object* context_id_;
 
   // TODO(titzer): Move handles out of ParseInfo.
   Handle<Script> script_;
@@ -294,9 +321,16 @@ class V8_EXPORT_PRIVATE ParseInfo {
   FunctionLiteral* literal_;
   PendingCompilationErrorHandler pending_error_handler_;
 
+
+  Isolate* isolate_;
+
   void SetFlag(Flag f) { flags_ |= f; }
   void SetFlag(Flag f, bool v) { flags_ = v ? flags_ | f : flags_ & ~f; }
   bool GetFlag(Flag f) const { return (flags_ & f) != 0; }
+
+
+  std::list<Expression*> declared_vars_;
+  std::map<DeclarationScope*, std::vector<std::pair<Expression*, Expression*>>> func_params_;
 };
 
 }  // namespace internal
diff --git a/src/parsing/parser-base.h b/src/parsing/parser-base.h
index d1ad0e9..0a299a6 100644
--- a/src/parsing/parser-base.h
+++ b/src/parsing/parser-base.h
@@ -4,9 +4,10 @@
 
 #ifndef V8_PARSING_PARSER_BASE_H_
 #define V8_PARSING_PARSER_BASE_H_
-
+#include <iostream>
 #include <stdint.h>
 #include <vector>
+#include <string.h>
 
 #include "src/ast/ast-source-ranges.h"
 #include "src/ast/ast.h"
@@ -25,6 +26,11 @@
 #include "src/parsing/token.h"
 #include "src/zone/zone-chunk-list.h"
 
+#include "src/objects/scope-info.h"
+
+
+#include "src/parsing/expression-printer.h"
+
 namespace v8 {
 namespace internal {
 
@@ -1078,12 +1084,12 @@ class ParserBase {
 
   ExpressionT ParseRegExpLiteral(bool* ok);
 
-  ExpressionT ParseBindingPattern(bool* ok);
-  ExpressionT ParsePrimaryExpression(bool* is_async, bool* ok);
+  ExpressionT ParseBindingPattern(ParseInfo* info, bool* ok);
+  ExpressionT ParsePrimaryExpression(ParseInfo* info, bool* is_async, bool* ok);
 
   // Use when parsing an expression that is known to not be a pattern or part
   // of a pattern.
-  V8_INLINE ExpressionT ParseExpression(bool* ok);
+  V8_INLINE ExpressionT ParseExpression(ParseInfo* info, bool* ok);
 
   // This method does not wrap the parsing of the expression inside a
   // new expression classifier; it uses the top-level classifier instead.
@@ -1092,9 +1098,9 @@ class ParserBase {
   // corresponds to what's inside the parentheses generated by the symbol
   // "CoverParenthesizedExpressionAndArrowParameterList" in the ES 2017
   // specification).
-  ExpressionT ParseExpressionCoverGrammar(bool accept_IN, bool* ok);
+  ExpressionT ParseExpressionCoverGrammar(ParseInfo* info, bool accept_IN, bool* ok);
 
-  ExpressionT ParseArrayLiteral(bool* ok);
+  ExpressionT ParseArrayLiteral(ParseInfo* info, bool* ok);
 
   inline static bool IsAccessor(ParsePropertyKind kind) {
     return IsInRange(kind, ParsePropertyKind::kAccessorGetter,
@@ -1114,70 +1120,71 @@ class ParserBase {
   ObjectLiteralPropertyT ParseObjectPropertyDefinition(
       ObjectLiteralChecker* checker, bool* is_computed_name,
       bool* is_rest_property, bool* ok);
-  ExpressionListT ParseArguments(Scanner::Location* first_spread_pos,
+  ExpressionListT ParseArguments(ParseInfo* info, Scanner::Location* first_spread_pos,
                                  bool maybe_arrow,
                                  bool* is_simple_parameter_list, bool* ok);
-  ExpressionListT ParseArguments(Scanner::Location* first_spread_pos,
+  ExpressionListT ParseArguments(ParseInfo* info, Scanner::Location* first_spread_pos,
                                  bool* ok) {
     bool is_simple = true;
-    return ParseArguments(first_spread_pos, false, &is_simple, ok);
+    return ParseArguments(info, first_spread_pos, false, &is_simple, ok);
   }
 
-  ExpressionT ParseAssignmentExpression(bool accept_IN, bool* ok);
-  ExpressionT ParseYieldExpression(bool accept_IN, bool* ok);
-  V8_INLINE ExpressionT ParseConditionalExpression(bool accept_IN, bool* ok);
-  ExpressionT ParseConditionalContinuation(ExpressionT expression,
+  ExpressionT ParseAssignmentExpression(ParseInfo* info, bool accept_IN, bool* ok);
+  ExpressionT ParseYieldExpression(ParseInfo* info, bool accept_IN, bool* ok);
+  V8_INLINE ExpressionT ParseConditionalExpression(ParseInfo* info, bool accept_IN, bool* ok);
+  ExpressionT ParseConditionalContinuation(ParseInfo* info, ExpressionT expression,
                                            bool accept_IN, int pos, bool* ok);
-  ExpressionT ParseBinaryExpression(int prec, bool accept_IN, bool* ok);
-  ExpressionT ParseUnaryOpExpression(bool* ok);
-  ExpressionT ParseAwaitExpression(bool* ok);
-  ExpressionT ParsePrefixExpression(bool* ok);
-  V8_INLINE ExpressionT ParseUnaryExpression(bool* ok);
-  V8_INLINE ExpressionT ParsePostfixExpression(bool* ok);
-  V8_INLINE ExpressionT ParseLeftHandSideExpression(bool* ok);
-  ExpressionT ParseMemberWithPresentNewPrefixesExpression(bool* is_async,
+  ExpressionT ParseBinaryExpression(ParseInfo* info, int prec, bool accept_IN, bool* ok);
+  ExpressionT ParseUnaryOpExpression(ParseInfo* info, bool* ok);
+  ExpressionT ParseAwaitExpression(ParseInfo* info, bool* ok);
+  ExpressionT ParsePrefixExpression(ParseInfo* info, bool* ok);
+  V8_INLINE ExpressionT ParseUnaryExpression(ParseInfo* info, bool* ok);
+  V8_INLINE ExpressionT ParsePostfixExpression(ParseInfo* info, bool* ok);
+  V8_INLINE ExpressionT ParseLeftHandSideExpression(ParseInfo* info, bool* ok);
+  ExpressionT ParseMemberWithPresentNewPrefixesExpression(ParseInfo* info, bool* is_async,
                                                           bool* ok);
-  V8_INLINE ExpressionT ParseMemberWithNewPrefixesExpression(bool* is_async,
+  V8_INLINE ExpressionT ParseMemberWithNewPrefixesExpression(ParseInfo* info, bool* is_async,
                                                              bool* ok);
-  V8_INLINE ExpressionT ParseMemberExpression(bool* is_async, bool* ok);
+  V8_INLINE ExpressionT ParseMemberExpression(ParseInfo* info, bool* is_async, bool* ok);
   V8_INLINE ExpressionT ParseMemberExpressionContinuation(
-      ExpressionT expression, bool* is_async, bool* ok);
+      ParseInfo* info, bool is_this, ExpressionT expression, bool* is_async, bool* ok);
 
   // `rewritable_length`: length of the destructuring_assignments_to_rewrite()
   // queue in the parent function state, prior to parsing of formal parameters.
   // If the arrow function is lazy, any items added during formal parameter
   // parsing are removed from the queue.
-  ExpressionT ParseArrowFunctionLiteral(bool accept_IN,
+  ExpressionT ParseArrowFunctionLiteral(ParseInfo* info, bool accept_IN,
                                         const FormalParametersT& parameters,
                                         int rewritable_length, bool* ok);
-  void ParseAsyncFunctionBody(Scope* scope, StatementListT body, bool* ok);
-  ExpressionT ParseAsyncFunctionLiteral(bool* ok);
+  void ParseAsyncFunctionBody(ParseInfo* info, Scope* scope, StatementListT body, bool* ok);
+  ExpressionT ParseAsyncFunctionLiteral(ParseInfo* info, bool* ok);
   ExpressionT ParseClassLiteral(IdentifierT name,
                                 Scanner::Location class_name_location,
                                 bool name_is_strict_reserved,
                                 int class_token_pos, bool* ok);
-  ExpressionT ParseTemplateLiteral(ExpressionT tag, int start, bool tagged,
+  ExpressionT ParseTemplateLiteral(ParseInfo* info, ExpressionT tag, int start, bool tagged,
                                    bool* ok);
   ExpressionT ParseSuperExpression(bool is_new, bool* ok);
   ExpressionT ParseImportExpressions(bool* ok);
   ExpressionT ParseNewTargetExpression(bool* ok);
 
-  V8_INLINE void ParseFormalParameter(FormalParametersT* parameters, bool* ok);
-  void ParseFormalParameterList(FormalParametersT* parameters, bool* ok);
+  V8_INLINE void ParseFormalParameter(ParseInfo* info, FormalParametersT* parameters, bool* ok);
+  void ParseFormalParameterList(ParseInfo* info, FormalParametersT* parameters, bool* ok);
+
   void CheckArityRestrictions(int param_count, FunctionKind function_type,
                               bool has_rest, int formals_start_pos,
                               int formals_end_pos, bool* ok);
 
-  BlockT ParseVariableDeclarations(VariableDeclarationContext var_context,
+  BlockT ParseVariableDeclarations(ParseInfo* info, VariableDeclarationContext var_context,
                                    DeclarationParsingResult* parsing_result,
                                    ZonePtrList<const AstRawString>* names,
                                    bool* ok);
   StatementT ParseAsyncFunctionDeclaration(
-      ZonePtrList<const AstRawString>* names, bool default_export, bool* ok);
-  StatementT ParseFunctionDeclaration(bool* ok);
-  StatementT ParseHoistableDeclaration(ZonePtrList<const AstRawString>* names,
+      ParseInfo* info, ZonePtrList<const AstRawString>* names, bool default_export, bool* ok);
+  StatementT ParseFunctionDeclaration(ParseInfo* info, bool* ok);
+  StatementT ParseHoistableDeclaration(ParseInfo* info, ZonePtrList<const AstRawString>* names,
                                        bool default_export, bool* ok);
-  StatementT ParseHoistableDeclaration(int pos, ParseFunctionFlags flags,
+  StatementT ParseHoistableDeclaration(ParseInfo* info, int pos, ParseFunctionFlags flags,
                                        ZonePtrList<const AstRawString>* names,
                                        bool default_export, bool* ok);
   StatementT ParseClassDeclaration(ZonePtrList<const AstRawString>* names,
@@ -1187,7 +1194,7 @@ class ParserBase {
   // Whether we're parsing a single-expression arrow function or something else.
   enum class FunctionBodyType { kExpression, kBlock };
   // Consumes the ending }.
-  void ParseFunctionBody(StatementListT result, IdentifierT function_name,
+  void ParseFunctionBody(ParseInfo* info, StatementListT result, IdentifierT function_name,
                          int pos, const FormalParametersT& parameters,
                          FunctionKind kind,
                          FunctionLiteral::FunctionType function_type,
@@ -1204,93 +1211,92 @@ class ParserBase {
   // by value. The method is expected to add the parsed statements to the
   // list. This works because in the case of the parser, StatementListT is
   // a pointer whereas the preparser does not really modify the body.
-  V8_INLINE void ParseStatementList(StatementListT body, Token::Value end_token,
+  V8_INLINE void ParseStatementList(ParseInfo* info, StatementListT body, Token::Value end_token,
                                     bool* ok) {
-    LazyParsingResult result = ParseStatementList(body, end_token, false, ok);
+    LazyParsingResult result = ParseStatementList(info, body, end_token, false, ok);
     USE(result);
     DCHECK_EQ(result, kLazyParsingComplete);
   }
-  V8_INLINE LazyParsingResult ParseStatementList(StatementListT body,
+  V8_INLINE LazyParsingResult ParseStatementList(ParseInfo* info, StatementListT body,
                                                  Token::Value end_token,
                                                  bool may_abort, bool* ok);
-  StatementT ParseStatementListItem(bool* ok);
-
-  StatementT ParseStatement(ZonePtrList<const AstRawString>* labels,
+  StatementT ParseStatementListItem(ParseInfo* info, bool* ok);
+  StatementT ParseStatement(ParseInfo* info, ZonePtrList<const AstRawString>* labels,
                             ZonePtrList<const AstRawString>* own_labels,
                             bool* ok) {
-    return ParseStatement(labels, own_labels,
+    return ParseStatement(info, labels, own_labels,
                           kDisallowLabelledFunctionStatement, ok);
   }
-  StatementT ParseStatement(ZonePtrList<const AstRawString>* labels,
+  StatementT ParseStatement(ParseInfo* info, ZonePtrList<const AstRawString>* labels,
                             ZonePtrList<const AstRawString>* own_labels,
                             AllowLabelledFunctionStatement allow_function,
                             bool* ok);
-  BlockT ParseBlock(ZonePtrList<const AstRawString>* labels, bool* ok);
+  BlockT ParseBlock(ParseInfo* info, ZonePtrList<const AstRawString>* labels, bool* ok);
 
   // Parse a SubStatement in strict mode, or with an extra block scope in
   // sloppy mode to handle
   // ES#sec-functiondeclarations-in-ifstatement-statement-clauses
-  StatementT ParseScopedStatement(ZonePtrList<const AstRawString>* labels,
+  StatementT ParseScopedStatement(ParseInfo* info, ZonePtrList<const AstRawString>* labels,
                                   bool* ok);
 
-  StatementT ParseVariableStatement(VariableDeclarationContext var_context,
+  StatementT ParseVariableStatement(ParseInfo* info, VariableDeclarationContext var_context,
                                     ZonePtrList<const AstRawString>* names,
                                     bool* ok);
 
   // Magical syntax support.
-  ExpressionT ParseV8Intrinsic(bool* ok);
+  ExpressionT ParseV8Intrinsic(ParseInfo* info, bool* ok);
 
-  ExpressionT ParseDoExpression(bool* ok);
+  ExpressionT ParseDoExpression(ParseInfo* info, bool* ok);
 
   StatementT ParseDebuggerStatement(bool* ok);
 
   StatementT ParseExpressionOrLabelledStatement(
-      ZonePtrList<const AstRawString>* labels,
+      ParseInfo* info, ZonePtrList<const AstRawString>* labels,
       ZonePtrList<const AstRawString>* own_labels,
       AllowLabelledFunctionStatement allow_function, bool* ok);
-  StatementT ParseIfStatement(ZonePtrList<const AstRawString>* labels,
+  StatementT ParseIfStatement(ParseInfo* info, ZonePtrList<const AstRawString>* labels,
                               bool* ok);
   StatementT ParseContinueStatement(bool* ok);
   StatementT ParseBreakStatement(ZonePtrList<const AstRawString>* labels,
                                  bool* ok);
-  StatementT ParseReturnStatement(bool* ok);
-  StatementT ParseWithStatement(ZonePtrList<const AstRawString>* labels,
+  StatementT ParseReturnStatement(ParseInfo* info, bool* ok);
+  StatementT ParseWithStatement(ParseInfo* info, ZonePtrList<const AstRawString>* labels,
                                 bool* ok);
-  StatementT ParseDoWhileStatement(ZonePtrList<const AstRawString>* labels,
+  StatementT ParseDoWhileStatement(ParseInfo* info, ZonePtrList<const AstRawString>* labels,
                                    ZonePtrList<const AstRawString>* own_labels,
                                    bool* ok);
-  StatementT ParseWhileStatement(ZonePtrList<const AstRawString>* labels,
+  StatementT ParseWhileStatement(ParseInfo* info, ZonePtrList<const AstRawString>* labels,
                                  ZonePtrList<const AstRawString>* own_labels,
                                  bool* ok);
-  StatementT ParseThrowStatement(bool* ok);
-  StatementT ParseSwitchStatement(ZonePtrList<const AstRawString>* labels,
+  StatementT ParseThrowStatement(ParseInfo* info, bool* ok);
+  StatementT ParseSwitchStatement(ParseInfo* info, ZonePtrList<const AstRawString>* labels,
                                   bool* ok);
-  V8_INLINE StatementT ParseTryStatement(bool* ok);
-  StatementT ParseForStatement(ZonePtrList<const AstRawString>* labels,
+  V8_INLINE StatementT ParseTryStatement(ParseInfo* info, bool* ok);
+  StatementT ParseForStatement(ParseInfo* info, ZonePtrList<const AstRawString>* labels,
                                ZonePtrList<const AstRawString>* own_labels,
                                bool* ok);
   StatementT ParseForEachStatementWithDeclarations(
-      int stmt_pos, ForInfo* for_info, ZonePtrList<const AstRawString>* labels,
+      ParseInfo* info, int stmt_pos, ForInfo* for_info, ZonePtrList<const AstRawString>* labels,
       ZonePtrList<const AstRawString>* own_labels, Scope* inner_block_scope,
       bool* ok);
   StatementT ParseForEachStatementWithoutDeclarations(
-      int stmt_pos, ExpressionT expression, int lhs_beg_pos, int lhs_end_pos,
+      ParseInfo* info, int stmt_pos, ExpressionT expression, int lhs_beg_pos, int lhs_end_pos,
       ForInfo* for_info, ZonePtrList<const AstRawString>* labels,
       ZonePtrList<const AstRawString>* own_labels, bool* ok);
 
   // Parse a C-style for loop: 'for (<init>; <cond>; <next>) { ... }'
   // "for (<init>;" is assumed to have been parser already.
   ForStatementT ParseStandardForLoop(
-      int stmt_pos, ZonePtrList<const AstRawString>* labels,
+      ParseInfo* info, int stmt_pos, ZonePtrList<const AstRawString>* labels,
       ZonePtrList<const AstRawString>* own_labels, ExpressionT* cond,
       StatementT* next, StatementT* body, bool* ok);
   // Same as the above, but handles those cases where <init> is a
   // lexical variable declaration.
   StatementT ParseStandardForLoopWithLexicalDeclarations(
-      int stmt_pos, StatementT init, ForInfo* for_info,
+      ParseInfo* info, int stmt_pos, StatementT init, ForInfo* for_info,
       ZonePtrList<const AstRawString>* labels,
       ZonePtrList<const AstRawString>* own_labels, bool* ok);
-  StatementT ParseForAwaitStatement(ZonePtrList<const AstRawString>* labels,
+  StatementT ParseForAwaitStatement(ParseInfo* info, ZonePtrList<const AstRawString>* labels,
                                     ZonePtrList<const AstRawString>* own_labels,
                                     bool* ok);
 
@@ -1417,9 +1423,13 @@ class ParserBase {
       function_state_->AddSuspend();
     }
     if (is_async_function()) {
-      return factory()->NewAsyncReturnStatement(expr, pos, end_pos);
+      StatementT return_statement = factory()->NewAsyncReturnStatement(expr, pos, end_pos);
+      impl()->SetTempVarForStatement(return_statement, true);
+      return return_statement;
     }
-    return factory()->NewReturnStatement(expr, pos, end_pos);
+    StatementT return_statement = factory()->NewReturnStatement(expr, pos, end_pos);
+    impl()->SetTempVarForStatement(return_statement, true);
+    return return_statement;
   }
 
   // Validation per ES6 object literals.
@@ -1687,7 +1697,6 @@ ParserBase<Impl>::ParseAndClassifyIdentifier(bool* ok) {
   STATIC_ASSERT(Token::IDENTIFIER + 1 == Token::ASYNC);
   if (IsInRange(next, Token::IDENTIFIER, Token::ASYNC)) {
     IdentifierT name = impl()->GetSymbol();
-
     // When this function is used to read a formal parameter, we don't always
     // know whether the function is going to be strict or sloppy.  Indeed for
     // arrow functions we don't always know that the identifier we are reading
@@ -1821,7 +1830,7 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseRegExpLiteral(
 
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseBindingPattern(
-    bool* ok) {
+    ParseInfo* info, bool* ok) {
   // Pattern ::
   //   Identifier
   //   ArrayLiteral
@@ -1838,7 +1847,7 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseBindingPattern(
     classifier()->RecordNonSimpleParameter();
 
     if (token == Token::LBRACK) {
-      result = ParseArrayLiteral(CHECK_OK);
+      result = ParseArrayLiteral(info, CHECK_OK);
     } else if (token == Token::LBRACE) {
       result = ParseObjectLiteral(CHECK_OK);
     } else {
@@ -1854,7 +1863,7 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseBindingPattern(
 
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParsePrimaryExpression(
-    bool* is_async, bool* ok) {
+    ParseInfo* info, bool* is_async, bool* ok) {
   // PrimaryExpression ::
   //   'this'
   //   'null'
@@ -1878,6 +1887,8 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParsePrimaryExpression(
     case Token::THIS: {
       BindingPatternUnexpectedToken();
       Consume(Token::THIS);
+      if(info)
+        info->set_is_this(true);
       return impl()->ThisExpression(beg_pos);
     }
 
@@ -1896,7 +1907,7 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParsePrimaryExpression(
       DCHECK(Token::IsLiteral(token));
       BindingPatternUnexpectedToken();
       Consume(Token::STRING);
-      return impl()->ExpressionFromString(beg_pos);
+      return impl()->ExpressionFromString(beg_pos, true);
     }
 
     case Token::ASYNC:
@@ -1904,7 +1915,7 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParsePrimaryExpression(
           PeekAhead() == Token::FUNCTION) {
         BindingPatternUnexpectedToken();
         Consume(Token::ASYNC);
-        return ParseAsyncFunctionLiteral(ok);
+        return ParseAsyncFunctionLiteral(info, ok);
       }
       // CoverCallExpressionAndAsyncArrowHead
       *is_async = true;
@@ -1931,7 +1942,7 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParsePrimaryExpression(
       return ParseRegExpLiteral(ok);
 
     case Token::LBRACK:
-      return ParseArrayLiteral(ok);
+      return ParseArrayLiteral(info, ok);
 
     case Token::LBRACE:
       return ParseObjectLiteral(ok);
@@ -1962,7 +1973,7 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParsePrimaryExpression(
           (peek() == Token::ASYNC && PeekAhead() == Token::FUNCTION)) {
         function_state_->set_next_function_is_likely_called();
       }
-      ExpressionT expr = ParseExpressionCoverGrammar(true, CHECK_OK);
+      ExpressionT expr = ParseExpressionCoverGrammar(info, true, CHECK_OK);
       Expect(Token::RPAREN, ok);
       return expr;
     }
@@ -1991,19 +2002,19 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParsePrimaryExpression(
     case Token::TEMPLATE_SPAN:
     case Token::TEMPLATE_TAIL:
       BindingPatternUnexpectedToken();
-      return ParseTemplateLiteral(impl()->NullExpression(), beg_pos, false, ok);
+      return ParseTemplateLiteral(info, impl()->NullExpression(), beg_pos, false, ok);
 
     case Token::MOD:
       if (allow_natives() || extension_ != nullptr) {
         BindingPatternUnexpectedToken();
-        return ParseV8Intrinsic(ok);
+        return ParseV8Intrinsic(info, ok);
       }
       break;
 
     case Token::DO:
       if (allow_harmony_do_expressions()) {
         BindingPatternUnexpectedToken();
-        return ParseDoExpression(ok);
+        return ParseDoExpression(info, ok);
       }
       break;
 
@@ -2018,16 +2029,16 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParsePrimaryExpression(
 
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseExpression(
-    bool* ok) {
+    ParseInfo* info, bool* ok) {
   ExpressionClassifier classifier(this);
-  ExpressionT result = ParseExpressionCoverGrammar(true, CHECK_OK);
+  ExpressionT result = ParseExpressionCoverGrammar(info, true, CHECK_OK);
   ValidateExpression(ok);
   return result;
 }
 
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT
-ParserBase<Impl>::ParseExpressionCoverGrammar(bool accept_IN, bool* ok) {
+ParserBase<Impl>::ParseExpressionCoverGrammar(ParseInfo* info, bool accept_IN, bool* ok) {
   // Expression ::
   //   AssignmentExpression
   //   Expression ',' AssignmentExpression
@@ -2046,7 +2057,7 @@ ParserBase<Impl>::ParseExpressionCoverGrammar(bool accept_IN, bool* ok) {
                                           Token::String(Token::ELLIPSIS));
       int ellipsis_pos = position();
       int pattern_pos = peek_position();
-      ExpressionT pattern = ParseBindingPattern(CHECK_OK);
+      ExpressionT pattern = ParseBindingPattern(info, CHECK_OK);
       if (peek() == Token::ASSIGN) {
         ReportMessage(MessageTemplate::kRestDefaultInitializer);
         *ok = false;
@@ -2054,7 +2065,7 @@ ParserBase<Impl>::ParseExpressionCoverGrammar(bool accept_IN, bool* ok) {
       }
       right = factory()->NewSpread(pattern, ellipsis_pos, pattern_pos);
     } else {
-      right = ParseAssignmentExpression(accept_IN, CHECK_OK);
+      right = ParseAssignmentExpression(info, accept_IN, CHECK_OK);
     }
     // No need to accumulate binding pattern-related errors, since
     // an Expression can't be a binding pattern anyway.
@@ -2097,7 +2108,7 @@ ParserBase<Impl>::ParseExpressionCoverGrammar(bool accept_IN, bool* ok) {
 
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseArrayLiteral(
-    bool* ok) {
+    ParseInfo* info, bool* ok) {
   // ArrayLiteral ::
   //   '[' Expression? (',' Expression?)* ']'
 
@@ -2112,7 +2123,7 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseArrayLiteral(
     } else if (Check(Token::ELLIPSIS)) {
       int start_pos = position();
       int expr_pos = peek_position();
-      ExpressionT argument = ParseAssignmentExpression(true, CHECK_OK);
+      ExpressionT argument = ParseAssignmentExpression(info, true, CHECK_OK);
       elem = factory()->NewSpread(argument, start_pos, expr_pos);
 
       if (first_spread_index < 0) {
@@ -2134,7 +2145,7 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseArrayLiteral(
       }
     } else {
       int beg_pos = peek_position();
-      elem = ParseAssignmentExpression(true, CHECK_OK);
+      elem = ParseAssignmentExpression(info, true, CHECK_OK);
       CheckDestructuringElement(elem, beg_pos, end_position());
     }
     values->Add(elem, zone_);
@@ -2262,7 +2273,7 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParsePropertyName(
       *is_computed_name = true;
       Consume(Token::LBRACK);
       ExpressionClassifier computed_name_classifier(this);
-      ExpressionT expression = ParseAssignmentExpression(true, CHECK_OK);
+      ExpressionT expression = ParseAssignmentExpression(nullptr, true, CHECK_OK);
       ValidateExpression(CHECK_OK);
       AccumulateFormalParameterContainmentErrors();
       Expect(Token::RBRACK, CHECK_OK);
@@ -2276,7 +2287,7 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParsePropertyName(
       if (*kind == ParsePropertyKind::kNotSet) {
         *name = impl()->NullIdentifier();
         Consume(Token::ELLIPSIS);
-        ExpressionT expression = ParseAssignmentExpression(true, CHECK_OK);
+        ExpressionT expression = ParseAssignmentExpression(nullptr, true, CHECK_OK);
         *kind = ParsePropertyKind::kSpread;
 
         if (!impl()->IsIdentifier(expression)) {
@@ -2436,10 +2447,10 @@ ParserBase<Impl>::ParseClassPropertyDefinition(
       }
 
       ExpressionT value = impl()->ParseFunctionLiteral(
-          *name, scanner()->location(), kSkipFunctionNameCheck, kind,
+          nullptr, *name, scanner()->location(), kSkipFunctionNameCheck, kind,
           name_token_position, FunctionLiteral::kAccessorOrMethod,
           language_mode(), nullptr, CHECK_OK_CUSTOM(NullLiteralProperty));
-
+      
       *property_kind = ClassLiteralProperty::METHOD;
       ClassLiteralPropertyT result = factory()->NewClassLiteralProperty(
           name_expression, value, *property_kind, *is_static,
@@ -2468,7 +2479,7 @@ ParserBase<Impl>::ParseClassPropertyDefinition(
                                  : FunctionKind::kSetterFunction;
 
       FunctionLiteralT value = impl()->ParseFunctionLiteral(
-          *name, scanner()->location(), kSkipFunctionNameCheck, kind,
+          nullptr, *name, scanner()->location(), kSkipFunctionNameCheck, kind,
           name_token_position, FunctionLiteral::kAccessorOrMethod,
           language_mode(), nullptr, CHECK_OK_CUSTOM(NullLiteralProperty));
 
@@ -2516,7 +2527,7 @@ ParserBase<Impl>::ParseClassFieldInitializer(ClassInfo* class_info, int beg_pos,
     ExpressionClassifier expression_classifier(this);
 
     initializer =
-        ParseAssignmentExpression(true, CHECK_OK_CUSTOM(NullExpression));
+        ParseAssignmentExpression(nullptr, true, CHECK_OK_CUSTOM(NullExpression));
     ValidateExpression(CHECK_OK_CUSTOM(NullExpression));
   } else {
     initializer = factory()->NewUndefinedLiteral(kNoSourcePosition);
@@ -2553,7 +2564,7 @@ ParserBase<Impl>::ParseObjectPropertyDefinition(ObjectLiteralChecker* checker,
                         CHECK_OK_CUSTOM(NullLiteralProperty));
 
   switch (kind) {
-    case ParsePropertyKind::kSpread:
+    case ParsePropertyKind::kSpread: {
       DCHECK_EQ(function_flags, ParseFunctionFlag::kIsNormal);
       DCHECK(!*is_computed_name);
       DCHECK_EQ(Token::ELLIPSIS, name_token);
@@ -2561,9 +2572,12 @@ ParserBase<Impl>::ParseObjectPropertyDefinition(ObjectLiteralChecker* checker,
       *is_computed_name = true;
       *is_rest_property = true;
 
-      return factory()->NewObjectLiteralProperty(
+      ObjectLiteralPropertyT prop = factory()->NewObjectLiteralProperty(
           factory()->NewTheHoleLiteral(), name_expression,
           ObjectLiteralProperty::SPREAD, true);
+      impl()->SetTempVarForObjectLiteralProperty(prop);
+      return prop;
+    }
 
     case ParsePropertyKind::kValue: {
       DCHECK_EQ(function_flags, ParseFunctionFlag::kIsNormal);
@@ -2574,11 +2588,13 @@ ParserBase<Impl>::ParseObjectPropertyDefinition(ObjectLiteralChecker* checker,
       Consume(Token::COLON);
       int beg_pos = peek_position();
       ExpressionT value =
-          ParseAssignmentExpression(true, CHECK_OK_CUSTOM(NullLiteralProperty));
+          ParseAssignmentExpression(nullptr, true, CHECK_OK_CUSTOM(NullLiteralProperty));
       CheckDestructuringElement(value, beg_pos, end_position());
 
       ObjectLiteralPropertyT result = factory()->NewObjectLiteralProperty(
-          name_expression, value, *is_computed_name);
+          name_expression, value, *is_computed_name);   
+      impl()->SetTempVarForObjectLiteralProperty(result);
+
       impl()->SetFunctionNameFromPropertyName(result, name);
       return result;
     }
@@ -2632,22 +2648,27 @@ ParserBase<Impl>::ParseObjectPropertyDefinition(ObjectLiteralChecker* checker,
         Consume(Token::ASSIGN);
         ExpressionClassifier rhs_classifier(this);
         ExpressionT rhs = ParseAssignmentExpression(
-            true, CHECK_OK_CUSTOM(NullLiteralProperty));
+            nullptr, true, CHECK_OK_CUSTOM(NullLiteralProperty)); 
         ValidateExpression(CHECK_OK_CUSTOM(NullLiteralProperty));
         AccumulateFormalParameterContainmentErrors();
         value = factory()->NewAssignment(Token::ASSIGN, lhs, rhs,
                                          kNoSourcePosition);
+
+        impl()->SetTempVarForExpression(value, true);
+
         classifier()->RecordExpressionError(
             Scanner::Location(next_beg_pos, end_position()),
             MessageTemplate::kInvalidCoverInitializedName);
 
-        impl()->SetFunctionNameFromIdentifierRef(rhs, lhs);
+        impl()->SetFunctionNameFromIdentifierRef(nullptr, rhs, lhs); 
       } else {
         value = lhs;
       }
 
       ObjectLiteralPropertyT result = factory()->NewObjectLiteralProperty(
-          name_expression, value, ObjectLiteralProperty::COMPUTED, false);
+          name_expression, value, ObjectLiteralProperty::COMPUTED, false); 
+      impl()->SetTempVarForObjectLiteralProperty(result);
+
       impl()->SetFunctionNameFromPropertyName(result, name);
       return result;
     }
@@ -2664,13 +2685,15 @@ ParserBase<Impl>::ParseObjectPropertyDefinition(ObjectLiteralChecker* checker,
       FunctionKind kind = MethodKindFor(function_flags);
 
       ExpressionT value = impl()->ParseFunctionLiteral(
-          name, scanner()->location(), kSkipFunctionNameCheck, kind,
+          nullptr, name, scanner()->location(), kSkipFunctionNameCheck, kind,
           next_beg_pos, FunctionLiteral::kAccessorOrMethod, language_mode(),
-          nullptr, CHECK_OK_CUSTOM(NullLiteralProperty));
+          nullptr, CHECK_OK_CUSTOM(NullLiteralProperty)); 
 
       ObjectLiteralPropertyT result = factory()->NewObjectLiteralProperty(
           name_expression, value, ObjectLiteralProperty::COMPUTED,
-          *is_computed_name);
+          *is_computed_name);  
+      impl()->SetTempVarForObjectLiteralProperty(result);
+
       impl()->SetFunctionNameFromPropertyName(result, name);
       return result;
     }
@@ -2696,7 +2719,7 @@ ParserBase<Impl>::ParseObjectPropertyDefinition(ObjectLiteralChecker* checker,
                                  : FunctionKind::kSetterFunction;
 
       FunctionLiteralT value = impl()->ParseFunctionLiteral(
-          name, scanner()->location(), kSkipFunctionNameCheck, kind,
+          nullptr, name, scanner()->location(), kSkipFunctionNameCheck, kind,
           next_beg_pos, FunctionLiteral::kAccessorOrMethod, language_mode(),
           nullptr, CHECK_OK_CUSTOM(NullLiteralProperty));
 
@@ -2704,7 +2727,9 @@ ParserBase<Impl>::ParseObjectPropertyDefinition(ObjectLiteralChecker* checker,
           name_expression, value,
           is_get ? ObjectLiteralProperty::GETTER
                  : ObjectLiteralProperty::SETTER,
-          *is_computed_name);
+          *is_computed_name);  
+      impl()->SetTempVarForObjectLiteralProperty(result);
+
       const AstRawString* prefix =
           is_get ? ast_value_factory()->get_space_string()
                  : ast_value_factory()->set_space_string();
@@ -2780,13 +2805,20 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseObjectLiteral(
                                            MessageTemplate::kTooManyArguments);
   }
 
-  return impl()->InitializeObjectLiteral(factory()->NewObjectLiteral(
-      properties, number_of_boilerplate_properties, pos, has_rest_property));
+  auto obj_lit = factory()->NewObjectLiteral(properties, number_of_boilerplate_properties, pos, has_rest_property);
+  impl()->SetTempVarForExpression(obj_lit, true);
+  ExpressionT return_expr = impl()->InitializeObjectLiteral(obj_lit);
+  bool success = false;
+  ExpressionT extra_asg = impl()->construct_asg_for_obj_literal(obj_lit, return_expr, &success);
+  if(success) {
+    return extra_asg;
+  }
+  return return_expr;
 }
 
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionListT ParserBase<Impl>::ParseArguments(
-    Scanner::Location* first_spread_arg_loc, bool maybe_arrow,
+    ParseInfo* info, Scanner::Location* first_spread_arg_loc, bool maybe_arrow,
     bool* is_simple_parameter_list, bool* ok) {
   // Arguments ::
   //   '(' (AssignmentExpression)*[','] ')'
@@ -2800,7 +2832,8 @@ typename ParserBase<Impl>::ExpressionListT ParserBase<Impl>::ParseArguments(
     int expr_pos = peek_position();
 
     ExpressionT argument =
-        ParseAssignmentExpression(true, CHECK_OK_CUSTOM(NullExpressionList));
+        ParseAssignmentExpression(info, true, CHECK_OK_CUSTOM(NullExpressionList)); 
+
     if (!impl()->IsIdentifier(argument)) *is_simple_parameter_list = false;
 
     if (!maybe_arrow) {
@@ -2856,16 +2889,18 @@ typename ParserBase<Impl>::ExpressionListT ParserBase<Impl>::ParseArguments(
 // Precedence = 2
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT
-ParserBase<Impl>::ParseAssignmentExpression(bool accept_IN, bool* ok) {
+ParserBase<Impl>::ParseAssignmentExpression(ParseInfo* info, bool accept_IN, bool* ok) {
   // AssignmentExpression ::
   //   ConditionalExpression
   //   ArrowFunction
   //   YieldExpression
   //   LeftHandSideExpression AssignmentOperator AssignmentExpression
+
   int lhs_beg_pos = peek_position();
 
   if (peek() == Token::YIELD && is_generator()) {
-    return ParseYieldExpression(accept_IN, ok);
+    ExpressionT yield_exp = ParseYieldExpression(info, accept_IN, ok);
+    return yield_exp;
   }
 
   FuncNameInferrerState fni_state(&fni_);
@@ -2889,11 +2924,12 @@ ParserBase<Impl>::ParseAssignmentExpression(bool accept_IN, bool* ok) {
   // that we have only a trivial expression to parse.
   ExpressionT expression;
   if (IsTrivialExpression()) {
-    expression = ParsePrimaryExpression(&is_async, CHECK_OK);
+    expression = ParsePrimaryExpression(info, &is_async, CHECK_OK);
   } else {
-    expression = ParseConditionalExpression(accept_IN, CHECK_OK);
+    expression = ParseConditionalExpression(info, accept_IN, CHECK_OK);
   }
 
+
   if (is_async && impl()->IsIdentifier(expression) && peek_any_identifier() &&
       PeekAhead() == Token::ARROW) {
     // async Identifier => AsyncConciseBody
@@ -2938,7 +2974,7 @@ ParserBase<Impl>::ParseAssignmentExpression(bool accept_IN, bool* ok) {
     if (duplicate_loc.IsValid()) {
       classifier()->RecordDuplicateFormalParameterError(duplicate_loc);
     }
-    expression = ParseArrowFunctionLiteral(accept_IN, parameters,
+    expression = ParseArrowFunctionLiteral(info, accept_IN, parameters,
                                            rewritable_length, CHECK_OK);
     Accumulate(ExpressionClassifier::AsyncArrowFormalParametersProduction);
     classifier()->RecordPatternError(arrow_loc,
@@ -2974,7 +3010,9 @@ ParserBase<Impl>::ParseAssignmentExpression(bool accept_IN, bool* ok) {
   }
 
   Accumulate(productions);
-  if (!Token::IsAssignmentOp(peek())) return expression;
+  if (!Token::IsAssignmentOp(peek())) {
+    return expression;
+  }
 
   if (is_destructuring_assignment) {
     ValidateAssignmentPattern(CHECK_OK);
@@ -2996,19 +3034,26 @@ ParserBase<Impl>::ParseAssignmentExpression(bool accept_IN, bool* ok) {
 
   ExpressionClassifier rhs_classifier(this);
 
-  ExpressionT right = ParseAssignmentExpression(accept_IN, CHECK_OK);
+  ExpressionT right = ParseAssignmentExpression(info, accept_IN, CHECK_OK);
   ValidateExpression(CHECK_OK);
   AccumulateFormalParameterContainmentErrors();
+  
+  if(right->IsCallNew()) {
+    impl()->PushNewedFunction(expression, right, info);
+  }
+
 
   // We try to estimate the set of properties set by constructors. We define a
   // new property whenever there is an assignment to a property of 'this'. We
   // should probably only add properties if we haven't seen them
   // before. Otherwise we'll probably overestimate the number of properties.
+  bool is_this = false;
   if (op == Token::ASSIGN && impl()->IsThisProperty(expression)) {
+    is_this = true;
     function_state_->AddProperty();
   }
 
-  impl()->CheckAssigningFunctionLiteralToProperty(expression, right);
+  impl()->CheckAssigningFunctionLiteralToProperty(info, expression, right, is_this);
 
   // Check if the right hand side is a call to avoid inferring a
   // name if we're dealing with "a = function(){...}();"-like
@@ -3020,11 +3065,12 @@ ParserBase<Impl>::ParseAssignmentExpression(bool accept_IN, bool* ok) {
   }
 
   if (op == Token::ASSIGN) {
-    impl()->SetFunctionNameFromIdentifierRef(right, expression);
+    impl()->SetFunctionNameFromIdentifierRef(info, right, expression);
   }
 
   DCHECK_NE(op, Token::INIT);
   ExpressionT result = factory()->NewAssignment(op, expression, right, pos);
+  impl()->SetTempVarForExpression(result, true);
 
   if (is_destructuring_assignment) {
     DCHECK_NE(op, Token::ASSIGN_EXP);
@@ -3032,13 +3078,12 @@ ParserBase<Impl>::ParseAssignmentExpression(bool accept_IN, bool* ok) {
     impl()->QueueDestructuringAssignmentForRewriting(rewritable);
     result = rewritable;
   }
-
   return result;
 }
 
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseYieldExpression(
-    bool accept_IN, bool* ok) {
+    ParseInfo* info, bool accept_IN, bool* ok) {
   // YieldExpression ::
   //   'yield' ([no line terminator] '*'? AssignmentExpression)?
   int pos = peek_position();
@@ -3069,7 +3114,7 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseYieldExpression(
         // Delegating yields require an RHS; fall through.
         V8_FALLTHROUGH;
       default:
-        expression = ParseAssignmentExpression(accept_IN, CHECK_OK);
+        expression = ParseAssignmentExpression(info, accept_IN, CHECK_OK);  
         ValidateExpression(CHECK_OK);
         break;
     }
@@ -3099,7 +3144,7 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseYieldExpression(
 // Precedence = 3
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT
-ParserBase<Impl>::ParseConditionalExpression(bool accept_IN,
+ParserBase<Impl>::ParseConditionalExpression(ParseInfo* info, bool accept_IN,
                                              bool* ok) {
   // ConditionalExpression ::
   //   LogicalOrExpression
@@ -3107,15 +3152,16 @@ ParserBase<Impl>::ParseConditionalExpression(bool accept_IN,
 
   int pos = peek_position();
   // We start using the binary expression parser for prec >= 4 only!
-  ExpressionT expression = ParseBinaryExpression(4, accept_IN, CHECK_OK);
+  
+  ExpressionT expression = ParseBinaryExpression(info, 4, accept_IN, CHECK_OK);
   return peek() == Token::CONDITIONAL
-             ? ParseConditionalContinuation(expression, accept_IN, pos, ok)
+             ? ParseConditionalContinuation(info, expression, accept_IN, pos, ok)
              : expression;
 }
 
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT
-ParserBase<Impl>::ParseConditionalContinuation(ExpressionT expression,
+ParserBase<Impl>::ParseConditionalContinuation(ParseInfo* info, ExpressionT expression,
                                                bool accept_IN, int pos,
                                                bool* ok) {
   SourceRange then_range, else_range;
@@ -3131,7 +3177,7 @@ ParserBase<Impl>::ParseConditionalContinuation(ExpressionT expression,
     // In parsing the first assignment expression in conditional
     // expressions we always accept the 'in' keyword; see ECMA-262,
     // section 11.12, page 58.
-    left = ParseAssignmentExpression(true, CHECK_OK);
+    left = ParseAssignmentExpression(info, true, CHECK_OK);
     AccumulateNonBindingPatternErrors();
   }
   ValidateExpression(CHECK_OK);
@@ -3140,11 +3186,12 @@ ParserBase<Impl>::ParseConditionalContinuation(ExpressionT expression,
     SourceRangeScope range_scope(scanner(), &else_range);
     Expect(Token::COLON, CHECK_OK);
     ExpressionClassifier classifier(this);
-    right = ParseAssignmentExpression(accept_IN, CHECK_OK);
+    right = ParseAssignmentExpression(info, accept_IN, CHECK_OK);
     AccumulateNonBindingPatternErrors();
   }
   ValidateExpression(CHECK_OK);
   ExpressionT expr = factory()->NewConditional(expression, left, right, pos);
+  impl()->SetTempVarForExpression(expr, true);
   impl()->RecordConditionalSourceRange(expr, then_range, else_range);
   return expr;
 }
@@ -3153,13 +3200,16 @@ ParserBase<Impl>::ParseConditionalContinuation(ExpressionT expression,
 // Precedence >= 4
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseBinaryExpression(
-    int prec, bool accept_IN, bool* ok) {
+    ParseInfo* info, int prec, bool accept_IN, bool* ok) {
   DCHECK_GE(prec, 4);
   SourceRange right_range;
-  ExpressionT x = ParseUnaryExpression(CHECK_OK);
+
+
+  ExpressionT x = ParseUnaryExpression(info, CHECK_OK);
   for (int prec1 = Precedence(peek(), accept_IN); prec1 >= prec; prec1--) {
     // prec1 >= 4
-    while (Precedence(peek(), accept_IN) == prec1) {
+    
+      while (Precedence(peek(), accept_IN) == prec1) {
       ValidateExpression(CHECK_OK);
       BindingPatternUnexpectedToken();
       ArrowFormalParametersUnexpectedToken();
@@ -3170,7 +3220,7 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseBinaryExpression(
 
       const bool is_right_associative = op == Token::EXP;
       const int next_prec = is_right_associative ? prec1 : prec1 + 1;
-      ExpressionT y = ParseBinaryExpression(next_prec, accept_IN, CHECK_OK);
+      ExpressionT y = ParseBinaryExpression(info, next_prec, accept_IN, CHECK_OK);
       right_range_scope.Finalize();
       ValidateExpression(CHECK_OK);
 
@@ -3201,12 +3251,13 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseBinaryExpression(
       }
     }
   }
+
   return x;
 }
 
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseUnaryOpExpression(
-    bool* ok) {
+   ParseInfo* info, bool* ok) {
   BindingPatternUnexpectedToken();
   ArrowFormalParametersUnexpectedToken();
 
@@ -3218,7 +3269,7 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseUnaryOpExpression(
     function_state_->set_next_function_is_likely_called();
   }
 
-  ExpressionT expression = ParseUnaryExpression(CHECK_OK);
+  ExpressionT expression = ParseUnaryExpression(info, CHECK_OK);
   ValidateExpression(CHECK_OK);
 
   if (op == Token::DELETE) {
@@ -3248,12 +3299,12 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseUnaryOpExpression(
 
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParsePrefixExpression(
-    bool* ok) {
+    ParseInfo* info, bool* ok) {
   BindingPatternUnexpectedToken();
   ArrowFormalParametersUnexpectedToken();
   Token::Value op = Next();
   int beg_pos = peek_position();
-  ExpressionT expression = ParseUnaryExpression(CHECK_OK);
+  ExpressionT expression = ParseUnaryExpression(info, CHECK_OK);
   expression = CheckAndRewriteReferenceExpression(
       expression, beg_pos, end_position(),
       MessageTemplate::kInvalidLhsInPrefixOp, CHECK_OK);
@@ -3266,14 +3317,14 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParsePrefixExpression(
 
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseAwaitExpression(
-    bool* ok) {
+    ParseInfo* info, bool* ok) {
   classifier()->RecordFormalParameterInitializerError(
       scanner()->peek_location(),
       MessageTemplate::kAwaitExpressionFormalParameter);
   int await_pos = peek_position();
   Consume(Token::AWAIT);
 
-  ExpressionT value = ParseUnaryExpression(CHECK_OK);
+  ExpressionT value = ParseUnaryExpression(info, CHECK_OK);
 
   classifier()->RecordBindingPatternError(
       Scanner::Location(await_pos, end_position()),
@@ -3287,7 +3338,7 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseAwaitExpression(
 
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseUnaryExpression(
-    bool* ok) {
+    ParseInfo* info, bool* ok) {
   // UnaryExpression ::
   //   PostfixExpression
   //   'delete' UnaryExpression
@@ -3302,22 +3353,22 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseUnaryExpression(
   //   [+Await] AwaitExpression[?Yield]
 
   Token::Value op = peek();
-  if (Token::IsUnaryOp(op)) return ParseUnaryOpExpression(ok);
-  if (Token::IsCountOp(op)) return ParsePrefixExpression(ok);
+  if (Token::IsUnaryOp(op)) return ParseUnaryOpExpression(info, ok);
+  if (Token::IsCountOp(op)) return ParsePrefixExpression(info, ok);
   if (is_async_function() && op == Token::AWAIT) {
-    return ParseAwaitExpression(ok);
+    return ParseAwaitExpression(info, ok);
   }
-  return ParsePostfixExpression(ok);
+  return ParsePostfixExpression(info, ok);
 }
 
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParsePostfixExpression(
-    bool* ok) {
+    ParseInfo* info, bool* ok) {
   // PostfixExpression ::
   //   LeftHandSideExpression ('++' | '--')?
 
   int lhs_beg_pos = peek_position();
-  ExpressionT expression = ParseLeftHandSideExpression(CHECK_OK);
+  ExpressionT expression = ParseLeftHandSideExpression(info, CHECK_OK);
   if (!scanner()->HasLineTerminatorBeforeNext() && Token::IsCountOp(peek())) {
     BindingPatternUnexpectedToken();
     ArrowFormalParametersUnexpectedToken();
@@ -3340,13 +3391,13 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParsePostfixExpression(
 
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT
-ParserBase<Impl>::ParseLeftHandSideExpression(bool* ok) {
+ParserBase<Impl>::ParseLeftHandSideExpression(ParseInfo* info, bool* ok) {
   // LeftHandSideExpression ::
   //   (NewExpression | MemberExpression) ...
 
   bool is_async = false;
   ExpressionT result =
-      ParseMemberWithNewPrefixesExpression(&is_async, CHECK_OK);
+      ParseMemberWithNewPrefixesExpression(info, &is_async, CHECK_OK);
 
   while (true) {
     switch (peek()) {
@@ -3356,7 +3407,7 @@ ParserBase<Impl>::ParseLeftHandSideExpression(bool* ok) {
         ArrowFormalParametersUnexpectedToken();
         Consume(Token::LBRACK);
         int pos = position();
-        ExpressionT index = ParseExpressionCoverGrammar(true, CHECK_OK);
+        ExpressionT index = ParseExpressionCoverGrammar(info, true, CHECK_OK);
         ValidateExpression(CHECK_OK);
         result = factory()->NewProperty(result, index, pos);
         Expect(Token::RBRACK, CHECK_OK);
@@ -3367,6 +3418,7 @@ ParserBase<Impl>::ParseLeftHandSideExpression(bool* ok) {
         int pos;
         ValidateExpression(CHECK_OK);
         BindingPatternUnexpectedToken();
+        
         if (scanner()->current_token() == Token::IDENTIFIER ||
             scanner()->current_token() == Token::SUPER ||
             scanner()->current_token() == Token::ASYNC) {
@@ -3383,6 +3435,7 @@ ParserBase<Impl>::ParseLeftHandSideExpression(bool* ok) {
           // Also the trailing parenthesis are a hint that the function will
           // be called immediately. If we happen to have parsed a preceding
           // function literal eagerly, we can also compile it eagerly.
+
           if (result->IsFunctionLiteral()) {
             result->AsFunctionLiteral()->SetShouldEagerCompile();
             result->AsFunctionLiteral()->mark_as_iife();
@@ -3393,7 +3446,7 @@ ParserBase<Impl>::ParseLeftHandSideExpression(bool* ok) {
         if (V8_UNLIKELY(is_async && impl()->IsIdentifier(result))) {
           ExpressionClassifier async_classifier(this);
           bool is_simple_parameter_list = true;
-          args = ParseArguments(&spread_pos, true, &is_simple_parameter_list,
+          args = ParseArguments(info, &spread_pos, true, &is_simple_parameter_list,
                                 CHECK_OK);
           if (peek() == Token::ARROW) {
             fni_.RemoveAsyncKeywordFromEnd();
@@ -3418,7 +3471,7 @@ ParserBase<Impl>::ParseLeftHandSideExpression(bool* ok) {
             AccumulateFormalParameterContainmentErrors();
           }
         } else {
-          args = ParseArguments(&spread_pos, CHECK_OK);
+          args = ParseArguments(info, &spread_pos, CHECK_OK);
         }
 
         ArrowFormalParametersUnexpectedToken();
@@ -3459,7 +3512,7 @@ ParserBase<Impl>::ParseLeftHandSideExpression(bool* ok) {
         ValidateExpression(CHECK_OK);
         BindingPatternUnexpectedToken();
         ArrowFormalParametersUnexpectedToken();
-        result = ParseTemplateLiteral(result, position(), true, CHECK_OK);
+        result = ParseTemplateLiteral(info, result, position(), true, CHECK_OK);
         break;
       }
 
@@ -3471,7 +3524,7 @@ ParserBase<Impl>::ParseLeftHandSideExpression(bool* ok) {
 
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT
-ParserBase<Impl>::ParseMemberWithPresentNewPrefixesExpression(bool* is_async,
+ParserBase<Impl>::ParseMemberWithPresentNewPrefixesExpression(ParseInfo* info, bool* is_async,
                                                               bool* ok) {
   // NewExpression ::
   //   ('new')+ MemberExpression
@@ -3494,6 +3547,7 @@ ParserBase<Impl>::ParseMemberWithPresentNewPrefixesExpression(bool* is_async,
   // new new foo().bar().baz means (new (new foo()).bar()).baz
   BindingPatternUnexpectedToken();
   ArrowFormalParametersUnexpectedToken();
+
   Consume(Token::NEW);
   int new_pos = position();
   ExpressionT result;
@@ -3509,40 +3563,44 @@ ParserBase<Impl>::ParseMemberWithPresentNewPrefixesExpression(bool* is_async,
   } else if (peek() == Token::PERIOD) {
     *is_async = false;
     result = ParseNewTargetExpression(CHECK_OK);
-    return ParseMemberExpressionContinuation(result, is_async, ok);
+    return ParseMemberExpressionContinuation(info, false, result, is_async, ok);
   } else {
-    result = ParseMemberWithNewPrefixesExpression(is_async, CHECK_OK);
+    result = ParseMemberWithNewPrefixesExpression(info, is_async, CHECK_OK);
   }
   ValidateExpression(CHECK_OK);
   if (peek() == Token::LPAREN) {
     // NewExpression with arguments.
+
     Scanner::Location spread_pos;
-    ExpressionListT args = ParseArguments(&spread_pos, CHECK_OK);
+    ExpressionListT args = ParseArguments(info, &spread_pos, CHECK_OK);
 
     if (spread_pos.IsValid()) {
       result = impl()->SpreadCallNew(result, args, new_pos);
     } else {
       result = factory()->NewCallNew(result, args, new_pos);
+      impl()->SetTempVarForExpression(result, true);
     }
     // The expression can still continue with . or [ after the arguments.
-    return ParseMemberExpressionContinuation(result, is_async, ok);
+    return ParseMemberExpressionContinuation(info, false, result, is_async, ok);
   }
   // NewExpression without arguments.
-  return factory()->NewCallNew(result, impl()->NewExpressionList(0), new_pos);
+  ExpressionT call_new = factory()->NewCallNew(result, impl()->NewExpressionList(0), new_pos);
+  impl()->SetTempVarForExpression(call_new, true);
+  return call_new;
 }
 
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT
-ParserBase<Impl>::ParseMemberWithNewPrefixesExpression(bool* is_async,
+ParserBase<Impl>::ParseMemberWithNewPrefixesExpression(ParseInfo* info, bool* is_async,
                                                        bool* ok) {
   return peek() == Token::NEW
-             ? ParseMemberWithPresentNewPrefixesExpression(is_async, ok)
-             : ParseMemberExpression(is_async, ok);
+             ? ParseMemberWithPresentNewPrefixesExpression(info, is_async, ok)
+             : ParseMemberExpression(info, is_async, ok);
 }
 
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseMemberExpression(
-    bool* is_async, bool* ok) {
+    ParseInfo* info, bool* is_async, bool* ok) {
   // MemberExpression ::
   //   (PrimaryExpression | FunctionLiteral | ClassLiteral)
   //     ('[' Expression ']' | '.' Identifier | Arguments | TemplateLiteral)*
@@ -3556,6 +3614,7 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseMemberExpression(
   // caller.
 
   // Parse the initial primary or function expression.
+
   ExpressionT result;
   if (peek() == Token::FUNCTION) {
     BindingPatternUnexpectedToken();
@@ -3575,6 +3634,7 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseMemberExpression(
     if (impl()->ParsingDynamicFunctionDeclaration()) {
       // We don't want dynamic functions to actually declare their name
       // "anonymous". We just want that name in the toString().
+      
       if (stack_overflow()) {
         *ok = false;
         return impl()->NullExpression();
@@ -3588,8 +3648,9 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseMemberExpression(
       function_name_location = scanner()->location();
       function_type = FunctionLiteral::kNamedExpression;
     }
+
     result = impl()->ParseFunctionLiteral(
-        name, function_name_location,
+        info, name, function_name_location,
         is_strict_reserved_name ? kFunctionNameIsStrictReserved
                                 : kFunctionNameValidityUnknown,
         function_kind, function_token_position, function_type, language_mode(),
@@ -3600,10 +3661,11 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseMemberExpression(
   } else if (allow_harmony_dynamic_import() && peek() == Token::IMPORT) {
     result = ParseImportExpressions(CHECK_OK);
   } else {
-    result = ParsePrimaryExpression(is_async, CHECK_OK);
+    result = ParsePrimaryExpression(info, is_async, CHECK_OK);
   }
 
-  return ParseMemberExpressionContinuation(result, is_async, ok);
+  bool is_this = info->is_this();
+  return ParseMemberExpressionContinuation(info, is_this, result, is_async, ok);
 }
 
 template <typename Impl>
@@ -3635,7 +3697,7 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseImportExpressions(
     *ok = false;
     return impl()->NullExpression();
   }
-  ExpressionT arg = ParseAssignmentExpression(true, CHECK_OK);
+  ExpressionT arg = ParseAssignmentExpression(nullptr, true, CHECK_OK); 
   Expect(Token::RPAREN, CHECK_OK);
   return factory()->NewImportCallExpression(arg, pos);
 }
@@ -3705,7 +3767,7 @@ ParserBase<Impl>::ParseNewTargetExpression(bool* ok) {
 
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT
-ParserBase<Impl>::ParseMemberExpressionContinuation(ExpressionT expression,
+ParserBase<Impl>::ParseMemberExpressionContinuation(ParseInfo* info, bool is_this, ExpressionT expression,
                                                     bool* is_async, bool* ok) {
   // Parses this part of MemberExpression:
   // ('[' Expression ']' | '.' Identifier | TemplateLiteral)*
@@ -3719,7 +3781,7 @@ ParserBase<Impl>::ParseMemberExpressionContinuation(ExpressionT expression,
 
         Consume(Token::LBRACK);
         int pos = position();
-        ExpressionT index = ParseExpressionCoverGrammar(true, CHECK_OK);
+        ExpressionT index = ParseExpressionCoverGrammar(info, true, CHECK_OK);
         ValidateExpression(CHECK_OK);
         expression = factory()->NewProperty(expression, index, pos);
         impl()->PushPropertyName(index);
@@ -3735,6 +3797,7 @@ ParserBase<Impl>::ParseMemberExpressionContinuation(ExpressionT expression,
         Consume(Token::PERIOD);
         int pos = peek_position();
         ExpressionT key = ParseIdentifierNameOrPrivateName(CHECK_OK);
+        
         expression = factory()->NewProperty(expression, key, pos);
         break;
       }
@@ -3755,7 +3818,7 @@ ParserBase<Impl>::ParseMemberExpressionContinuation(ExpressionT expression,
             expression->AsFunctionLiteral()->SetShouldEagerCompile();
           }
         }
-        expression = ParseTemplateLiteral(expression, pos, true, CHECK_OK);
+        expression = ParseTemplateLiteral(info, expression, pos, true, CHECK_OK);
         break;
       }
       case Token::ILLEGAL: {
@@ -3763,7 +3826,7 @@ ParserBase<Impl>::ParseMemberExpressionContinuation(ExpressionT expression,
         *ok = false;
         return impl()->NullExpression();
       }
-      default:
+      default: 
         return expression;
     }
   }
@@ -3772,14 +3835,14 @@ ParserBase<Impl>::ParseMemberExpressionContinuation(ExpressionT expression,
 }
 
 template <typename Impl>
-void ParserBase<Impl>::ParseFormalParameter(FormalParametersT* parameters,
+void ParserBase<Impl>::ParseFormalParameter(ParseInfo* info, FormalParametersT* parameters,
                                             bool* ok) {
   // FormalParameter[Yield,GeneratorParameter] :
   //   BindingElement[?Yield, ?GeneratorParameter]
   bool is_rest = parameters->has_rest;
 
   FuncNameInferrerState fni_state(&fni_);
-  ExpressionT pattern = ParseBindingPattern(CHECK_OK_CUSTOM(Void));
+  ExpressionT pattern = ParseBindingPattern(info, CHECK_OK_CUSTOM(Void));
   if (!impl()->IsIdentifier(pattern)) {
     parameters->is_simple = false;
     ValidateFormalParameterInitializer(CHECK_OK_CUSTOM(Void));
@@ -3793,22 +3856,24 @@ void ParserBase<Impl>::ParseFormalParameter(FormalParametersT* parameters,
       return;
     }
     ExpressionClassifier init_classifier(this);
-    initializer = ParseAssignmentExpression(true, CHECK_OK_CUSTOM(Void));
+    initializer = ParseAssignmentExpression(info, true, CHECK_OK_CUSTOM(Void));
     ValidateExpression(CHECK_OK_CUSTOM(Void));
     ValidateFormalParameterInitializer(CHECK_OK_CUSTOM(Void));
     parameters->is_simple = false;
     DiscardExpressionClassifier();
     classifier()->RecordNonSimpleParameter();
 
-    impl()->SetFunctionNameFromIdentifierRef(initializer, pattern);
+    impl()->SetFunctionNameFromIdentifierRef(info, initializer, pattern);
   }
 
+  impl()->appendDeclarationParam(parameters->scope, pattern, initializer, info);
+
   impl()->AddFormalParameter(parameters, pattern, initializer, end_position(),
                              is_rest);
 }
 
 template <typename Impl>
-void ParserBase<Impl>::ParseFormalParameterList(FormalParametersT* parameters,
+void ParserBase<Impl>::ParseFormalParameterList(ParseInfo* info, FormalParametersT* parameters,
                                                 bool* ok) {
   // FormalParameters[Yield] :
   //   [empty]
@@ -3831,7 +3896,7 @@ void ParserBase<Impl>::ParseFormalParameterList(FormalParametersT* parameters,
         return;
       }
       parameters->has_rest = Check(Token::ELLIPSIS);
-      ParseFormalParameter(parameters, CHECK_OK_CUSTOM(Void));
+      ParseFormalParameter(info, parameters, CHECK_OK_CUSTOM(Void));
 
       if (parameters->has_rest) {
         parameters->is_simple = false;
@@ -3858,7 +3923,7 @@ void ParserBase<Impl>::ParseFormalParameterList(FormalParametersT* parameters,
 
 template <typename Impl>
 typename ParserBase<Impl>::BlockT ParserBase<Impl>::ParseVariableDeclarations(
-    VariableDeclarationContext var_context,
+    ParseInfo* info, VariableDeclarationContext var_context,
     DeclarationParsingResult* parsing_result,
     ZonePtrList<const AstRawString>* names, bool* ok) {
   // VariableDeclarations ::
@@ -3909,7 +3974,7 @@ typename ParserBase<Impl>::BlockT ParserBase<Impl>::ParseVariableDeclarations(
     int decl_pos = peek_position();
     {
       ExpressionClassifier pattern_classifier(this);
-      pattern = ParseBindingPattern(CHECK_OK_CUSTOM(NullStatement));
+      pattern = ParseBindingPattern(info, CHECK_OK_CUSTOM(NullStatement));
 
       if (IsLexicalVariableMode(parsing_result->descriptor.mode)) {
         ValidateLetPattern(CHECK_OK_CUSTOM(NullStatement));
@@ -3929,8 +3994,8 @@ typename ParserBase<Impl>::BlockT ParserBase<Impl>::ParseVariableDeclarations(
       value_beg_position = peek_position();
 
       ExpressionClassifier classifier(this);
-      value = ParseAssignmentExpression(var_context != kForStatement,
-                                        CHECK_OK_CUSTOM(NullStatement));
+      value = ParseAssignmentExpression(info, var_context != kForStatement,
+                                        CHECK_OK_CUSTOM(NullStatement)); 
       ValidateExpression(CHECK_OK_CUSTOM(NullStatement));
       variable_loc.end_pos = end_position();
 
@@ -3939,7 +4004,7 @@ typename ParserBase<Impl>::BlockT ParserBase<Impl>::ParseVariableDeclarations(
       }
 
       // Don't infer if it is "a = function(){...}();"-like expression.
-      if (single_name) {
+      if (single_name) {        
         if (!value->IsCall() && !value->IsCallNew()) {
           fni_.Infer();
         } else {
@@ -3947,7 +4012,7 @@ typename ParserBase<Impl>::BlockT ParserBase<Impl>::ParseVariableDeclarations(
         }
       }
 
-      impl()->SetFunctionNameFromIdentifierRef(value, pattern);
+      impl()->SetFunctionNameFromIdentifierRef(info, value, pattern);
 
       // End position of the initializer is after the assignment expression.
       initializer_position = end_position();
@@ -3973,9 +4038,11 @@ typename ParserBase<Impl>::BlockT ParserBase<Impl>::ParseVariableDeclarations(
       initializer_position = position();
     }
 
+
     typename DeclarationParsingResult::Declaration decl(
         pattern, initializer_position, value);
     decl.value_beg_position = value_beg_position;
+
     if (var_context == kForStatement) {
       // Save the declaration for further handling in ParseForStatement.
       parsing_result->declarations.push_back(decl);
@@ -3988,6 +4055,10 @@ typename ParserBase<Impl>::BlockT ParserBase<Impl>::ParseVariableDeclarations(
           init_block, &parsing_result->descriptor, &decl, names,
           CHECK_OK_CUSTOM(NullStatement));
     }
+
+    if(info) {
+      impl()->appendDeclaration(pattern, info);
+    }
   } while (Check(Token::COMMA));
 
   parsing_result->bindings_loc =
@@ -3999,7 +4070,7 @@ typename ParserBase<Impl>::BlockT ParserBase<Impl>::ParseVariableDeclarations(
 
 template <typename Impl>
 typename ParserBase<Impl>::StatementT
-ParserBase<Impl>::ParseFunctionDeclaration(bool* ok) {
+ParserBase<Impl>::ParseFunctionDeclaration(ParseInfo* info, bool* ok) {
   Consume(Token::FUNCTION);
   int pos = position();
   ParseFunctionFlags flags = ParseFunctionFlag::kIsNormal;
@@ -4010,26 +4081,26 @@ ParserBase<Impl>::ParseFunctionDeclaration(bool* ok) {
     *ok = false;
     return impl()->NullStatement();
   }
-  return ParseHoistableDeclaration(pos, flags, nullptr, false, ok);
+  return ParseHoistableDeclaration(info, pos, flags, nullptr, false, ok);
 }
 
 template <typename Impl>
 typename ParserBase<Impl>::StatementT
 ParserBase<Impl>::ParseHoistableDeclaration(
-    ZonePtrList<const AstRawString>* names, bool default_export, bool* ok) {
+    ParseInfo* info, ZonePtrList<const AstRawString>* names, bool default_export, bool* ok) {
   Expect(Token::FUNCTION, CHECK_OK_CUSTOM(NullStatement));
   int pos = position();
   ParseFunctionFlags flags = ParseFunctionFlag::kIsNormal;
   if (Check(Token::MUL)) {
     flags |= ParseFunctionFlag::kIsGenerator;
   }
-  return ParseHoistableDeclaration(pos, flags, names, default_export, ok);
+  return ParseHoistableDeclaration(info, pos, flags, names, default_export, ok);
 }
 
 template <typename Impl>
 typename ParserBase<Impl>::StatementT
 ParserBase<Impl>::ParseHoistableDeclaration(
-    int pos, ParseFunctionFlags flags, ZonePtrList<const AstRawString>* names,
+    ParseInfo* info, int pos, ParseFunctionFlags flags, ZonePtrList<const AstRawString>* names,
     bool default_export, bool* ok) {
   // FunctionDeclaration ::
   //   'function' Identifier '(' FormalParameters ')' '{' FunctionBody '}'
@@ -4072,7 +4143,7 @@ ParserBase<Impl>::ParseHoistableDeclaration(
   FunctionKind kind = FunctionKindFor(flags);
 
   FunctionLiteralT function = impl()->ParseFunctionLiteral(
-      name, scanner()->location(), name_validity, kind, pos,
+      info, name, scanner()->location(), name_validity, kind, pos,
       FunctionLiteral::kDeclaration, language_mode(), nullptr,
       CHECK_OK_CUSTOM(NullStatement));
 
@@ -4091,8 +4162,9 @@ ParserBase<Impl>::ParseHoistableDeclaration(
                                   !scope()->is_declaration_scope() &&
                                   flags == ParseFunctionFlag::kIsNormal;
 
+  declared_functions.push_back(impl()->ConvertIdentifierToString(variable_name));
   return impl()->DeclareFunction(variable_name, function, mode, pos,
-                                 is_sloppy_block_function, names, ok);
+                                 is_sloppy_block_function, names, ok, info);
 }
 
 template <typename Impl>
@@ -4167,7 +4239,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseNativeDeclaration(
 template <typename Impl>
 typename ParserBase<Impl>::StatementT
 ParserBase<Impl>::ParseAsyncFunctionDeclaration(
-    ZonePtrList<const AstRawString>* names, bool default_export, bool* ok) {
+    ParseInfo* info, ZonePtrList<const AstRawString>* names, bool default_export, bool* ok) {
   // AsyncFunctionDeclaration ::
   //   async [no LineTerminator here] function BindingIdentifier[Await]
   //       ( FormalParameters[Await] ) { AsyncFunctionBody }
@@ -4180,12 +4252,12 @@ ParserBase<Impl>::ParseAsyncFunctionDeclaration(
   }
   Expect(Token::FUNCTION, CHECK_OK_CUSTOM(NullStatement));
   ParseFunctionFlags flags = ParseFunctionFlag::kIsAsync;
-  return ParseHoistableDeclaration(pos, flags, names, default_export, ok);
+  return ParseHoistableDeclaration(info, pos, flags, names, default_export, ok);
 }
 
 template <typename Impl>
 void ParserBase<Impl>::ParseFunctionBody(
-    typename ParserBase<Impl>::StatementListT result, IdentifierT function_name,
+    ParseInfo* info, typename ParserBase<Impl>::StatementListT result, IdentifierT function_name,
     int pos, const FormalParametersT& parameters, FunctionKind kind,
     FunctionLiteral::FunctionType function_type, FunctionBodyType body_type,
     bool accept_IN, bool* ok) {
@@ -4210,7 +4282,7 @@ void ParserBase<Impl>::ParseFunctionBody(
     if (body_type == FunctionBodyType::kExpression) {
       ExpressionClassifier classifier(this);
       ExpressionT expression =
-          ParseAssignmentExpression(accept_IN, CHECK_OK_VOID);
+          ParseAssignmentExpression(info, accept_IN, CHECK_OK_VOID);
       ValidateExpression(CHECK_OK_VOID);
 
       if (IsAsyncFunction(kind)) {
@@ -4231,20 +4303,21 @@ void ParserBase<Impl>::ParseFunctionBody(
                                        : Token::RBRACE;
 
       if (IsAsyncGeneratorFunction(kind)) {
-        impl()->ParseAndRewriteAsyncGeneratorFunctionBody(pos, kind, body,
+        impl()->ParseAndRewriteAsyncGeneratorFunctionBody(info, pos, kind, body,
                                                           CHECK_OK_VOID);
       } else if (IsGeneratorFunction(kind)) {
-        impl()->ParseAndRewriteGeneratorFunctionBody(pos, kind, body,
+        impl()->ParseAndRewriteGeneratorFunctionBody(info, pos, kind, body,
                                                      CHECK_OK_VOID);
       } else if (IsAsyncFunction(kind)) {
-        ParseAsyncFunctionBody(inner_scope, body, CHECK_OK_VOID);
+        ParseAsyncFunctionBody(info, inner_scope, body, CHECK_OK_VOID);
       } else {
-        ParseStatementList(body, closing_token, CHECK_OK_VOID);
+        ParseStatementList(info, body, closing_token, info, CHECK_OK_VOID);
       }
 
       if (IsDerivedConstructor(kind)) {
-        body->Add(factory()->NewReturnStatement(impl()->ThisExpression(),
-                                                kNoSourcePosition),
+        StatementT return_statement = factory()->NewReturnStatement(impl()->ThisExpression(), kNoSourcePosition);
+        impl()->SetTempVarForStatement(return_statement, true);
+        body->Add(return_statement,
                   zone());
       }
       Expect(closing_token, CHECK_OK_VOID);
@@ -4370,7 +4443,7 @@ bool ParserBase<Impl>::IsTrivialExpression() {
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT
 ParserBase<Impl>::ParseArrowFunctionLiteral(
-    bool accept_IN, const FormalParametersT& formal_parameters,
+    ParseInfo* info, bool accept_IN, const FormalParametersT& formal_parameters,
     int rewritable_length, bool* ok) {
   const RuntimeCallCounterId counters[2][2] = {
       {RuntimeCallCounterId::kParseBackgroundArrowFunctionLiteral,
@@ -4449,7 +4522,7 @@ ParserBase<Impl>::ParseArrowFunctionLiteral(
           // unidentified error we do a full reparse to return the error.
           Consume(Token::LBRACE);
           body = impl()->NewStatementList(8);
-          ParseFunctionBody(body, impl()->NullIdentifier(), kNoSourcePosition,
+          ParseFunctionBody(info, body, impl()->NullIdentifier(), kNoSourcePosition,
                             formal_parameters, kind,
                             FunctionLiteral::kAnonymousExpression,
                             FunctionBodyType::kBlock, true, ok);
@@ -4459,7 +4532,7 @@ ParserBase<Impl>::ParseArrowFunctionLiteral(
       } else {
         Consume(Token::LBRACE);
         body = impl()->NewStatementList(8);
-        ParseFunctionBody(body, impl()->NullIdentifier(), kNoSourcePosition,
+        ParseFunctionBody(info, body, impl()->NullIdentifier(), kNoSourcePosition,
                           formal_parameters, kind,
                           FunctionLiteral::kAnonymousExpression,
                           FunctionBodyType::kBlock, true, CHECK_OK);
@@ -4469,7 +4542,7 @@ ParserBase<Impl>::ParseArrowFunctionLiteral(
       // Single-expression body
       has_braces = false;
       body = impl()->NewStatementList(1);
-      ParseFunctionBody(body, impl()->NullIdentifier(), kNoSourcePosition,
+      ParseFunctionBody(info, body, impl()->NullIdentifier(), kNoSourcePosition,
                         formal_parameters, kind,
                         FunctionLiteral::kAnonymousExpression,
                         FunctionBodyType::kExpression, accept_IN, CHECK_OK);
@@ -4505,10 +4578,14 @@ ParserBase<Impl>::ParseArrowFunctionLiteral(
       FunctionLiteral::kAnonymousExpression, eager_compile_hint,
       formal_parameters.scope->start_position(), has_braces,
       function_literal_id, produced_preparsed_scope_data);
+ 
+  impl()->DeclareWindowAsUnresolved(function_literal);
 
   function_literal->set_suspend_count(suspend_count);
   function_literal->set_function_token_position(
       formal_parameters.scope->start_position());
+  
+  impl()->SetFunctionID(function_literal, ++functionID);
 
   impl()->AddFunctionForNameInference(function_literal);
 
@@ -4559,7 +4636,7 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseClassLiteral(
   if (Check(Token::EXTENDS)) {
     FuncNameInferrerState fni_state(&fni_);
     ExpressionClassifier extends_classifier(this);
-    class_info.extends = ParseLeftHandSideExpression(CHECK_OK);
+    class_info.extends = ParseLeftHandSideExpression(nullptr, CHECK_OK); 
     ValidateExpression(CHECK_OK);
     AccumulateFormalParameterContainmentErrors();
   }
@@ -4610,11 +4687,11 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseClassLiteral(
 }
 
 template <typename Impl>
-void ParserBase<Impl>::ParseAsyncFunctionBody(Scope* scope, StatementListT body,
+void ParserBase<Impl>::ParseAsyncFunctionBody(ParseInfo* info, Scope* scope, StatementListT body,
                                               bool* ok) {
   BlockT block = factory()->NewBlock(8, true);
 
-  ParseStatementList(block->statements(), Token::RBRACE, CHECK_OK_VOID);
+  ParseStatementList(info, block->statements(), Token::RBRACE, CHECK_OK_VOID);
   impl()->RewriteAsyncFunctionBody(
       body, block, factory()->NewUndefinedLiteral(kNoSourcePosition),
       CHECK_OK_VOID);
@@ -4623,7 +4700,7 @@ void ParserBase<Impl>::ParseAsyncFunctionBody(Scope* scope, StatementListT body,
 
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT
-ParserBase<Impl>::ParseAsyncFunctionLiteral(bool* ok) {
+ParserBase<Impl>::ParseAsyncFunctionLiteral(ParseInfo* info, bool* ok) {
   // AsyncFunctionLiteral ::
   //   async [no LineTerminator here] function ( FormalParameters[Await] )
   //       { AsyncFunctionBody }
@@ -4659,8 +4736,9 @@ ParserBase<Impl>::ParseAsyncFunctionLiteral(bool* ok) {
     // recognized the error.
     DCHECK(!is_await);
   }
+
   return impl()->ParseFunctionLiteral(
-      name, scanner()->location(),
+      info, name, scanner()->location(),
       is_strict_reserved ? kFunctionNameIsStrictReserved
                          : kFunctionNameValidityUnknown,
       kind, pos, type, language_mode(), nullptr, ok);
@@ -4668,7 +4746,7 @@ ParserBase<Impl>::ParseAsyncFunctionLiteral(bool* ok) {
 
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseTemplateLiteral(
-    ExpressionT tag, int start, bool tagged, bool* ok) {
+    ParseInfo* info, ExpressionT tag, int start, bool tagged, bool* ok) {
   // A TemplateLiteral is made up of 0 or more TEMPLATE_SPAN tokens (literal
   // text followed by a substitution expression), finalized by a single
   // TEMPLATE_TAIL.
@@ -4728,7 +4806,7 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseTemplateLiteral(
     }
 
     int expr_pos = peek_position();
-    ExpressionT expression = ParseExpressionCoverGrammar(true, CHECK_OK);
+    ExpressionT expression = ParseExpressionCoverGrammar(info, true, CHECK_OK);
     ValidateExpression(CHECK_OK);
     impl()->AddTemplateExpression(&ts, expression);
 
@@ -4825,7 +4903,7 @@ void ParserBase<Impl>::CheckDestructuringElement(ExpressionT expression,
 
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseV8Intrinsic(
-    bool* ok) {
+    ParseInfo* info, bool* ok) {
   // CallRuntime ::
   //   '%' Identifier Arguments
 
@@ -4835,7 +4913,7 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseV8Intrinsic(
   IdentifierT name = ParseIdentifier(kAllowRestrictedIdentifiers, CHECK_OK);
   Scanner::Location spread_pos;
   ExpressionClassifier classifier(this);
-  ExpressionListT args = ParseArguments(&spread_pos, CHECK_OK);
+  ExpressionListT args = ParseArguments(info, &spread_pos, CHECK_OK);
 
   if (spread_pos.IsValid()) {
     *ok = false;
@@ -4849,13 +4927,13 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseV8Intrinsic(
 
 template <typename Impl>
 typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseDoExpression(
-    bool* ok) {
+     ParseInfo* info, bool* ok) {
   // AssignmentExpression ::
   //     do '{' StatementList '}'
 
   int pos = peek_position();
   Expect(Token::DO, CHECK_OK);
-  BlockT block = ParseBlock(nullptr, CHECK_OK);
+  BlockT block = ParseBlock(info, nullptr, CHECK_OK);
   return impl()->RewriteDoExpression(block, pos, ok);
 }
 
@@ -4865,7 +4943,7 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseDoExpression(
 
 template <typename Impl>
 typename ParserBase<Impl>::LazyParsingResult
-ParserBase<Impl>::ParseStatementList(StatementListT body,
+ParserBase<Impl>::ParseStatementList(ParseInfo* info, StatementListT body,
                                      Token::Value end_token, bool may_abort,
                                      bool* ok) {
   // StatementList ::
@@ -4888,8 +4966,9 @@ ParserBase<Impl>::ParseStatementList(StatementListT body,
 
     bool starts_with_identifier = peek() == Token::IDENTIFIER;
     Scanner::Location token_loc = scanner()->peek_location();
+
     StatementT stat =
-        ParseStatementListItem(CHECK_OK_CUSTOM(Return, kLazyParsingComplete));
+        ParseStatementListItem(info, CHECK_OK_CUSTOM(Return, kLazyParsingComplete));
 
     if (impl()->IsNull(stat) || stat->IsEmptyStatement()) {
       directive_prologue = false;  // End of directive prologue.
@@ -4913,6 +4992,7 @@ ParserBase<Impl>::ParseStatementList(StatementListT body,
               token_loc, MessageTemplate::kIllegalLanguageModeDirective,
               "use strict");
           *ok = false;
+
           return kLazyParsingComplete;
         }
       } else if (impl()->IsUseAsmDirective(stat) &&
@@ -4942,18 +5022,20 @@ ParserBase<Impl>::ParseStatementList(StatementListT body,
       if (!starts_with_identifier) {
         may_abort = false;
       } else if (++count_statements > kLazyParseTrialLimit) {
+
         return kLazyParsingAborted;
       }
     }
 
     body->Add(stat, zone());
   }
+
   return kLazyParsingComplete;
 }
 
 template <typename Impl>
 typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseStatementListItem(
-    bool* ok) {
+    ParseInfo* info, bool* ok) {
   // ECMA 262 6th Edition
   // StatementListItem[Yield, Return] :
   //   Statement[?Yield, ?Return]
@@ -4973,34 +5055,34 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseStatementListItem(
 
   switch (peek()) {
     case Token::FUNCTION:
-      return ParseHoistableDeclaration(nullptr, false, ok);
+      return ParseHoistableDeclaration(info, nullptr, false, ok);
     case Token::CLASS:
       Consume(Token::CLASS);
       return ParseClassDeclaration(nullptr, false, ok);
     case Token::VAR:
     case Token::CONST:
-      return ParseVariableStatement(kStatementListItem, nullptr, ok);
+      return ParseVariableStatement(info, kStatementListItem, nullptr, ok);
     case Token::LET:
       if (IsNextLetKeyword()) {
-        return ParseVariableStatement(kStatementListItem, nullptr, ok);
+        return ParseVariableStatement(info, kStatementListItem, nullptr, ok);
       }
       break;
     case Token::ASYNC:
       if (PeekAhead() == Token::FUNCTION &&
           !scanner()->HasLineTerminatorAfterNext()) {
         Consume(Token::ASYNC);
-        return ParseAsyncFunctionDeclaration(nullptr, false, ok);
+        return ParseAsyncFunctionDeclaration(info, nullptr, false, ok);
       }
       break;
     default:
       break;
   }
-  return ParseStatement(nullptr, nullptr, kAllowLabelledFunctionStatement, ok);
+  return ParseStatement(info, nullptr, nullptr, kAllowLabelledFunctionStatement, ok);
 }
 
 template <typename Impl>
 typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseStatement(
-    ZonePtrList<const AstRawString>* labels,
+    ParseInfo* info, ZonePtrList<const AstRawString>* labels,
     ZonePtrList<const AstRawString>* own_labels,
     AllowLabelledFunctionStatement allow_function, bool* ok) {
   // Statement ::
@@ -5031,46 +5113,46 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseStatement(
   // parsed into an empty statement.
   switch (peek()) {
     case Token::LBRACE:
-      return ParseBlock(labels, ok);
+      return ParseBlock(info, labels, ok);
     case Token::SEMICOLON:
       Next();
       return factory()->NewEmptyStatement(kNoSourcePosition);
     case Token::IF:
-      return ParseIfStatement(labels, ok);
+      return ParseIfStatement(info, labels, ok);
     case Token::DO:
-      return ParseDoWhileStatement(labels, own_labels, ok);
+      return ParseDoWhileStatement(info, labels, own_labels, ok);
     case Token::WHILE:
-      return ParseWhileStatement(labels, own_labels, ok);
+      return ParseWhileStatement(info, labels, own_labels, ok);
     case Token::FOR:
       if (V8_UNLIKELY(is_async_function() && PeekAhead() == Token::AWAIT)) {
-        return ParseForAwaitStatement(labels, own_labels, ok);
+        return ParseForAwaitStatement(info, labels, own_labels, ok);
       }
-      return ParseForStatement(labels, own_labels, ok);
+      return ParseForStatement(info, labels, own_labels, ok);
     case Token::CONTINUE:
       return ParseContinueStatement(ok);
     case Token::BREAK:
       return ParseBreakStatement(labels, ok);
     case Token::RETURN:
-      return ParseReturnStatement(ok);
+      return ParseReturnStatement(info, ok);
     case Token::THROW:
-      return ParseThrowStatement(ok);
+      return ParseThrowStatement(info, ok);
     case Token::TRY: {
       // It is somewhat complicated to have labels on try-statements.
       // When breaking out of a try-finally statement, one must take
       // great care not to treat it as a fall-through. It is much easier
       // just to wrap the entire try-statement in a statement block and
       // put the labels there.
-      if (labels == nullptr) return ParseTryStatement(ok);
+      if (labels == nullptr) return ParseTryStatement(info, ok);
       BlockT result = factory()->NewBlock(1, false, labels);
       typename Types::Target target(this, result);
-      StatementT statement = ParseTryStatement(CHECK_OK);
+      StatementT statement = ParseTryStatement(info, CHECK_OK);
       result->statements()->Add(statement, zone());
       return result;
     }
     case Token::WITH:
-      return ParseWithStatement(labels, ok);
+      return ParseWithStatement(info, labels, ok);
     case Token::SWITCH:
-      return ParseSwitchStatement(labels, ok);
+      return ParseSwitchStatement(info, labels, ok);
     case Token::FUNCTION:
       // FunctionDeclaration only allowed as a StatementListItem, not in
       // an arbitrary Statement position. Exceptions such as
@@ -5086,7 +5168,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseStatement(
     case Token::DEBUGGER:
       return ParseDebuggerStatement(ok);
     case Token::VAR:
-      return ParseVariableStatement(kStatement, nullptr, ok);
+      return ParseVariableStatement(info, kStatement, nullptr, ok);
     case Token::ASYNC:
       if (!scanner()->HasLineTerminatorAfterNext() &&
           PeekAhead() == Token::FUNCTION) {
@@ -5098,14 +5180,14 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseStatement(
       }
       V8_FALLTHROUGH;
     default:
-      return ParseExpressionOrLabelledStatement(labels, own_labels,
+      return ParseExpressionOrLabelledStatement(info, labels, own_labels,
                                                 allow_function, ok);
   }
 }
 
 template <typename Impl>
 typename ParserBase<Impl>::BlockT ParserBase<Impl>::ParseBlock(
-    ZonePtrList<const AstRawString>* labels, bool* ok) {
+    ParseInfo* info, ZonePtrList<const AstRawString>* labels, bool* ok) {
   // Block ::
   //   '{' StatementList '}'
 
@@ -5121,7 +5203,7 @@ typename ParserBase<Impl>::BlockT ParserBase<Impl>::ParseBlock(
     typename Types::Target target(this, body);
 
     while (peek() != Token::RBRACE) {
-      StatementT stat = ParseStatementListItem(CHECK_OK_CUSTOM(NullStatement));
+      StatementT stat = ParseStatementListItem(info, CHECK_OK_CUSTOM(NullStatement));
       if (!impl()->IsNull(stat) && !stat->IsEmptyStatement()) {
         body->statements()->Add(stat, zone());
       }
@@ -5139,16 +5221,16 @@ typename ParserBase<Impl>::BlockT ParserBase<Impl>::ParseBlock(
 
 template <typename Impl>
 typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseScopedStatement(
-    ZonePtrList<const AstRawString>* labels, bool* ok) {
+     ParseInfo* info, ZonePtrList<const AstRawString>* labels, bool* ok) {
   if (is_strict(language_mode()) || peek() != Token::FUNCTION) {
-    return ParseStatement(labels, nullptr, ok);
+    return ParseStatement(info, labels, nullptr, ok);
   } else {
     // Make a block around the statement for a lexical binding
     // is introduced by a FunctionDeclaration.
     BlockState block_state(zone(), &scope_);
     scope()->set_start_position(scanner()->location().beg_pos);
     BlockT block = factory()->NewBlock(1, false);
-    StatementT body = ParseFunctionDeclaration(CHECK_OK);
+    StatementT body = ParseFunctionDeclaration(info, CHECK_OK);
     block->statements()->Add(body, zone());
     scope()->set_end_position(end_position());
     block->set_scope(scope()->FinalizeBlockScope());
@@ -5158,7 +5240,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseScopedStatement(
 
 template <typename Impl>
 typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseVariableStatement(
-    VariableDeclarationContext var_context,
+    ParseInfo* info, VariableDeclarationContext var_context,
     ZonePtrList<const AstRawString>* names, bool* ok) {
   // VariableStatement ::
   //   VariableDeclarations ';'
@@ -5177,7 +5259,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseVariableStatement(
 
   DeclarationParsingResult parsing_result;
   StatementT result =
-      ParseVariableDeclarations(var_context, &parsing_result, names, CHECK_OK);
+      ParseVariableDeclarations(info, var_context, &parsing_result, names, CHECK_OK);
   ExpectSemicolon(ok);
   return result;
 }
@@ -5200,7 +5282,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseDebuggerStatement(
 template <typename Impl>
 typename ParserBase<Impl>::StatementT
 ParserBase<Impl>::ParseExpressionOrLabelledStatement(
-    ZonePtrList<const AstRawString>* labels,
+    ParseInfo* info, ZonePtrList<const AstRawString>* labels,
     ZonePtrList<const AstRawString>* own_labels,
     AllowLabelledFunctionStatement allow_function, bool* ok) {
   // ExpressionStatement | LabelledStatement ::
@@ -5240,7 +5322,8 @@ ParserBase<Impl>::ParseExpressionOrLabelledStatement(
   }
 
   bool starts_with_identifier = peek_any_identifier();
-  ExpressionT expr = ParseExpression(CHECK_OK);
+  ExpressionT expr = ParseExpression(info, CHECK_OK);
+
   if (peek() == Token::COLON && starts_with_identifier &&
       impl()->IsIdentifier(expr)) {
     // The whole expression was a single identifier, and not, e.g.,
@@ -5251,11 +5334,10 @@ ParserBase<Impl>::ParseExpressionOrLabelledStatement(
     // ES#sec-labelled-function-declarations Labelled Function Declarations
     if (peek() == Token::FUNCTION && is_sloppy(language_mode()) &&
         allow_function == kAllowLabelledFunctionStatement) {
-      return ParseFunctionDeclaration(ok);
+      return ParseFunctionDeclaration(info, ok);
     }
-    return ParseStatement(labels, own_labels, allow_function, ok);
+    return ParseStatement(info, labels, own_labels, allow_function, ok);
   }
-
   // If we have an extension, we allow a native function declaration.
   // A native function declaration starts with "native function" with
   // no line-terminator between the two words.
@@ -5272,26 +5354,26 @@ ParserBase<Impl>::ParseExpressionOrLabelledStatement(
 
 template <typename Impl>
 typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseIfStatement(
-    ZonePtrList<const AstRawString>* labels, bool* ok) {
+    ParseInfo* info, ZonePtrList<const AstRawString>* labels, bool* ok) {
   // IfStatement ::
   //   'if' '(' Expression ')' Statement ('else' Statement)?
 
   int pos = peek_position();
   Expect(Token::IF, CHECK_OK);
   Expect(Token::LPAREN, CHECK_OK);
-  ExpressionT condition = ParseExpression(CHECK_OK);
+  ExpressionT condition = ParseExpression(info, CHECK_OK);
   Expect(Token::RPAREN, CHECK_OK);
 
   SourceRange then_range, else_range;
   StatementT then_statement = impl()->NullStatement();
   {
     SourceRangeScope range_scope(scanner(), &then_range);
-    then_statement = ParseScopedStatement(labels, CHECK_OK);
+    then_statement = ParseScopedStatement(info, labels, CHECK_OK);
   }
 
   StatementT else_statement = impl()->NullStatement();
   if (Check(Token::ELSE)) {
-    else_statement = ParseScopedStatement(labels, CHECK_OK);
+    else_statement = ParseScopedStatement(info, labels, CHECK_OK);
     else_range = SourceRange::ContinuationOf(then_range, end_position());
   } else {
     else_statement = factory()->NewEmptyStatement(kNoSourcePosition);
@@ -5380,7 +5462,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseBreakStatement(
 
 template <typename Impl>
 typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseReturnStatement(
-    bool* ok) {
+    ParseInfo* info, bool* ok) {
   // ReturnStatement ::
   //   'return' [no line terminator] Expression? ';'
 
@@ -5409,7 +5491,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseReturnStatement(
       return_value = impl()->ThisExpression(loc.beg_pos);
     }
   } else {
-    return_value = ParseExpression(CHECK_OK);
+    return_value = ParseExpression(info, CHECK_OK);
   }
   ExpectSemicolon(CHECK_OK);
   return_value = impl()->RewriteReturn(return_value, loc.beg_pos);
@@ -5422,7 +5504,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseReturnStatement(
 
 template <typename Impl>
 typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseWithStatement(
-    ZonePtrList<const AstRawString>* labels, bool* ok) {
+    ParseInfo* info, ZonePtrList<const AstRawString>* labels, bool* ok) {
   // WithStatement ::
   //   'with' '(' Expression ')' Statement
 
@@ -5436,7 +5518,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseWithStatement(
   }
 
   Expect(Token::LPAREN, CHECK_OK);
-  ExpressionT expr = ParseExpression(CHECK_OK);
+  ExpressionT expr = ParseExpression(info, CHECK_OK);
   Expect(Token::RPAREN, CHECK_OK);
 
   Scope* with_scope = NewScope(WITH_SCOPE);
@@ -5444,7 +5526,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseWithStatement(
   {
     BlockState block_state(&scope_, with_scope);
     with_scope->set_start_position(scanner()->peek_location().beg_pos);
-    body = ParseStatement(labels, nullptr, CHECK_OK);
+    body = ParseStatement(info, labels, nullptr, CHECK_OK);
     with_scope->set_end_position(end_position());
   }
   return factory()->NewWithStatement(with_scope, expr, body, pos);
@@ -5452,7 +5534,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseWithStatement(
 
 template <typename Impl>
 typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseDoWhileStatement(
-    ZonePtrList<const AstRawString>* labels,
+    ParseInfo* info, ZonePtrList<const AstRawString>* labels,
     ZonePtrList<const AstRawString>* own_labels, bool* ok) {
   // DoStatement ::
   //   'do' Statement 'while' '(' Expression ')' ';'
@@ -5467,12 +5549,12 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseDoWhileStatement(
   Expect(Token::DO, CHECK_OK);
   {
     SourceRangeScope range_scope(scanner(), &body_range);
-    body = ParseStatement(nullptr, nullptr, CHECK_OK);
+    body = ParseStatement(info, nullptr, nullptr, CHECK_OK);
   }
   Expect(Token::WHILE, CHECK_OK);
   Expect(Token::LPAREN, CHECK_OK);
 
-  ExpressionT cond = ParseExpression(CHECK_OK);
+  ExpressionT cond = ParseExpression(info, CHECK_OK);
   Expect(Token::RPAREN, CHECK_OK);
 
   // Allow do-statements to be terminated with and without
@@ -5489,7 +5571,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseDoWhileStatement(
 
 template <typename Impl>
 typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseWhileStatement(
-    ZonePtrList<const AstRawString>* labels,
+    ParseInfo* info, ZonePtrList<const AstRawString>* labels,
     ZonePtrList<const AstRawString>* own_labels, bool* ok) {
   // WhileStatement ::
   //   'while' '(' Expression ')' Statement
@@ -5502,11 +5584,11 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseWhileStatement(
 
   Expect(Token::WHILE, CHECK_OK);
   Expect(Token::LPAREN, CHECK_OK);
-  ExpressionT cond = ParseExpression(CHECK_OK);
+  ExpressionT cond = ParseExpression(info, CHECK_OK);
   Expect(Token::RPAREN, CHECK_OK);
   {
     SourceRangeScope range_scope(scanner(), &body_range);
-    body = ParseStatement(nullptr, nullptr, CHECK_OK);
+    body = ParseStatement(info, nullptr, nullptr, CHECK_OK);
   }
 
   loop->Initialize(cond, body);
@@ -5517,7 +5599,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseWhileStatement(
 
 template <typename Impl>
 typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseThrowStatement(
-    bool* ok) {
+    ParseInfo* info, bool* ok) {
   // ThrowStatement ::
   //   'throw' Expression ';'
 
@@ -5528,7 +5610,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseThrowStatement(
     *ok = false;
     return impl()->NullStatement();
   }
-  ExpressionT exception = ParseExpression(CHECK_OK);
+  ExpressionT exception = ParseExpression(info, CHECK_OK);
   ExpectSemicolon(CHECK_OK);
 
   StatementT stmt = impl()->NewThrowStatement(exception, pos);
@@ -5539,7 +5621,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseThrowStatement(
 
 template <typename Impl>
 typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseSwitchStatement(
-    ZonePtrList<const AstRawString>* labels, bool* ok) {
+    ParseInfo* info, ZonePtrList<const AstRawString>* labels, bool* ok) {
   // SwitchStatement ::
   //   'switch' '(' Expression ')' '{' CaseClause* '}'
   // CaseClause ::
@@ -5550,7 +5632,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseSwitchStatement(
 
   Expect(Token::SWITCH, CHECK_OK);
   Expect(Token::LPAREN, CHECK_OK);
-  ExpressionT tag = ParseExpression(CHECK_OK);
+  ExpressionT tag = ParseExpression(info, CHECK_OK);
   Expect(Token::RPAREN, CHECK_OK);
 
   auto switch_statement =
@@ -5570,7 +5652,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseSwitchStatement(
       SourceRange clause_range;
       SourceRangeScope range_scope(scanner(), &clause_range);
       if (Check(Token::CASE)) {
-        label = ParseExpression(CHECK_OK);
+        label = ParseExpression(info, CHECK_OK);
       } else {
         Expect(Token::DEFAULT, CHECK_OK);
         if (default_seen) {
@@ -5584,7 +5666,8 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseSwitchStatement(
       StatementListT statements = impl()->NewStatementList(5);
       while (peek() != Token::CASE && peek() != Token::DEFAULT &&
              peek() != Token::RBRACE) {
-        StatementT stat = ParseStatementListItem(CHECK_OK);
+
+        StatementT stat = ParseStatementListItem(info, CHECK_OK);
         statements->Add(stat, zone());
       }
       auto clause = factory()->NewCaseClause(label, statements);
@@ -5606,7 +5689,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseSwitchStatement(
 
 template <typename Impl>
 typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseTryStatement(
-    bool* ok) {
+    ParseInfo* info, bool* ok) {
   // TryStatement ::
   //   'try' Block Catch
   //   'try' Block Finally
@@ -5621,7 +5704,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseTryStatement(
   Expect(Token::TRY, CHECK_OK);
   int pos = position();
 
-  BlockT try_block = ParseBlock(nullptr, CHECK_OK);
+  BlockT try_block = ParseBlock(info, nullptr, CHECK_OK);
 
   CatchInfo catch_info(this);
 
@@ -5664,7 +5747,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseTryStatement(
                   ParseIdentifier(kDontAllowRestrictedIdentifiers, CHECK_OK);
             } else {
               ExpressionClassifier pattern_classifier(this);
-              catch_info.pattern = ParseBindingPattern(CHECK_OK);
+              catch_info.pattern = ParseBindingPattern(info, CHECK_OK);
             }
 
             Expect(Token::RPAREN, CHECK_OK);
@@ -5673,7 +5756,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseTryStatement(
               catch_block->statements()->Add(catch_info.init_block, zone());
             }
 
-            catch_info.inner_block = ParseBlock(nullptr, CHECK_OK);
+            catch_info.inner_block = ParseBlock(info, nullptr, CHECK_OK);
             catch_block->statements()->Add(catch_info.inner_block, zone());
             impl()->ValidateCatchBlock(catch_info, CHECK_OK);
             scope()->set_end_position(end_position());
@@ -5683,7 +5766,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseTryStatement(
 
         catch_info.scope->set_end_position(end_position());
       } else {
-        catch_block = ParseBlock(nullptr, CHECK_OK);
+        catch_block = ParseBlock(info, nullptr, CHECK_OK);
       }
     }
   }
@@ -5693,7 +5776,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseTryStatement(
   {
     SourceRangeScope range_scope(scanner(), &finally_range);
     if (Check(Token::FINALLY)) {
-      finally_block = ParseBlock(nullptr, CHECK_OK);
+      finally_block = ParseBlock(info, nullptr, CHECK_OK);
     }
   }
 
@@ -5704,7 +5787,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseTryStatement(
 
 template <typename Impl>
 typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseForStatement(
-    ZonePtrList<const AstRawString>* labels,
+    ParseInfo* info, ZonePtrList<const AstRawString>* labels,
     ZonePtrList<const AstRawString>* own_labels, bool* ok) {
   // Either a standard for loop
   //   for (<init>; <cond>; <next>) { ... }
@@ -5737,7 +5820,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseForStatement(
     Scope* inner_block_scope = NewScope(BLOCK_SCOPE);
     {
       BlockState inner_state(&scope_, inner_block_scope);
-      ParseVariableDeclarations(kForStatement, &for_info.parsing_result,
+      ParseVariableDeclarations(info, kForStatement, &for_info.parsing_result,
                                 nullptr, CHECK_OK);
     }
     DCHECK(IsLexicalVariableMode(for_info.parsing_result.descriptor.mode));
@@ -5746,7 +5829,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseForStatement(
     if (CheckInOrOf(&for_info.mode)) {
       scope()->set_is_hidden();
       return ParseForEachStatementWithDeclarations(
-          stmt_pos, &for_info, labels, own_labels, inner_block_scope, ok);
+          info, stmt_pos, &for_info, labels, own_labels, inner_block_scope, ok);
     }
 
     Expect(Token::SEMICOLON, CHECK_OK);
@@ -5759,18 +5842,18 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseForStatement(
     DCHECK_NULL(finalized);
     USE(finalized);
     return ParseStandardForLoopWithLexicalDeclarations(
-        stmt_pos, init, &for_info, labels, own_labels, ok);
+        info, stmt_pos, init, &for_info, labels, own_labels, ok);
   }
 
   StatementT init = impl()->NullStatement();
   if (peek() == Token::VAR) {
-    ParseVariableDeclarations(kForStatement, &for_info.parsing_result, nullptr,
+    ParseVariableDeclarations(info, kForStatement, &for_info.parsing_result, nullptr,
                               CHECK_OK);
     DCHECK_EQ(for_info.parsing_result.descriptor.mode, VariableMode::kVar);
     for_info.position = scanner()->location().beg_pos;
 
     if (CheckInOrOf(&for_info.mode)) {
-      return ParseForEachStatementWithDeclarations(stmt_pos, &for_info, labels,
+      return ParseForEachStatementWithDeclarations(info, stmt_pos, &for_info, labels,
                                                    own_labels, nullptr, ok);
     }
 
@@ -5780,7 +5863,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseForStatement(
     // The initializer does not contain declarations.
     int lhs_beg_pos = peek_position();
     ExpressionClassifier classifier(this);
-    ExpressionT expression = ParseExpressionCoverGrammar(false, CHECK_OK);
+    ExpressionT expression = ParseExpressionCoverGrammar(info, false, CHECK_OK);
     int lhs_end_pos = end_position();
 
     bool is_for_each = CheckInOrOf(&for_info.mode);
@@ -5795,7 +5878,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseForStatement(
 
     if (is_for_each) {
       return ParseForEachStatementWithoutDeclarations(
-          stmt_pos, expression, lhs_beg_pos, lhs_end_pos, &for_info, labels,
+          info, stmt_pos, expression, lhs_beg_pos, lhs_end_pos, &for_info, labels,
           own_labels, ok);
     }
     // Initializer is just an expression.
@@ -5808,7 +5891,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseForStatement(
   ExpressionT cond = impl()->NullExpression();
   StatementT next = impl()->NullStatement();
   StatementT body = impl()->NullStatement();
-  ForStatementT loop = ParseStandardForLoop(stmt_pos, labels, own_labels, &cond,
+  ForStatementT loop = ParseStandardForLoop(info, stmt_pos, labels, own_labels, &cond,
                                             &next, &body, CHECK_OK);
   loop->Initialize(init, cond, next, body);
   return loop;
@@ -5817,7 +5900,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseForStatement(
 template <typename Impl>
 typename ParserBase<Impl>::StatementT
 ParserBase<Impl>::ParseForEachStatementWithDeclarations(
-    int stmt_pos, ForInfo* for_info, ZonePtrList<const AstRawString>* labels,
+    ParseInfo* info, int stmt_pos, ForInfo* for_info, ZonePtrList<const AstRawString>* labels,
     ZonePtrList<const AstRawString>* own_labels, Scope* inner_block_scope,
     bool* ok) {
   // Just one declaration followed by in/of.
@@ -5854,10 +5937,10 @@ ParserBase<Impl>::ParseForEachStatementWithDeclarations(
   ExpressionT enumerable = impl()->NullExpression();
   if (for_info->mode == ForEachStatement::ITERATE) {
     ExpressionClassifier classifier(this);
-    enumerable = ParseAssignmentExpression(true, CHECK_OK);
+    enumerable = ParseAssignmentExpression(info, true, CHECK_OK);
     ValidateExpression(CHECK_OK);
   } else {
-    enumerable = ParseExpression(CHECK_OK);
+    enumerable = ParseExpression(info, CHECK_OK);
   }
 
   Expect(Token::RPAREN, CHECK_OK);
@@ -5878,7 +5961,7 @@ ParserBase<Impl>::ParseForEachStatementWithDeclarations(
     SourceRange body_range;
     SourceRangeScope range_scope(scanner(), &body_range);
 
-    StatementT body = ParseStatement(nullptr, nullptr, CHECK_OK);
+    StatementT body = ParseStatement(info, nullptr, nullptr, CHECK_OK);
     impl()->RecordIterationStatementSourceRange(loop, range_scope.Finalize());
 
     impl()->DesugarBindingInForEachStatement(for_info, &body_block,
@@ -5916,7 +5999,7 @@ ParserBase<Impl>::ParseForEachStatementWithDeclarations(
 template <typename Impl>
 typename ParserBase<Impl>::StatementT
 ParserBase<Impl>::ParseForEachStatementWithoutDeclarations(
-    int stmt_pos, ExpressionT expression, int lhs_beg_pos, int lhs_end_pos,
+    ParseInfo* info, int stmt_pos, ExpressionT expression, int lhs_beg_pos, int lhs_end_pos,
     ForInfo* for_info, ZonePtrList<const AstRawString>* labels,
     ZonePtrList<const AstRawString>* own_labels, bool* ok) {
   // Initializer is reference followed by in/of.
@@ -5933,10 +6016,10 @@ ParserBase<Impl>::ParseForEachStatementWithoutDeclarations(
   ExpressionT enumerable = impl()->NullExpression();
   if (for_info->mode == ForEachStatement::ITERATE) {
     ExpressionClassifier classifier(this);
-    enumerable = ParseAssignmentExpression(true, CHECK_OK);
+    enumerable = ParseAssignmentExpression(info, true, CHECK_OK);
     ValidateExpression(CHECK_OK);
   } else {
-    enumerable = ParseExpression(CHECK_OK);
+    enumerable = ParseExpression(info, CHECK_OK);
   }
 
   Expect(Token::RPAREN, CHECK_OK);
@@ -5946,7 +6029,7 @@ ParserBase<Impl>::ParseForEachStatementWithoutDeclarations(
     SourceRange body_range;
     SourceRangeScope range_scope(scanner(), &body_range);
 
-    body = ParseStatement(nullptr, nullptr, CHECK_OK);
+    body = ParseStatement(info, nullptr, nullptr, CHECK_OK);
     impl()->RecordIterationStatementSourceRange(loop, range_scope.Finalize());
   }
   return impl()->InitializeForEachStatement(loop, expression, enumerable, body);
@@ -5955,7 +6038,7 @@ ParserBase<Impl>::ParseForEachStatementWithoutDeclarations(
 template <typename Impl>
 typename ParserBase<Impl>::StatementT
 ParserBase<Impl>::ParseStandardForLoopWithLexicalDeclarations(
-    int stmt_pos, StatementT init, ForInfo* for_info,
+    ParseInfo* info, int stmt_pos, StatementT init, ForInfo* for_info,
     ZonePtrList<const AstRawString>* labels,
     ZonePtrList<const AstRawString>* own_labels, bool* ok) {
   // The condition and the next statement of the for loop must be parsed
@@ -5968,7 +6051,7 @@ ParserBase<Impl>::ParseStandardForLoopWithLexicalDeclarations(
   {
     BlockState block_state(&scope_, inner_scope);
     scope()->set_start_position(scanner()->location().beg_pos);
-    loop = ParseStandardForLoop(stmt_pos, labels, own_labels, &cond, &next,
+    loop = ParseStandardForLoop(info, stmt_pos, labels, own_labels, &cond, &next,
                                 &body, CHECK_OK);
     scope()->set_end_position(end_position());
   }
@@ -6012,19 +6095,19 @@ ParserBase<Impl>::ParseStandardForLoopWithLexicalDeclarations(
 
 template <typename Impl>
 typename ParserBase<Impl>::ForStatementT ParserBase<Impl>::ParseStandardForLoop(
-    int stmt_pos, ZonePtrList<const AstRawString>* labels,
+    ParseInfo* info, int stmt_pos, ZonePtrList<const AstRawString>* labels,
     ZonePtrList<const AstRawString>* own_labels, ExpressionT* cond,
     StatementT* next, StatementT* body, bool* ok) {
   ForStatementT loop = factory()->NewForStatement(labels, own_labels, stmt_pos);
   typename Types::Target target(this, loop);
 
   if (peek() != Token::SEMICOLON) {
-    *cond = ParseExpression(CHECK_OK);
+    *cond = ParseExpression(info, CHECK_OK);
   }
   Expect(Token::SEMICOLON, CHECK_OK);
 
   if (peek() != Token::RPAREN) {
-    ExpressionT exp = ParseExpression(CHECK_OK);
+    ExpressionT exp = ParseExpression(info, CHECK_OK);
     *next = factory()->NewExpressionStatement(exp, exp->position());
   }
   Expect(Token::RPAREN, CHECK_OK);
@@ -6032,7 +6115,7 @@ typename ParserBase<Impl>::ForStatementT ParserBase<Impl>::ParseStandardForLoop(
   SourceRange body_range;
   {
     SourceRangeScope range_scope(scanner(), &body_range);
-    *body = ParseStatement(nullptr, nullptr, CHECK_OK);
+    *body = ParseStatement(info, nullptr, nullptr, CHECK_OK);
   }
   impl()->RecordIterationStatementSourceRange(loop, body_range);
 
@@ -6052,7 +6135,7 @@ void ParserBase<Impl>::MarkLoopVariableAsAssigned(
 
 template <typename Impl>
 typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseForAwaitStatement(
-    ZonePtrList<const AstRawString>* labels,
+    ParseInfo* info, ZonePtrList<const AstRawString>* labels,
     ZonePtrList<const AstRawString>* own_labels, bool* ok) {
   // for await '(' ForDeclaration of AssignmentExpression ')'
   DCHECK(is_async_function());
@@ -6089,7 +6172,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseForAwaitStatement(
 
     {
       BlockState inner_state(&scope_, inner_block_scope);
-      ParseVariableDeclarations(kForStatement, &for_info.parsing_result,
+      ParseVariableDeclarations(info, kForStatement, &for_info.parsing_result,
                                 nullptr, CHECK_OK);
     }
     for_info.position = scanner()->location().beg_pos;
@@ -6118,7 +6201,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseForAwaitStatement(
     int lhs_beg_pos = peek_position();
     BlockState inner_state(&scope_, inner_block_scope);
     ExpressionClassifier classifier(this);
-    ExpressionT lhs = each_variable = ParseLeftHandSideExpression(CHECK_OK);
+    ExpressionT lhs = each_variable = ParseLeftHandSideExpression(info, CHECK_OK);
     int lhs_end_pos = end_position();
 
     if (lhs->IsArrayLiteral() || lhs->IsObjectLiteral()) {
@@ -6139,7 +6222,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseForAwaitStatement(
 
   {
     ExpressionClassifier classifier(this);
-    iterable = ParseAssignmentExpression(kAllowIn, CHECK_OK);
+    iterable = ParseAssignmentExpression(info, kAllowIn, CHECK_OK);
     ValidateExpression(CHECK_OK);
   }
 
@@ -6153,7 +6236,7 @@ typename ParserBase<Impl>::StatementT ParserBase<Impl>::ParseForAwaitStatement(
     SourceRange body_range;
     SourceRangeScope range_scope(scanner(), &body_range);
 
-    body = ParseStatement(nullptr, nullptr, CHECK_OK);
+    body = ParseStatement(info, nullptr, nullptr, CHECK_OK);
     scope()->set_end_position(end_position());
     impl()->RecordIterationStatementSourceRange(loop, range_scope.Finalize());
 
diff --git a/src/parsing/parser.cc b/src/parsing/parser.cc
index 6d0d9ff..352283a 100644
--- a/src/parsing/parser.cc
+++ b/src/parsing/parser.cc
@@ -1,6 +1,9 @@
 // Copyright 2012 the V8 project authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#include <iostream>
+#include <fstream>
+#include "src/parsing/global_maps.h"
 
 #include "src/parsing/parser.h"
 
@@ -26,6 +29,7 @@
 #include "src/string-stream.h"
 #include "src/tracing/trace-event.h"
 
+
 namespace v8 {
 namespace internal {
 
@@ -66,7 +70,28 @@ FunctionLiteral* Parser::DefaultConstructor(const AstRawString* name,
       args->Add(spread_args, zone());
       Expression* super_call_ref = NewSuperCallReference(pos);
       Expression* call = factory()->NewCall(super_call_ref, args, pos);
-      body->Add(factory()->NewReturnStatement(call, pos), zone());
+  
+      Scope* closure_scope = scope();
+      while(closure_scope->outer_scope())
+        closure_scope = closure_scope->outer_scope();
+      ReturnStatement* ret = factory()->NewReturnStatement(call, pos);
+      gmutex.lock();
+      assign_id++;
+      std::string tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+      gmutex.unlock();
+      const AstRawString* tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+      closure_scope->NewUnresolved(factory(), tmp_token);
+      ret->set_allocated_temp_var(tmp);
+
+      gmutex.lock();
+      assign_id++;
+      tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+      gmutex.unlock();
+      const AstRawString* one_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+      closure_scope->NewUnresolved(factory(), one_tmp_token);
+      ret->set_allocated_temp_var_for_asg(tmp);
+
+      body->Add(ret, zone());
     }
 
     expected_property_count = function_state.expected_property_count();
@@ -77,6 +102,21 @@ FunctionLiteral* Parser::DefaultConstructor(const AstRawString* name,
       parameter_count, FunctionLiteral::kNoDuplicateParameters,
       FunctionLiteral::kAnonymousExpression, default_eager_compile_hint(), pos,
       true, GetNextFunctionLiteralId());
+  Scope* closure_scope = function_scope;
+  while(closure_scope->outer_scope())
+    closure_scope = closure_scope->outer_scope();
+
+  if(function_literal) {
+    const AstRawString* window = factory()->ast_value_factory()->GetOneByteString("window");
+    closure_scope->NewUnresolved(factory(), window);  
+    const AstRawString* object = factory()->ast_value_factory()->GetOneByteString("Object");
+    closure_scope->NewUnresolved(factory(), object);  
+    const AstRawString* globalID = factory()->ast_value_factory()->GetOneByteString("Yx$Q7r$zJUnQUy__GlobalID");
+    closure_scope->NewUnresolved(factory(), globalID);  
+    const AstRawString* frameID = factory()->ast_value_factory()->GetOneByteString("Yx$Q7r$zJUnQUy__FrameID");
+    closure_scope->NewUnresolved(factory(), frameID);  
+
+  }
   return function_literal;
 }
 
@@ -371,7 +411,8 @@ Parser::Parser(ParseInfo* info)
       target_stack_(nullptr),
       total_preparse_skipped_(0),
       consumed_preparsed_scope_data_(info->consumed_preparsed_scope_data()),
-      parameters_end_pos_(info->parameters_end_pos()) {
+      parameters_end_pos_(info->parameters_end_pos()),
+      parse_info_(info) {
   // Even though we were passed ParseInfo, we should not store it in
   // Parser - this makes sure that Isolate is not accidentally accessed via
   // ParseInfo during background parsing.
@@ -484,6 +525,16 @@ FunctionLiteral* Parser::ParseProgram(Isolate* isolate, ParseInfo* info) {
   return result;
 }
 
+
+void Parser::appendDeclarationParam(DeclarationScope* scope, Expression* param, Expression* initializer, ParseInfo* info) {
+  if(info == nullptr)
+    return;
+  info->append_func_param(scope, param, initializer);
+  info->appendDeclaration(param);
+}
+
+
+
 FunctionLiteral* Parser::DoParseProgram(Isolate* isolate, ParseInfo* info) {
   // Note that this function can be called from the main thread or from a
   // background thread. We should not access anything Isolate / heap dependent
@@ -493,6 +544,7 @@ FunctionLiteral* Parser::DoParseProgram(Isolate* isolate, ParseInfo* info) {
   DCHECK_NULL(scope_);
   DCHECK_NULL(target_stack_);
 
+
   ParsingModeScope mode(this, allow_lazy_ ? PARSE_LAZILY : PARSE_EAGERLY);
   ResetFunctionLiteralId();
   DCHECK(info->function_literal_id() == FunctionLiteral::kIdTypeTopLevel ||
@@ -519,6 +571,7 @@ FunctionLiteral* Parser::DoParseProgram(Isolate* isolate, ParseInfo* info) {
     int beg_pos = scanner()->location().beg_pos;
     if (parsing_module_) {
       DCHECK(info->is_module());
+
       // Declare the special module parameter.
       auto name = ast_value_factory()->empty_string();
       bool is_duplicate = false;
@@ -537,7 +590,7 @@ FunctionLiteral* Parser::DoParseProgram(Isolate* isolate, ParseInfo* info) {
           factory()->NewExpressionStatement(initial_yield, kNoSourcePosition),
           zone());
 
-      ParseModuleItemList(body, &ok);
+      ParseModuleItemList(info, body, &ok);
       ok = ok && module()->Validate(this->scope()->AsModuleScope(),
                                     pending_error_handler(), zone());
     } else if (info->is_wrapped_as_function()) {
@@ -546,7 +599,7 @@ FunctionLiteral* Parser::DoParseProgram(Isolate* isolate, ParseInfo* info) {
       // Don't count the mode in the use counters--give the program a chance
       // to enable script-wide strict mode below.
       this->scope()->SetLanguageMode(info->language_mode());
-      ParseStatementList(body, Token::EOS, &ok);
+      ParseStatementList(info, body, Token::EOS, &ok);
     }
 
     // The parser will peek but not consume EOS.  Our scope logically goes all
@@ -584,6 +637,18 @@ FunctionLiteral* Parser::DoParseProgram(Isolate* isolate, ParseInfo* info) {
           scope, body, function_state.expected_property_count(),
           parameter_count);
       result->set_suspend_count(function_state.suspend_count());
+      Scope* closure_scope = result->scope();
+      while(closure_scope->outer_scope())
+        closure_scope = closure_scope->outer_scope();
+
+      const AstRawString* window = factory()->ast_value_factory()->GetOneByteString("window");
+      closure_scope->NewUnresolved(factory(), window);
+      const AstRawString* object = factory()->ast_value_factory()->GetOneByteString("Object");
+      closure_scope->NewUnresolved(factory(), object); 
+      const AstRawString* globalID = factory()->ast_value_factory()->GetOneByteString("Yx$Q7r$zJUnQUy__GlobalID");
+      closure_scope->NewUnresolved(factory(), globalID);  
+      const AstRawString* frameID = factory()->ast_value_factory()->GetOneByteString("Yx$Q7r$zJUnQUy__FrameID");
+      closure_scope->NewUnresolved(factory(), frameID);  
     }
   }
 
@@ -629,12 +694,31 @@ void Parser::ParseWrapped(Isolate* isolate, ParseInfo* info,
       PrepareWrappedArguments(isolate, info, zone);
 
   FunctionLiteral* function_literal = ParseFunctionLiteral(
-      function_name, location, kSkipFunctionNameCheck, kNormalFunction,
+      info, function_name, location, kSkipFunctionNameCheck, kNormalFunction,
       kNoSourcePosition, FunctionLiteral::kWrapped, LanguageMode::kSloppy,
       arguments_for_wrapped_function, CHECK_OK_VOID);
 
   Statement* return_statement = factory()->NewReturnStatement(
       function_literal, kNoSourcePosition, kNoSourcePosition);
+  Scope* closure_scope = scope();
+  while(closure_scope->outer_scope())
+    closure_scope = closure_scope->outer_scope();
+  gmutex.lock();
+  assign_id++;
+  std::string tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+  gmutex.unlock();
+  const AstRawString* tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+  closure_scope->NewUnresolved(factory(), tmp_token);
+  return_statement->set_allocated_temp_var(tmp);
+    
+  gmutex.lock();
+  assign_id++;
+  tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+  gmutex.unlock();
+  const AstRawString* one_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+  closure_scope->NewUnresolved(factory(), one_tmp_token);
+  return_statement->set_allocated_temp_var_for_asg(tmp);
+
   body->Add(return_statement, zone);
 }
 
@@ -660,6 +744,7 @@ FunctionLiteral* Parser::ParseFunction(Isolate* isolate, ParseInfo* info,
   FunctionLiteral* result =
       DoParseFunction(isolate, info, info->function_name());
   MaybeResetCharacterStream(info, result);
+
   if (result != nullptr) {
     Handle<String> inferred_name(shared_info->inferred_name(), isolate);
     result->set_inferred_name(inferred_name);
@@ -759,11 +844,11 @@ FunctionLiteral* Parser::DoParseFunction(Isolate* isolate, ParseInfo* info,
         BlockState block_state(&scope_, scope);
         if (Check(Token::LPAREN)) {
           // '(' StrictFormalParameters ')'
-          ParseFormalParameterList(&formals, &ok);
+          ParseFormalParameterList(info, &formals, &ok);
           if (ok) ok = Check(Token::RPAREN);
         } else {
           // BindingIdentifier
-          ParseFormalParameter(&formals, &ok);
+          ParseFormalParameter(info, &formals, &ok);
           if (ok) {
             DeclareFormalParameters(formals.scope, formals.params,
                                     formals.is_simple);
@@ -794,7 +879,7 @@ FunctionLiteral* Parser::DoParseFunction(Isolate* isolate, ParseInfo* info,
         // actually belong to the arrow function itself.
         const int rewritable_length = 0;
         Expression* expression = ParseArrowFunctionLiteral(
-            accept_IN, formals, rewritable_length, &ok);
+            info, accept_IN, formals, rewritable_length, &ok);
         if (ok) {
           // Scanning must end at the same position that was recorded
           // previously. If not, parsing has been interrupted due to a stack
@@ -821,12 +906,12 @@ FunctionLiteral* Parser::DoParseFunction(Isolate* isolate, ParseInfo* info,
           info->is_wrapped_as_function()
               ? PrepareWrappedArguments(isolate, info, zone())
               : nullptr;
+
       result = ParseFunctionLiteral(
-          raw_name, Scanner::Location::invalid(), kSkipFunctionNameCheck, kind,
+          info, raw_name, Scanner::Location::invalid(), kSkipFunctionNameCheck, kind,
           kNoSourcePosition, function_type, info->language_mode(),
           arguments_for_wrapped_function, &ok);
     }
-
     if (ok) {
       result->set_requires_instance_fields_initializer(
           info->requires_instance_fields_initializer());
@@ -842,7 +927,7 @@ FunctionLiteral* Parser::DoParseFunction(Isolate* isolate, ParseInfo* info,
   return result;
 }
 
-Statement* Parser::ParseModuleItem(bool* ok) {
+Statement* Parser::ParseModuleItem(ParseInfo* info, bool* ok) {
   // ecma262/#prod-ModuleItem
   // ModuleItem :
   //    ImportDeclaration
@@ -852,7 +937,7 @@ Statement* Parser::ParseModuleItem(bool* ok) {
   Token::Value next = peek();
 
   if (next == Token::EXPORT) {
-    return ParseExportDeclaration(ok);
+    return ParseExportDeclaration(info, ok);
   }
 
   if (next == Token::IMPORT) {
@@ -861,15 +946,15 @@ Statement* Parser::ParseModuleItem(bool* ok) {
     Token::Value peek_ahead = PeekAhead();
     if ((!allow_harmony_dynamic_import() || peek_ahead != Token::LPAREN) &&
         (!allow_harmony_import_meta() || peek_ahead != Token::PERIOD)) {
-      ParseImportDeclaration(CHECK_OK);
+      ParseImportDeclaration(info, CHECK_OK);
       return factory()->NewEmptyStatement(kNoSourcePosition);
     }
   }
 
-  return ParseStatementListItem(ok);
+  return ParseStatementListItem(info, ok);
 }
 
-void Parser::ParseModuleItemList(ZonePtrList<Statement>* body, bool* ok) {
+void Parser::ParseModuleItemList(ParseInfo* info, ZonePtrList<Statement>* body, bool* ok) {
   // ecma262/#prod-Module
   // Module :
   //    ModuleBody?
@@ -880,7 +965,7 @@ void Parser::ParseModuleItemList(ZonePtrList<Statement>* body, bool* ok) {
 
   DCHECK(scope()->is_module_scope());
   while (peek() != Token::EOS) {
-    Statement* stat = ParseModuleItem(CHECK_OK_VOID);
+    Statement* stat = ParseModuleItem(info, CHECK_OK_VOID);
     if (stat && !stat->IsEmpty()) {
       body->Add(stat, zone());
     }
@@ -1000,7 +1085,7 @@ ZonePtrList<const Parser::NamedImport>* Parser::ParseNamedImports(int pos,
 }
 
 
-void Parser::ParseImportDeclaration(bool* ok) {
+void Parser::ParseImportDeclaration(ParseInfo* info, bool* ok) {
   // ImportDeclaration :
   //   'import' ImportClause 'from' ModuleSpecifier ';'
   //   'import' ModuleSpecifier ';'
@@ -1108,7 +1193,7 @@ void Parser::ParseImportDeclaration(bool* ok) {
 }
 
 
-Statement* Parser::ParseExportDefault(bool* ok) {
+Statement* Parser::ParseExportDefault(ParseInfo* info, bool* ok) {
   //  Supports the following productions, starting after the 'default' token:
   //    'export' 'default' HoistableDeclaration
   //    'export' 'default' ClassDeclaration
@@ -1121,7 +1206,7 @@ Statement* Parser::ParseExportDefault(bool* ok) {
   Statement* result = nullptr;
   switch (peek()) {
     case Token::FUNCTION:
-      result = ParseHoistableDeclaration(&local_names, true, CHECK_OK);
+      result = ParseHoistableDeclaration(info, &local_names, true, CHECK_OK);
       break;
 
     case Token::CLASS:
@@ -1133,7 +1218,7 @@ Statement* Parser::ParseExportDefault(bool* ok) {
       if (PeekAhead() == Token::FUNCTION &&
           !scanner()->HasLineTerminatorAfterNext()) {
         Consume(Token::ASYNC);
-        result = ParseAsyncFunctionDeclaration(&local_names, true, CHECK_OK);
+        result = ParseAsyncFunctionDeclaration(info, &local_names, true, CHECK_OK);
         break;
       }
       V8_FALLTHROUGH;
@@ -1141,9 +1226,9 @@ Statement* Parser::ParseExportDefault(bool* ok) {
     default: {
       int pos = position();
       ExpressionClassifier classifier(this);
-      Expression* value = ParseAssignmentExpression(true, CHECK_OK);
+      Expression* value = ParseAssignmentExpression(info, true, CHECK_OK);
       ValidateExpression(CHECK_OK);
-      SetFunctionName(value, ast_value_factory()->default_string());
+      SetFunctionName(info, value, ast_value_factory()->default_string());
 
       const AstRawString* local_name =
           ast_value_factory()->star_default_star_string();
@@ -1160,6 +1245,8 @@ Statement* Parser::ParseExportDefault(bool* ok) {
       result = IgnoreCompletion(
           factory()->NewExpressionStatement(assignment, kNoSourcePosition));
 
+      SetTempVarForExpression(assignment, true);
+
       ExpectSemicolon(CHECK_OK);
       break;
     }
@@ -1174,7 +1261,7 @@ Statement* Parser::ParseExportDefault(bool* ok) {
   return result;
 }
 
-Statement* Parser::ParseExportDeclaration(bool* ok) {
+Statement* Parser::ParseExportDeclaration(ParseInfo* info, bool* ok) {
   // ExportDeclaration:
   //    'export' '*' 'from' ModuleSpecifier ';'
   //    'export' ExportClause ('from' ModuleSpecifier)? ';'
@@ -1190,7 +1277,7 @@ Statement* Parser::ParseExportDeclaration(bool* ok) {
   Scanner::Location loc = scanner()->peek_location();
   switch (peek()) {
     case Token::DEFAULT:
-      return ParseExportDefault(ok);
+      return ParseExportDefault(info, ok);
 
     case Token::MUL: {
       Consume(Token::MUL);
@@ -1248,7 +1335,7 @@ Statement* Parser::ParseExportDeclaration(bool* ok) {
     }
 
     case Token::FUNCTION:
-      result = ParseHoistableDeclaration(&names, false, CHECK_OK);
+      result = ParseHoistableDeclaration(info, &names, false, CHECK_OK);
       break;
 
     case Token::CLASS:
@@ -1259,14 +1346,14 @@ Statement* Parser::ParseExportDeclaration(bool* ok) {
     case Token::VAR:
     case Token::LET:
     case Token::CONST:
-      result = ParseVariableStatement(kStatementListItem, &names, CHECK_OK);
+      result = ParseVariableStatement(info, kStatementListItem, &names, CHECK_OK);
       break;
 
     case Token::ASYNC:
       // TODO(neis): Why don't we have the same check here as in
       // ParseStatementListItem?
       Consume(Token::ASYNC);
-      result = ParseAsyncFunctionDeclaration(&names, false, CHECK_OK);
+      result = ParseAsyncFunctionDeclaration(info, &names, false, CHECK_OK);
       break;
 
     default:
@@ -1290,8 +1377,11 @@ VariableProxy* Parser::NewUnresolved(const AstRawString* name, int begin_pos,
   return scope()->NewUnresolved(factory(), name, begin_pos, kind);
 }
 
-VariableProxy* Parser::NewUnresolved(const AstRawString* name) {
-  return scope()->NewUnresolved(factory(), name, scanner()->location().beg_pos);
+VariableProxy* Parser::NewUnresolved(const AstRawString* name, Scope* input_scope, AstNodeFactory* input_factory) {
+  if(!input_scope)
+    return scope()->NewUnresolved(factory(), name, scanner()->location().beg_pos);
+  else
+    return input_scope->NewUnresolved(input_factory, name, -1);
 }
 
 Declaration* Parser::DeclareVariable(const AstRawString* name,
@@ -1304,6 +1394,7 @@ Declaration* Parser::DeclareVariable(const AstRawString* name,
                                      VariableMode mode, InitializationFlag init,
                                      int pos, bool* ok) {
   DCHECK_NOT_NULL(name);
+
   VariableProxy* proxy = factory()->NewVariableProxy(
       name, NORMAL_VARIABLE, scanner()->location().beg_pos);
   Declaration* declaration;
@@ -1363,11 +1454,92 @@ Block* Parser::BuildInitializationBlock(
   return result;
 }
 
+
+
+bool Parser::LogFunctionInfo(FunctionLiteral* function, bool force_infer_name, std::string raw_func_name, bool force_log) {
+  int pid = base::OS::GetCurrentProcessId();
+  char filename[128];
+
+  sprintf(filename, "%d.func", pid);
+  std::ofstream f_out;
+  f_out.open(filename, std::ios::app);
+  if(!f_out) {
+    return false;
+  }
+  else {
+    v8::Isolate* isolate = v8::Isolate::GetCurrent();
+    bool should_write_to_file = isolate ? true : false;
+    i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);
+    std::string func_name;
+
+    if(function->scope()->outer_scope()->is_script_scope() || force_log) {
+      if(!force_infer_name) {
+        std::unique_ptr<char []> func_name_ptr = function->GetDebugName();
+        std::string func_name_str(func_name_ptr.get());
+        func_name = func_name_str;
+      }
+      else {
+        func_name = raw_func_name; 
+      }
+      int start_pos = function->start_position();
+      int end_pos = function->end_position();
+      int script_id = function->script_id();
+      std::string script_url;
+      if(function->script_url()) {
+        std::unique_ptr<char []> script_url_ptr = String::cast(function->script_url())->ToCString();
+        std::string script_url_str(script_url_ptr.get());
+        script_url = script_url_str;
+      }
+      else if(!function->script_url_str().empty()) {
+        script_url = function->script_url_str();
+      }
+      else {
+        script_url =  "0";
+      }
+      if(should_write_to_file) {
+        f_out << func_name << "\t";
+        f_out.flush();
+        f_out << std::to_string(start_pos) << "\t";
+        f_out.flush();
+        f_out << std::to_string(end_pos) << "\t";
+        f_out.flush();
+        f_out << script_url << "\t";
+        f_out.flush();
+        f_out << std::to_string(base::Time::Now().ToJsTime()) << "\t";
+        f_out.flush();
+        f_out << std::to_string(script_id) << "\t";
+        f_out.flush();
+        f_out << std::to_string(Smi::ToInt(Smi::cast(i_isolate->native_context()->debug_context_id()))) << "\n";
+        f_out.flush();
+        f_out.close();
+      }
+      else {
+          std::vector<std::string> func_info;
+          func_info.push_back(func_name);
+          func_info.push_back(std::to_string(start_pos));
+          func_info.push_back(std::to_string(end_pos));   
+          func_info.push_back(script_url);
+          func_info.push_back(std::to_string(base::Time::Now().ToJsTime()));
+          unbound_functions[script_id] = func_info;
+      }
+    }
+    return true;
+  }
+}
+ 
+
+
 Statement* Parser::DeclareFunction(const AstRawString* variable_name,
                                    FunctionLiteral* function, VariableMode mode,
                                    int pos, bool is_sloppy_block_function,
                                    ZonePtrList<const AstRawString>* names,
-                                   bool* ok) {
+                                   bool* ok, ParseInfo* info) {
+
+  Scope* current_scope = this->scope();
+  current_scope->append_declared_function_name(ConvertIdentifierToString(variable_name)); 
+
+  LogFunctionInfo(function, false, "", false);
+
   VariableProxy* proxy =
       factory()->NewVariableProxy(variable_name, NORMAL_VARIABLE, pos);
   Declaration* declaration =
@@ -1396,6 +1568,7 @@ Statement* Parser::DeclareClass(const AstRawString* variable_name,
 
   Assignment* assignment = factory()->NewAssignment(Token::INIT, decl->proxy(),
                                                     value, class_token_pos);
+  SetTempVarForExpression(assignment, true);
   return IgnoreCompletion(
       factory()->NewExpressionStatement(assignment, kNoSourcePosition));
 }
@@ -1413,9 +1586,12 @@ Statement* Parser::DeclareNative(const AstRawString* name, int pos, bool* ok) {
   Declaration* decl = DeclareVariable(name, VariableMode::kVar, pos, CHECK_OK);
   NativeFunctionLiteral* lit =
       factory()->NewNativeFunctionLiteral(name, extension_, kNoSourcePosition);
+
+  Assignment* asg = factory()->NewAssignment(Token::INIT, decl->proxy(), lit, kNoSourcePosition);
+
+  SetTempVarForExpression(asg, true);
   return factory()->NewExpressionStatement(
-      factory()->NewAssignment(Token::INIT, decl->proxy(), lit,
-                               kNoSourcePosition),
+      asg,
       pos);
 }
 
@@ -1487,7 +1663,11 @@ Expression* Parser::RewriteReturn(Expression* return_value, int pos) {
     Variable* temp = NewTemporary(ast_value_factory()->empty_string());
     Assignment* assign = factory()->NewAssignment(
         Token::ASSIGN, factory()->NewVariableProxy(temp), return_value, pos);
+    Scope* closure_scope = scope();
+    while(closure_scope->outer_scope())
+      closure_scope = closure_scope->outer_scope();
 
+    SetTempVarForExpression(assign, true);
     // temp === undefined
     Expression* is_undefined = factory()->NewCompareOperation(
         Token::EQ_STRICT, assign,
@@ -1497,6 +1677,23 @@ Expression* Parser::RewriteReturn(Expression* return_value, int pos) {
     return_value =
         factory()->NewConditional(is_undefined, ThisExpression(pos),
                                   factory()->NewVariableProxy(temp), pos);
+    gmutex.lock();
+    assign_id++;
+    std::string tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+    gmutex.unlock();
+    const AstRawString* one_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+    //AstNodeFactory ast_node_factory(info->GetOrCreateAstValueFactory(), info->zone());
+    closure_scope->NewUnresolved(factory(), one_tmp_token);
+    return_value->set_allocated_temp_var(tmp);
+
+    gmutex.lock();
+    assign_id++;
+    tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+    gmutex.unlock();
+    const AstRawString* two_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+    //AstNodeFactory ast_node_factory(info->GetOrCreateAstValueFactory(), info->zone());
+    closure_scope->NewUnresolved(factory(), two_tmp_token);
+    return_value->set_allocated_temp_var_for_asg(tmp);
   }
   return return_value;
 }
@@ -1535,6 +1732,9 @@ Statement* Parser::RewriteSwitchStatement(SwitchStatement* switch_statement,
   Assignment* tag_assign = factory()->NewAssignment(
       Token::ASSIGN, factory()->NewVariableProxy(tag_variable), tag,
       tag->position());
+
+  SetTempVarForExpression(tag_assign, true);
+
   // Wrap with IgnoreCompletion so the tag isn't returned as the completion
   // value, in case the switch statements don't have a value.
   Statement* tag_statement = IgnoreCompletion(
@@ -1635,18 +1835,19 @@ Statement* Parser::RewriteTryStatement(Block* try_block, Block* catch_block,
   }
 }
 
-void Parser::ParseAndRewriteGeneratorFunctionBody(int pos, FunctionKind kind,
+void Parser::ParseAndRewriteGeneratorFunctionBody(ParseInfo* info, int pos, FunctionKind kind,
                                                   ZonePtrList<Statement>* body,
                                                   bool* ok) {
   // For ES6 Generators, we just prepend the initial yield.
   Expression* initial_yield = BuildInitialYield(pos, kind);
   body->Add(factory()->NewExpressionStatement(initial_yield, kNoSourcePosition),
             zone());
-  ParseStatementList(body, Token::RBRACE, ok);
+
+  ParseStatementList(info, body, Token::RBRACE, ok);
 }
 
 void Parser::ParseAndRewriteAsyncGeneratorFunctionBody(
-    int pos, FunctionKind kind, ZonePtrList<Statement>* body, bool* ok) {
+    ParseInfo* info, int pos, FunctionKind kind, ZonePtrList<Statement>* body, bool* ok) {
   // For ES2017 Async Generators, we produce:
   //
   // try {
@@ -1674,7 +1875,8 @@ void Parser::ParseAndRewriteAsyncGeneratorFunctionBody(
   try_block->statements()->Add(
       factory()->NewExpressionStatement(initial_yield, kNoSourcePosition),
       zone());
-  ParseStatementList(try_block->statements(), Token::RBRACE, ok);
+ 
+  ParseStatementList(info, try_block->statements(), Token::RBRACE, ok);
   if (!*ok) return;
 
   // Don't create iterator result for async generators, as the resume methods
@@ -1698,8 +1900,30 @@ void Parser::ParseAndRewriteAsyncGeneratorFunctionBody(
 
   Expression* reject_call = factory()->NewCallRuntime(
       Runtime::kInlineAsyncGeneratorReject, reject_args, kNoSourcePosition);
+
+  ReturnStatement* return_statement = factory()->NewReturnStatement(reject_call, kNoSourcePosition);
+  Scope* closure_scope = scope();
+  while(closure_scope->outer_scope())
+    closure_scope = closure_scope->outer_scope();
+  gmutex.lock();
+  assign_id++;
+  std::string tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+  gmutex.unlock();
+  const AstRawString* tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+  closure_scope->NewUnresolved(factory(), tmp_token);
+  return_statement->set_allocated_temp_var(tmp);
+
+
+  gmutex.lock();
+  assign_id++;
+  tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+  gmutex.unlock();
+  const AstRawString* one_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+  closure_scope->NewUnresolved(factory(), one_tmp_token);
+  return_statement->set_allocated_temp_var_for_asg(tmp);
+
   Block* catch_block = IgnoreCompletion(
-      factory()->NewReturnStatement(reject_call, kNoSourcePosition));
+      return_statement);
 
   TryStatement* try_catch = factory()->NewTryCatchStatementForAsyncAwait(
       try_block, catch_scope, catch_block, kNoSourcePosition);
@@ -1757,6 +1981,8 @@ Expression* Parser::BuildIteratorNextResult(VariableProxy* iterator,
   Expression* left =
       factory()->NewAssignment(Token::ASSIGN, result_proxy, next_call, pos);
 
+  SetTempVarForExpression(left, true);
+
   // %_IsJSReceiver(...)
   ZonePtrList<Expression>* is_spec_object_args =
       new (zone()) ZonePtrList<Expression>(1, zone());
@@ -1791,9 +2017,13 @@ Statement* Parser::InitializeForEachStatement(ForEachStatement* stmt,
     if (each->IsArrayLiteral() || each->IsObjectLiteral()) {
       Variable* temp = NewTemporary(ast_value_factory()->empty_string());
       VariableProxy* temp_proxy = factory()->NewVariableProxy(temp);
+
+      Assignment* tag_assign = factory()->NewAssignment(Token::ASSIGN, each, temp_proxy, kNoSourcePosition);
+
+      SetTempVarForExpression(tag_assign, true);
+
       Expression* assign_each =
-          RewriteDestructuringAssignment(factory()->NewAssignment(
-              Token::ASSIGN, each, temp_proxy, kNoSourcePosition));
+          RewriteDestructuringAssignment(tag_assign);
       auto block = factory()->NewBlock(2, false);
       block->statements()->Add(
           factory()->NewExpressionStatement(assign_each, kNoSourcePosition),
@@ -1833,10 +2063,13 @@ Block* Parser::RewriteForVarInLegacy(const ForInfo& for_info) {
     const AstRawString* name = decl.pattern->AsVariableProxy()->raw_name();
     VariableProxy* single_var = NewUnresolved(name);
     Block* init_block = factory()->NewBlock(2, true);
+
+    Assignment* tag_assign = factory()->NewAssignment(Token::ASSIGN, single_var, decl.initializer, kNoSourcePosition);
+
+    SetTempVarForExpression(tag_assign, true);
     init_block->statements()->Add(
         factory()->NewExpressionStatement(
-            factory()->NewAssignment(Token::ASSIGN, single_var,
-                                     decl.initializer, kNoSourcePosition),
+            tag_assign,
             kNoSourcePosition),
         zone());
     return init_block;
@@ -1960,6 +2193,8 @@ Statement* Parser::InitializeForOfStatement(
         Token::ASSIGN, factory()->NewVariableProxy(iterator),
         factory()->NewGetIterator(iterable, type, iterable->position()),
         iterable->position());
+
+    SetTempVarForExpression(assign_iterator, true);
   }
 
   Expression* assign_next;
@@ -1971,6 +2206,8 @@ Statement* Parser::InitializeForOfStatement(
                                    avfactory->next_string(), kNoSourcePosition),
                                kNoSourcePosition),
         kNoSourcePosition);
+
+    SetTempVarForExpression(assign_next, true);
   }
 
   // [if (IteratorType == kNormal)]
@@ -2013,10 +2250,15 @@ Statement* Parser::InitializeForOfStatement(
     Variable* tmp = NewTemporary(avfactory->empty_string());
     Expression* save_result = factory()->NewAssignment(
         Token::ASSIGN, factory()->NewVariableProxy(tmp), result_value, nopos);
+    
+    SetTempVarForExpression(save_result, true);
+
 
     Expression* set_completion_abrupt = factory()->NewAssignment(
         Token::ASSIGN, factory()->NewVariableProxy(completion),
         factory()->NewSmiLiteral(Parser::kAbruptCompletion, nopos), nopos);
+  
+    SetTempVarForExpression(set_completion_abrupt, true);
 
     result_value = factory()->NewBinaryOperation(Token::COMMA, save_result,
                                                  set_completion_abrupt, nopos);
@@ -2029,6 +2271,10 @@ Statement* Parser::InitializeForOfStatement(
   {
     assign_each =
         factory()->NewAssignment(Token::ASSIGN, each, result_value, nopos);
+
+    SetTempVarForExpression(assign_each, true);
+
+
     if (each->IsArrayLiteral() || each->IsObjectLiteral()) {
       assign_each = RewriteDestructuringAssignment(assign_each->AsAssignment());
     }
@@ -2042,6 +2288,8 @@ Statement* Parser::InitializeForOfStatement(
         Token::ASSIGN, proxy,
         factory()->NewSmiLiteral(Parser::kNormalCompletion, nopos), nopos);
 
+    SetTempVarForExpression(assignment, true);
+
     set_completion_normal =
         IgnoreCompletion(factory()->NewExpressionStatement(assignment, nopos));
   }
@@ -2120,6 +2368,10 @@ Statement* Parser::DesugarLexicalBindingsInForStatement(
     VariableProxy* temp_proxy = factory()->NewVariableProxy(temp);
     Assignment* assignment = factory()->NewAssignment(Token::ASSIGN, temp_proxy,
                                                       proxy, kNoSourcePosition);
+
+    SetTempVarForExpression(assignment, true);
+
+
     Statement* assignment_statement =
         factory()->NewExpressionStatement(assignment, kNoSourcePosition);
     outer_block->statements()->Add(assignment_statement, zone());
@@ -2134,6 +2386,10 @@ Statement* Parser::DesugarLexicalBindingsInForStatement(
     Expression* const1 = factory()->NewSmiLiteral(1, kNoSourcePosition);
     Assignment* assignment = factory()->NewAssignment(
         Token::ASSIGN, first_proxy, const1, kNoSourcePosition);
+
+    SetTempVarForExpression(assignment, true);
+
+
     Statement* assignment_statement =
         factory()->NewExpressionStatement(assignment, kNoSourcePosition);
     outer_block->statements()->Add(assignment_statement, zone());
@@ -2172,6 +2428,10 @@ Statement* Parser::DesugarLexicalBindingsInForStatement(
       VariableProxy* temp_proxy = factory()->NewVariableProxy(temps.at(i));
       Assignment* assignment = factory()->NewAssignment(
           Token::INIT, decl->proxy(), temp_proxy, kNoSourcePosition);
+
+      SetTempVarForExpression(assignment, true);
+
+
       Statement* assignment_statement =
           factory()->NewExpressionStatement(assignment, kNoSourcePosition);
       int declaration_pos = for_info.parsing_result.descriptor.declaration_pos;
@@ -2198,6 +2458,9 @@ Statement* Parser::DesugarLexicalBindingsInForStatement(
         Expression* const0 = factory()->NewSmiLiteral(0, kNoSourcePosition);
         Assignment* assignment = factory()->NewAssignment(
             Token::ASSIGN, first_proxy, const0, kNoSourcePosition);
+
+        SetTempVarForExpression(assignment, true);
+
         clear_first =
             factory()->NewExpressionStatement(assignment, kNoSourcePosition);
       }
@@ -2213,6 +2476,10 @@ Statement* Parser::DesugarLexicalBindingsInForStatement(
       Expression* const1 = factory()->NewSmiLiteral(1, kNoSourcePosition);
       Assignment* assignment = factory()->NewAssignment(
           Token::ASSIGN, flag_proxy, const1, kNoSourcePosition);
+
+      SetTempVarForExpression(assignment, true);
+
+
       Statement* assignment_statement =
           factory()->NewExpressionStatement(assignment, kNoSourcePosition);
       ignore_completion_block->statements()->Add(assignment_statement, zone());
@@ -2248,6 +2515,9 @@ Statement* Parser::DesugarLexicalBindingsInForStatement(
         Expression* const0 = factory()->NewSmiLiteral(0, kNoSourcePosition);
         compound_next = factory()->NewAssignment(Token::ASSIGN, flag_proxy,
                                                  const0, kNoSourcePosition);
+
+        SetTempVarForExpression(compound_next, true);
+
       }
 
       // Make the comma-separated list of temp_x = x assignments.
@@ -2258,6 +2528,10 @@ Statement* Parser::DesugarLexicalBindingsInForStatement(
             factory()->NewVariableProxy(inner_vars.at(i), inner_var_proxy_pos);
         Assignment* assignment = factory()->NewAssignment(
             Token::ASSIGN, temp_proxy, proxy, kNoSourcePosition);
+
+        SetTempVarForExpression(assignment, true);
+
+
         compound_next = factory()->NewBinaryOperation(
             Token::COMMA, compound_next, assignment, kNoSourcePosition);
       }
@@ -2412,7 +2686,7 @@ void Parser::PrepareGeneratorVariables() {
 }
 
 FunctionLiteral* Parser::ParseFunctionLiteral(
-    const AstRawString* function_name, Scanner::Location function_name_location,
+    ParseInfo* info, const AstRawString* function_name, Scanner::Location function_name_location,
     FunctionNameValidity function_name_validity, FunctionKind kind,
     int function_token_pos, FunctionLiteral::FunctionType function_type,
     LanguageMode language_mode,
@@ -2433,6 +2707,10 @@ FunctionLiteral* Parser::ParseFunctionLiteral(
                                                     : function_token_pos;
   DCHECK_NE(kNoSourcePosition, pos);
 
+  int tmp_token_pos = -1;
+  if (function_token_pos != kNoSourcePosition)
+    tmp_token_pos = peek_position();
+
   // Anonymous functions were passed either the empty symbol or a null
   // handle as the function name.  Remember if we were passed a non-empty
   // handle to decide whether to invoke function name inference.
@@ -2557,9 +2835,10 @@ FunctionLiteral* Parser::ParseFunctionLiteral(
       SkipFunction(function_name, kind, function_type, scope, &num_parameters,
                    &produced_preparsed_scope_data, is_lazy_inner_function,
                    is_lazy_top_level_function, &eager_compile_hint, CHECK_OK);
+
   if (!did_preparse_successfully) {
     body = ParseFunction(
-        function_name, pos, kind, function_type, scope, &num_parameters,
+        info, function_name, pos, kind, function_type, scope, &num_parameters,
         &function_length, &has_duplicate_parameters, &expected_property_count,
         &suspend_count, arguments_for_wrapped_function, CHECK_OK);
   }
@@ -2607,16 +2886,42 @@ FunctionLiteral* Parser::ParseFunctionLiteral(
                                : FunctionLiteral::kNoDuplicateParameters;
 
   // Note that the FunctionLiteral needs to be created in the main Zone again.
+
   FunctionLiteral* function_literal = factory()->NewFunctionLiteral(
       function_name, scope, body, expected_property_count, num_parameters,
       function_length, duplicate_parameters, function_type, eager_compile_hint,
-      pos, true, function_literal_id, produced_preparsed_scope_data);
+      pos, true, function_literal_id, produced_preparsed_scope_data, info);
   function_literal->set_function_token_position(function_token_pos);
   function_literal->set_suspend_count(suspend_count);
+  Scope* closure_scope = scope;
+  while(closure_scope->outer_scope())
+    closure_scope = closure_scope->outer_scope();
+
+  if(function_literal) {
+    const AstRawString* window = factory()->ast_value_factory()->GetOneByteString("window");
+    closure_scope->NewUnresolved(factory(), window);  
+    const AstRawString* object = factory()->ast_value_factory()->GetOneByteString("Object");
+    closure_scope->NewUnresolved(factory(), object); 
+    const AstRawString* globalID = factory()->ast_value_factory()->GetOneByteString("Yx$Q7r$zJUnQUy__GlobalID");
+    closure_scope->NewUnresolved(factory(), globalID);  
+    const AstRawString* frameID = factory()->ast_value_factory()->GetOneByteString("Yx$Q7r$zJUnQUy__FrameID");
+    closure_scope->NewUnresolved(factory(), frameID);   
+  }
 
   if (should_infer_name) {
     fni_.AddFunction(function_literal);
   }
+
+  if(did_preparse_successfully) { 
+    // we still assign a functionID to it, but that ID would be updated later
+    std::tuple<int, int> info(script_id(), tmp_token_pos);
+    function_id_alias[info] = function_literal->function_id(); // not a list, used only once
+  }
+  else {
+    std::tuple<int, int> target(script_id(), pos);
+    if(function_id_alias.find(target) != function_id_alias.end())
+      function_literal->set_function_id(function_id_alias[target]);
+  }
   return function_literal;
 }
 
@@ -2816,6 +3121,26 @@ Block* Parser::BuildParameterInitializationBlock(
       initial_value = factory()->NewConditional(
           condition, parameter->initializer, initial_value, kNoSourcePosition);
       descriptor.initialization_pos = parameter->initializer->position();
+
+      Scope* closure_scope = scope();
+      while(closure_scope->outer_scope())
+        closure_scope = closure_scope->outer_scope();
+      gmutex.lock();
+      assign_id++;
+      std::string tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+      gmutex.unlock();
+      const AstRawString* tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+      closure_scope->NewUnresolved(factory(), tmp_token);
+      initial_value->set_allocated_temp_var(tmp);
+
+      gmutex.lock();
+      assign_id++;
+      tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+      gmutex.unlock();
+      const AstRawString* one_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+      closure_scope->NewUnresolved(factory(), one_tmp_token);
+      initial_value->set_allocated_temp_var_for_asg(tmp);
+
     }
 
     Scope* param_scope = scope();
@@ -2882,6 +3207,10 @@ Block* Parser::BuildRejectPromiseOnException(Block* inner_block) {
     Assignment* assign_promise = factory()->NewAssignment(
         Token::ASSIGN, factory()->NewVariableProxy(PromiseVariable()),
         create_promise, kNoSourcePosition);
+
+    SetTempVarForExpression(assign_promise, true);
+
+
     set_promise =
         factory()->NewExpressionStatement(assign_promise, kNoSourcePosition);
   }
@@ -2893,8 +3222,30 @@ Block* Parser::BuildRejectPromiseOnException(Block* inner_block) {
   Expression* promise_reject = BuildRejectPromise(
       factory()->NewVariableProxy(catch_scope->catch_variable()),
       kNoSourcePosition);
+
+  ReturnStatement* return_statement = factory()->NewReturnStatement(promise_reject, kNoSourcePosition);
+  Scope* closure_scope = scope();
+  while(closure_scope->outer_scope())
+    closure_scope = closure_scope->outer_scope();
+  gmutex.lock();
+  assign_id++;
+  std::string tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+  gmutex.unlock();
+  const AstRawString* tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+  closure_scope->NewUnresolved(factory(), tmp_token);
+  return_statement->set_allocated_temp_var(tmp);
+
+  gmutex.lock();
+  assign_id++;
+  tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+  gmutex.unlock();
+  const AstRawString* one_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+  closure_scope->NewUnresolved(factory(), one_tmp_token);
+  return_statement->set_allocated_temp_var_for_asg(tmp);
+
+
   Block* catch_block = IgnoreCompletion(
-      factory()->NewReturnStatement(promise_reject, kNoSourcePosition));
+      return_statement);
 
   TryStatement* try_catch_statement =
       factory()->NewTryCatchStatementForAsyncAwait(
@@ -2966,12 +3317,13 @@ Expression* Parser::BuildInitialYield(int pos, FunctionKind kind) {
 }
 
 ZonePtrList<Statement>* Parser::ParseFunction(
-    const AstRawString* function_name, int pos, FunctionKind kind,
+    ParseInfo* info, const AstRawString* function_name, int pos, FunctionKind kind,
     FunctionLiteral::FunctionType function_type,
     DeclarationScope* function_scope, int* num_parameters, int* function_length,
     bool* has_duplicate_parameters, int* expected_property_count,
     int* suspend_count,
     ZonePtrList<const AstRawString>* arguments_for_wrapped_function, bool* ok) {
+
   ParsingModeScope mode(this, allow_lazy_ ? PARSE_LAZILY : PARSE_EAGERLY);
 
   FunctionState function_state(&function_state_, &scope_, function_scope);
@@ -3009,7 +3361,7 @@ ZonePtrList<Statement>* Parser::ParseFunction(
   } else {
     // For a regular function, the function arguments are parsed from source.
     DCHECK_NULL(arguments_for_wrapped_function);
-    ParseFormalParameterList(&formals, CHECK_OK);
+    ParseFormalParameterList(info, &formals, CHECK_OK);
     if (expected_parameters_end_pos != kNoSourcePosition) {
       // Check for '(' or ')' shenanigans in the parameter string for dynamic
       // functions.
@@ -3039,7 +3391,7 @@ ZonePtrList<Statement>* Parser::ParseFunction(
   *function_length = formals.function_length;
 
   ZonePtrList<Statement>* body = new (zone()) ZonePtrList<Statement>(8, zone());
-  ParseFunctionBody(body, function_name, pos, formals, kind, function_type,
+  ParseFunctionBody(info, body, function_name, pos, formals, kind, function_type,
                     FunctionBodyType::kBlock, true, ok);
 
   // Validate parameter names. We can do this only after parsing the function,
@@ -3159,12 +3511,28 @@ FunctionLiteral* Parser::CreateInitializerFunction(
   InitializeClassFieldsStatement* static_fields =
       factory()->NewInitializeClassFieldsStatement(fields, kNoSourcePosition);
   statements->Add(static_fields, zone());
-  return factory()->NewFunctionLiteral(
+  FunctionLiteral* new_function = factory()->NewFunctionLiteral(
       ast_value_factory()->GetOneByteString(name), scope, statements, 0, 0, 0,
       FunctionLiteral::kNoDuplicateParameters,
       FunctionLiteral::kAnonymousExpression,
       FunctionLiteral::kShouldEagerCompile, scope->start_position(), false,
       GetNextFunctionLiteralId());
+  Scope* closure_scope = scope;
+  while(closure_scope->outer_scope())
+    closure_scope = closure_scope->outer_scope();
+
+   if(new_function) {
+    const AstRawString* window = factory()->ast_value_factory()->GetOneByteString("window");
+    closure_scope->NewUnresolved(factory(), window);  
+    const AstRawString* object = factory()->ast_value_factory()->GetOneByteString("Object");
+    closure_scope->NewUnresolved(factory(), object);  
+    const AstRawString* globalID = factory()->ast_value_factory()->GetOneByteString("Yx$Q7r$zJUnQUy__GlobalID");
+    closure_scope->NewUnresolved(factory(), globalID);  
+    const AstRawString* frameID = factory()->ast_value_factory()->GetOneByteString("Yx$Q7r$zJUnQUy__FrameID");
+    closure_scope->NewUnresolved(factory(), frameID);  
+  }
+
+  return new_function;
 }
 
 // This method generates a ClassLiteral AST node.
@@ -3266,6 +3634,9 @@ void Parser::InsertShadowingVarBindingInitializers(Block* inner_block) {
     VariableProxy* from = factory()->NewVariableProxy(parameter);
     Expression* assignment =
         factory()->NewAssignment(Token::ASSIGN, to, from, kNoSourcePosition);
+
+    SetTempVarForExpression(assignment, true);
+
     Statement* statement =
         factory()->NewExpressionStatement(assignment, kNoSourcePosition);
     inner_block->statements()->InsertAt(0, statement, zone());
@@ -3490,6 +3861,9 @@ Expression* Parser::SpreadCall(Expression* function,
       VariableProxy* obj = factory()->NewVariableProxy(temp);
       Assignment* assign_obj = factory()->NewAssignment(
           Token::ASSIGN, obj, function->AsProperty()->obj(), kNoSourcePosition);
+
+      SetTempVarForExpression(assign_obj, true);
+
       function = factory()->NewProperty(
           assign_obj, function->AsProperty()->key(), kNoSourcePosition);
       args->Add(function, zone());
@@ -3509,7 +3883,28 @@ Expression* Parser::SpreadCallNew(Expression* function,
                                   ZonePtrList<Expression>* args_list, int pos) {
   if (OnlyLastArgIsSpread(args_list)) {
     // Handle in BytecodeGenerator.
-    return factory()->NewCallNew(function, args_list, pos);
+    Expression* expr = factory()->NewCallNew(function, args_list, pos);
+    Scope* closure_scope = scope();
+    while(closure_scope->outer_scope())
+      closure_scope = closure_scope->outer_scope();
+    gmutex.lock();
+    assign_id++;
+    std::string tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+    gmutex.unlock();
+    const AstRawString* tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+    closure_scope->NewUnresolved(factory(), tmp_token);
+    expr->set_allocated_temp_var(tmp);
+
+    gmutex.lock();
+    assign_id++;
+    tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+    gmutex.unlock();
+    const AstRawString* one_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+    closure_scope->NewUnresolved(factory(), one_tmp_token);
+    expr->set_allocated_temp_var_for_asg(tmp);
+
+
+    return expr;
   }
   ZonePtrList<Expression>* args =
       new (zone()) ZonePtrList<Expression>(2, zone());
@@ -3560,9 +3955,29 @@ void Parser::RewriteAsyncFunctionBody(ZonePtrList<Statement>* body,
   //     return %ResolvePromise(.promise, expr), .promise;
   //   })
   // }
-
-  block->statements()->Add(factory()->NewAsyncReturnStatement(
-                               return_value, return_value->position()),
+ 
+  ReturnStatement* return_statement = factory()->NewAsyncReturnStatement(return_value, return_value->position());
+  Scope* closure_scope = scope();
+  while(closure_scope->outer_scope())
+    closure_scope = closure_scope->outer_scope();
+  gmutex.lock();
+  assign_id++;
+  std::string tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+  gmutex.unlock();
+  const AstRawString* tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+  closure_scope->NewUnresolved(factory(), tmp_token);
+  return_statement->set_allocated_temp_var(tmp);
+
+  gmutex.lock();
+  assign_id++;
+  tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+  gmutex.unlock();
+  const AstRawString* one_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+  closure_scope->NewUnresolved(factory(), one_tmp_token);
+  return_statement->set_allocated_temp_var_for_asg(tmp);
+
+
+  block->statements()->Add(return_statement,
                            zone());
   block = BuildRejectPromiseOnException(block);
   body->Add(block, zone());
@@ -3615,7 +4030,8 @@ void Parser::SetFunctionNameFromPropertyName(LiteralProperty* property,
   }
 
   Expression* value = property->value();
-  SetFunctionName(value, name, prefix);
+
+  SetFunctionName(nullptr, value, name, prefix);
 }
 
 void Parser::SetFunctionNameFromPropertyName(ObjectLiteralProperty* property,
@@ -3633,14 +4049,16 @@ void Parser::SetFunctionNameFromPropertyName(ObjectLiteralProperty* property,
                                   prefix);
 }
 
-void Parser::SetFunctionNameFromIdentifierRef(Expression* value,
+void Parser::SetFunctionNameFromIdentifierRef(ParseInfo* info, Expression* value,
                                               Expression* identifier) {
   if (!identifier->IsVariableProxy()) return;
-  SetFunctionName(value, identifier->AsVariableProxy()->raw_name());
+  SetFunctionName(info, value, identifier->AsVariableProxy()->raw_name());
 }
 
-void Parser::SetFunctionName(Expression* value, const AstRawString* name,
-                             const AstRawString* prefix) {
+
+
+void Parser::SetFunctionName(ParseInfo* info, Expression* value, const AstRawString* name,
+                             const AstRawString* prefix) { 
   if (!value->IsAnonymousFunctionDefinition() &&
       !value->IsConciseMethodDefinition() &&
       !value->IsAccessorFunctionDefinition()) {
@@ -3661,7 +4079,9 @@ void Parser::SetFunctionName(Expression* value, const AstRawString* name,
     } else {
       DCHECK_NULL(prefix);
     }
+
     function->set_raw_name(cons_name);
+    declared_functions.push_back(ConvertIdentifierToString(name));
   }
 }
 
@@ -3684,6 +4104,8 @@ Statement* Parser::CheckCallable(Variable* var, Expression* error, int pos) {
   return validate_var;
 }
 
+
+
 void Parser::BuildIteratorClose(ZonePtrList<Statement>* statements,
                                 Variable* iterator, Variable* input,
                                 Variable* var_output, IteratorType type) {
@@ -3713,6 +4135,8 @@ void Parser::BuildIteratorClose(ZonePtrList<Statement>* statements,
     Expression* return_proxy = factory()->NewVariableProxy(var_return);
     Expression* assignment =
         factory()->NewAssignment(Token::ASSIGN, return_proxy, property, nopos);
+    SetTempVarForExpression(assignment, true);
+
     get_return = factory()->NewExpressionStatement(assignment, nopos);
   }
 
@@ -3750,6 +4174,8 @@ void Parser::BuildIteratorClose(ZonePtrList<Statement>* statements,
     Expression* output_proxy = factory()->NewVariableProxy(var_output);
     Expression* assignment =
         factory()->NewAssignment(Token::ASSIGN, output_proxy, call, nopos);
+    SetTempVarForExpression(assignment, true);
+
     call_return = factory()->NewExpressionStatement(assignment, nopos);
   }
 
@@ -3815,6 +4241,8 @@ void Parser::FinalizeIteratorUse(Variable* completion, Expression* condition,
     Expression* assignment = factory()->NewAssignment(
         Token::ASSIGN, proxy,
         factory()->NewSmiLiteral(Parser::kNormalCompletion, nopos), nopos);
+    SetTempVarForExpression(assignment, true);
+
     initialize_completion =
         factory()->NewExpressionStatement(assignment, nopos);
   }
@@ -3830,6 +4258,8 @@ void Parser::FinalizeIteratorUse(Variable* completion, Expression* condition,
     Expression* assignment = factory()->NewAssignment(
         Token::ASSIGN, proxy,
         factory()->NewSmiLiteral(Parser::kThrowCompletion, nopos), nopos);
+    SetTempVarForExpression(assignment, true);
+
     Statement* statement = factory()->NewExpressionStatement(assignment, nopos);
     set_completion_throw = factory()->NewIfStatement(
         condition, statement, factory()->NewEmptyStatement(nopos), nopos);
@@ -3938,6 +4368,8 @@ void Parser::BuildIteratorCloseForCompletion(ZonePtrList<Statement>* statements,
     Expression* return_proxy = factory()->NewVariableProxy(var_return);
     Expression* assignment =
         factory()->NewAssignment(Token::ASSIGN, return_proxy, property, nopos);
+    SetTempVarForExpression(assignment, true);
+
     get_return = factory()->NewExpressionStatement(assignment, nopos);
   }
 
@@ -3998,6 +4430,8 @@ void Parser::BuildIteratorCloseForCompletion(ZonePtrList<Statement>* statements,
       Expression* output_proxy = factory()->NewVariableProxy(var_output);
       Expression* assignment =
           factory()->NewAssignment(Token::ASSIGN, output_proxy, call, nopos);
+      SetTempVarForExpression(assignment, true);
+
       call_return = factory()->NewExpressionStatement(assignment, nopos);
     }
 
diff --git a/src/parsing/parser.h b/src/parsing/parser.h
index 35de065..ec8068d 100644
--- a/src/parsing/parser.h
+++ b/src/parsing/parser.h
@@ -6,9 +6,12 @@
 #define V8_PARSING_PARSER_H_
 
 #include <cstddef>
+//#include "src/parsing/global_maps.h"
+#include <fstream>
 
 #include "src/ast/ast-source-ranges.h"
 #include "src/ast/ast.h"
+#include "src/parsing/expression-printer.h"
 #include "src/ast/scopes.h"
 #include "src/base/compiler-specific.h"
 #include "src/base/threaded-list.h"
@@ -18,6 +21,8 @@
 #include "src/parsing/preparser.h"
 #include "src/zone/zone-chunk-list.h"
 
+
+
 namespace v8 {
 
 class ScriptCompiler;
@@ -159,6 +164,7 @@ class V8_EXPORT_PRIVATE Parser : public NON_EXPORTED_BASE(ParserBase<Parser>) {
   static bool IsPreParser() { return false; }
 
   void ParseOnBackground(ParseInfo* info);
+  bool LogFunctionInfo(FunctionLiteral* function, bool force_infer_name, std::string func_name_str, bool force_log);
 
   // Initializes an empty scope chain for top-level scripts, or scopes which
   // consist of only the native context.
@@ -179,6 +185,60 @@ class V8_EXPORT_PRIVATE Parser : public NON_EXPORTED_BASE(ParserBase<Parser>) {
   void UpdateStatistics(Isolate* isolate, Handle<Script> script);
   void HandleSourceURLComments(Isolate* isolate, Handle<Script> script);
 
+
+
+
+
+  void appendDeclarationParam(DeclarationScope* scope, Expression* param, Expression* initializer, ParseInfo* info);
+
+
+
+
+
+  VariableProxy* PublicExpressionFromIdentifier(
+      const AstRawString* name, DeclarationScope* scope, AstNodeFactory* factory,
+      InferName infer = InferName::kYes) {
+
+    if (infer == InferName::kYes) {
+      fni_.PushVariableName(name);
+    }
+
+    return NewUnresolved(name, scope, factory);
+  }
+
+
+
+
+
+  Expression* PublicExpressionFromString(const AstRawString* symbol, Scope* scope, AstNodeFactory* factory) {
+    //const AstRawString* symbol = GetSymbol();
+    fni_.PushLiteralName(symbol);
+    return factory->NewStringLiteral(symbol, -1);
+  }
+
+
+
+  ZonePtrList<Expression>* PublicNewExpressionList(int size) const {
+    return new (zone()) ZonePtrList<Expression>(size, zone());
+  }
+
+
+  ZonePtrList<ObjectLiteral::Property>* PublicNewObjectPropertyList(
+      int size) const {
+    return new (zone()) ZonePtrList<ObjectLiteral::Property>(size, zone());
+  }
+
+
+
+  ObjectLiteral* PublicInitializeObjectLiteral(ObjectLiteral* object_literal) {
+    object_literal->CalculateEmitStore(main_zone());
+    return object_literal;
+  }
+
+
+
+
+
  private:
   friend class ParserBase<Parser>;
   friend class v8::internal::ExpressionClassifierErrorTracker<
@@ -263,12 +323,12 @@ class V8_EXPORT_PRIVATE Parser : public NON_EXPORTED_BASE(ParserBase<Parser>) {
     return reusable_preparser_;
   }
 
-  void ParseModuleItemList(ZonePtrList<Statement>* body, bool* ok);
-  Statement* ParseModuleItem(bool* ok);
+  void ParseModuleItemList(ParseInfo* info, ZonePtrList<Statement>* body, bool* ok);
+  Statement* ParseModuleItem(ParseInfo* info, bool* ok);
   const AstRawString* ParseModuleSpecifier(bool* ok);
-  void ParseImportDeclaration(bool* ok);
-  Statement* ParseExportDeclaration(bool* ok);
-  Statement* ParseExportDefault(bool* ok);
+  void ParseImportDeclaration(ParseInfo* info, bool* ok);
+  Statement* ParseExportDeclaration(ParseInfo* info, bool* ok);
+  Statement* ParseExportDefault(ParseInfo* info, bool* ok);
   struct ExportClauseData {
     const AstRawString* export_name;
     const AstRawString* local_name;
@@ -305,10 +365,10 @@ class V8_EXPORT_PRIVATE Parser : public NON_EXPORTED_BASE(ParserBase<Parser>) {
                                  Block* finally_block,
                                  const SourceRange& finally_range,
                                  const CatchInfo& catch_info, int pos);
-  void ParseAndRewriteGeneratorFunctionBody(int pos, FunctionKind kind,
+  void ParseAndRewriteGeneratorFunctionBody(ParseInfo* info, int pos, FunctionKind kind,
                                             ZonePtrList<Statement>* body,
                                             bool* ok);
-  void ParseAndRewriteAsyncGeneratorFunctionBody(int pos, FunctionKind kind,
+  void ParseAndRewriteAsyncGeneratorFunctionBody(ParseInfo* info, int pos, FunctionKind kind,
                                                  ZonePtrList<Statement>* body,
                                                  bool* ok);
   void DeclareFunctionNameVar(const AstRawString* function_name,
@@ -318,7 +378,7 @@ class V8_EXPORT_PRIVATE Parser : public NON_EXPORTED_BASE(ParserBase<Parser>) {
   Statement* DeclareFunction(const AstRawString* variable_name,
                              FunctionLiteral* function, VariableMode mode,
                              int pos, bool is_sloppy_block_function,
-                             ZonePtrList<const AstRawString>* names, bool* ok);
+                             ZonePtrList<const AstRawString>* names, bool* ok, ParseInfo* info=nullptr);
   Variable* CreateSyntheticContextVariable(const AstRawString* synthetic_name,
                                            bool* ok);
   FunctionLiteral* CreateInitializerFunction(
@@ -391,7 +451,7 @@ class V8_EXPORT_PRIVATE Parser : public NON_EXPORTED_BASE(ParserBase<Parser>) {
   Expression* RewriteDoExpression(Block* body, int pos, bool* ok);
 
   FunctionLiteral* ParseFunctionLiteral(
-      const AstRawString* name, Scanner::Location function_name_location,
+      ParseInfo* info, const AstRawString* name, Scanner::Location function_name_location,
       FunctionNameValidity function_name_validity, FunctionKind kind,
       int function_token_position, FunctionLiteral::FunctionType type,
       LanguageMode language_mode,
@@ -425,7 +485,7 @@ class V8_EXPORT_PRIVATE Parser : public NON_EXPORTED_BASE(ParserBase<Parser>) {
 
   VariableProxy* NewUnresolved(const AstRawString* name, int begin_pos,
                                VariableKind kind = NORMAL_VARIABLE);
-  VariableProxy* NewUnresolved(const AstRawString* name);
+  VariableProxy* NewUnresolved(const AstRawString* name, Scope* scope=nullptr, AstNodeFactory* factory=nullptr);
   Variable* Declare(Declaration* declaration,
                     DeclarationDescriptor::Kind declaration_kind,
                     VariableMode mode, InitializationFlag init, bool* ok,
@@ -469,7 +529,7 @@ class V8_EXPORT_PRIVATE Parser : public NON_EXPORTED_BASE(ParserBase<Parser>) {
   Block* BuildRejectPromiseOnException(Block* block);
 
   ZonePtrList<Statement>* ParseFunction(
-      const AstRawString* function_name, int pos, FunctionKind kind,
+      ParseInfo* info, const AstRawString* function_name, int pos, FunctionKind kind,
       FunctionLiteral::FunctionType function_type,
       DeclarationScope* function_scope, int* num_parameters,
       int* function_length, bool* has_duplicate_parameters,
@@ -578,7 +638,7 @@ class V8_EXPORT_PRIVATE Parser : public NON_EXPORTED_BASE(ParserBase<Parser>) {
   void AddArrowFunctionFormalParameters(ParserFormalParameters* parameters,
                                         Expression* params, int end_pos,
                                         bool* ok);
-  void SetFunctionName(Expression* value, const AstRawString* name,
+  void SetFunctionName(ParseInfo* info, Expression* value, const AstRawString* name,
                        const AstRawString* prefix = nullptr);
 
   // Helper functions for recursive descent.
@@ -683,6 +743,169 @@ class V8_EXPORT_PRIVATE Parser : public NON_EXPORTED_BASE(ParserBase<Parser>) {
     fni_.PushVariableName(id);
   }
 
+
+  V8_INLINE void appendDeclaration(ExpressionT expr, ParseInfo* info) {
+    info->appendDeclaration(expr);
+  }
+
+
+  V8_INLINE void PrintExpression(ParseInfo* info, ExpressionT expr) {
+    if(info && expr)
+      std::cout << "  " << ExpressionPrinter(info->stack_limit()).Print(expr)  << ",  info: " << info << std::endl;
+  }
+
+
+  V8_INLINE std::string ConvertIdentifierToString(const AstRawString* identifier) {
+    if(identifier) {
+      std::string str;
+      const unsigned char* raw_str = identifier->raw_data();
+      if(raw_str != nullptr) {
+        const int increment = identifier->is_one_byte() ? 1:2;
+        for(int i=0; i<identifier->length(); i+=increment) {
+          str += raw_str[i];
+        }
+      }
+      return str;
+    }
+    else
+      return "";
+
+  }
+
+
+
+  V8_INLINE ExpressionT construct_asg_for_obj_literal(ExpressionT expr, ExpressionT rhs, bool* flag) {
+    const char* tmp_char = expr->allocated_temp_var().c_str(); //mpl()->retrieve_temp_char(obj_lit);
+    IdentifierT tmp_token = parse_info_->ast_value_factory()->GetOneByteString(tmp_char);
+    ExpressionT tmp = ExpressionFromIdentifier(tmp_token, position(), InferName::kNo);
+    ExpressionT extra_asg = nullptr;
+    if(parse_info_->script_id()>=17 && parse_info_->script_scope()->PublicResolveVariable(parse_info_, tmp->AsVariableProxy())) {
+      *flag = true;
+      extra_asg = factory()->NewAssignment(Token::ASSIGN, tmp, rhs, position()); 
+      extra_asg->set_should_break(false);
+      extra_asg->AsAssignment()->set_expr_for_typeof(tmp);
+      extra_asg->set_allocated_temp_var(std::string(tmp_char));
+    }
+    else {
+      *flag = false;
+    }
+    return extra_asg;
+  }
+
+
+
+  V8_INLINE std::string ConvertIdentifierOrStringLiteralToString(Expression* exp) {
+    if(IsIdentifier(exp))
+      return ConvertIdentifierToString(AsIdentifier(exp));
+    else 
+      return ConvertIdentifierToString(exp->AsLiteral()->AsRawString());
+  }
+
+
+
+  V8_INLINE void DeclareWindowAsUnresolved(FunctionLiteralT function_literal) {
+    if(function_literal == nullptr)
+      return;
+    Scope* closure_scope = function_literal->scope();
+    while(closure_scope->outer_scope())
+      closure_scope = closure_scope->outer_scope();
+
+    const AstRawString* window = factory()->ast_value_factory()->GetOneByteString("window");
+    closure_scope->NewUnresolved(factory(), window);  
+    const AstRawString* object = factory()->ast_value_factory()->GetOneByteString("Object");
+    closure_scope->NewUnresolved(factory(), object);  
+    const AstRawString* globalID = factory()->ast_value_factory()->GetOneByteString("Yx$Q7r$zJUnQUy__GlobalID");
+    closure_scope->NewUnresolved(factory(), globalID);  
+    const AstRawString* frameID = factory()->ast_value_factory()->GetOneByteString("Yx$Q7r$zJUnQUy__FrameID");
+    closure_scope->NewUnresolved(factory(), frameID);  
+  }
+
+
+  V8_INLINE void SetTempVarForObjectLiteralProperty(ObjectLiteralPropertyT prop) {
+    Scope* closure_scope = scope();
+    while(closure_scope->outer_scope())
+      closure_scope = closure_scope->outer_scope();
+
+    gmutex.lock();
+    assign_id++;
+    std::string tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+    gmutex.unlock();
+    const AstRawString* tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+    closure_scope->NewUnresolved(factory(), tmp_token);
+    prop->set_allocated_temp_var(tmp);
+  }
+
+  // if flag = True, we need to allocate one more temp variable because 
+  // later in the interpreter, an extra assignment would be created for this statement
+  V8_INLINE void SetTempVarForStatement(StatementT expr, bool flag=false) {
+    Scope* closure_scope = scope();
+    while(closure_scope->outer_scope())
+      closure_scope = closure_scope->outer_scope();
+
+    gmutex.lock();
+    assign_id++;
+    std::string tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+    gmutex.unlock();
+    const AstRawString* tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+    closure_scope->NewUnresolved(factory(), tmp_token);
+    expr->set_allocated_temp_var(tmp);
+
+    if(flag) {
+      gmutex.lock();
+      assign_id++;
+      tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+      gmutex.unlock();
+      const AstRawString* one_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+      closure_scope->NewUnresolved(factory(), one_tmp_token);
+      expr->set_allocated_temp_var_for_asg(tmp);
+    }
+  }
+
+
+
+  V8_INLINE void SetTempVarForExpression(ExpressionT expr, bool flag=false) {
+    Scope* closure_scope = scope();
+    while(closure_scope->outer_scope())
+      closure_scope = closure_scope->outer_scope();
+    gmutex.lock();
+    assign_id++;
+    std::string tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+    gmutex.unlock();
+    const AstRawString* tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+    closure_scope->NewUnresolved(factory(), tmp_token);
+    expr->set_allocated_temp_var(tmp);
+
+    if(flag) {
+      gmutex.lock();
+      assign_id++;
+      tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+      gmutex.unlock();
+      const AstRawString* one_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+      closure_scope->NewUnresolved(factory(), one_tmp_token);
+      expr->set_allocated_temp_var_for_asg(tmp);
+    }
+
+  }
+
+
+
+  V8_INLINE void SetFunctionID(FunctionLiteral* func, int id) {
+    //func->set_function_id(id);
+  }
+  
+
+  V8_INLINE void PushNewedFunction(ExpressionT var_name, ExpressionT value, ParseInfo* info) {
+    //PrintExpression(info, value->AsCallNew()->expression());
+    if(info == nullptr)
+      return;
+    std::string newed_type(ExpressionPrinter(info->stack_limit()).Print(value->AsCallNew()->expression()));
+    if(newed_type == std::string("Function")) {
+      declared_functions.push_back(ExpressionPrinter(info->stack_limit()).Print(var_name));
+    }
+  }
+
+
+
   V8_INLINE void PushPropertyName(Expression* expression) {
     if (expression->IsPropertyName()) {
       fni_.PushLiteralName(expression->AsLiteral()->AsRawPropertyName());
@@ -704,7 +927,7 @@ class V8_EXPORT_PRIVATE Parser : public NON_EXPORTED_BASE(ParserBase<Parser>) {
   // If we assign a function literal to a property we pretenure the
   // literal so it can be added as a constant function property.
   V8_INLINE static void CheckAssigningFunctionLiteralToProperty(
-      Expression* left, Expression* right) {
+      ParseInfo* info, Expression* left, Expression* right, bool is_this) {
     DCHECK_NOT_NULL(left);
     if (left->IsProperty() && right->IsFunctionLiteral()) {
       right->AsFunctionLiteral()->set_pretenure();
@@ -865,16 +1088,19 @@ class V8_EXPORT_PRIVATE Parser : public NON_EXPORTED_BASE(ParserBase<Parser>) {
   V8_INLINE VariableProxy* ExpressionFromIdentifier(
       const AstRawString* name, int start_position,
       InferName infer = InferName::kYes) {
+
     if (infer == InferName::kYes) {
       fni_.PushVariableName(name);
     }
+
     return NewUnresolved(name, start_position);
   }
 
-  V8_INLINE Expression* ExpressionFromString(int pos) {
+  V8_INLINE Expression* ExpressionFromString(int pos, bool quote=false) {
     const AstRawString* symbol = GetSymbol();
     fni_.PushLiteralName(symbol);
-    return factory()->NewStringLiteral(symbol, pos);
+
+    return factory()->NewStringLiteral(symbol, pos, quote);
   }
 
   V8_INLINE ZonePtrList<Expression>* NewExpressionList(int size) const {
@@ -953,7 +1179,7 @@ class V8_EXPORT_PRIVATE Parser : public NON_EXPORTED_BASE(ParserBase<Parser>) {
                                        const AstRawString* name,
                                        const AstRawString* prefix = nullptr);
 
-  void SetFunctionNameFromIdentifierRef(Expression* value,
+  void SetFunctionNameFromIdentifierRef(ParseInfo* info, Expression* value,
                                         Expression* identifier);
 
   V8_INLINE ZoneList<typename ExpressionClassifier::Error>*
@@ -1120,6 +1346,7 @@ class V8_EXPORT_PRIVATE Parser : public NON_EXPORTED_BASE(ParserBase<Parser>) {
   // indicates the correct position of the ')' that closes the parameter list.
   // After that ')' is encountered, this field is reset to kNoSourcePosition.
   int parameters_end_pos_;
+  ParseInfo* parse_info_;
 };
 
 // ----------------------------------------------------------------------------
diff --git a/src/parsing/parsing.cc b/src/parsing/parsing.cc
index 378023c..5bf2eaa 100644
--- a/src/parsing/parsing.cc
+++ b/src/parsing/parsing.cc
@@ -1,7 +1,8 @@
 // Copyright 2016 the V8 project authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-
+#include <iostream>
+#include <fstream>
 #include "src/parsing/parsing.h"
 
 #include <memory>
@@ -13,6 +14,8 @@
 #include "src/parsing/scanner-character-streams.h"
 #include "src/vm-state-inl.h"
 
+#include "src/parsing/expression-printer.h"
+
 namespace v8 {
 namespace internal {
 namespace parsing {
@@ -49,6 +52,7 @@ bool ParseProgram(ParseInfo* info, Isolate* isolate) {
     }
   }
   parser.UpdateStatistics(isolate, info->script());
+
   return (result != nullptr);
 }
 
@@ -85,7 +89,7 @@ bool ParseFunction(ParseInfo* info, Handle<SharedFunctionInfo> shared_info,
       info->set_allow_eval_cache(parser.allow_eval_cache());
     }
   }
-  parser.UpdateStatistics(isolate, info->script());
+  parser.UpdateStatistics(isolate, info->script());  
   return (result != nullptr);
 }
 
diff --git a/src/parsing/pattern-rewriter.cc b/src/parsing/pattern-rewriter.cc
index 4465670..29ec172 100644
--- a/src/parsing/pattern-rewriter.cc
+++ b/src/parsing/pattern-rewriter.cc
@@ -188,6 +188,26 @@ void PatternRewriter::VisitVariableProxy(VariableProxy* pattern) {
     // In an assignment context, simply perform the assignment
     Assignment* assignment = factory()->NewAssignment(
         Token::ASSIGN, pattern, value, pattern->position());
+
+    Scope* closure_scope = scope();
+    while(closure_scope->outer_scope())
+      closure_scope = closure_scope->outer_scope();
+    gmutex.lock();
+    assign_id++;
+    std::string tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+    gmutex.unlock();
+    const AstRawString* tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+    closure_scope->NewUnresolved(factory(), tmp_token);
+    assignment->set_allocated_temp_var(tmp);
+    
+    gmutex.lock();
+    assign_id++;
+    tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+    gmutex.unlock();
+    const AstRawString* one_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+    closure_scope->NewUnresolved(factory(), one_tmp_token);
+    assignment->set_allocated_temp_var_for_asg(tmp);
+
     block_->statements()->Add(
         factory()->NewExpressionStatement(assignment, pattern->position()),
         zone());
@@ -294,6 +314,25 @@ void PatternRewriter::VisitVariableProxy(VariableProxy* pattern) {
   }
   Assignment* assignment =
       factory()->NewAssignment(Token::INIT, proxy, value, pos);
+  Scope* closure_scope = scope();
+  while(closure_scope->outer_scope())
+    closure_scope = closure_scope->outer_scope();
+  gmutex.lock();
+  assign_id++;
+  std::string tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+  gmutex.unlock();
+  const AstRawString* tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+  closure_scope->NewUnresolved(factory(), tmp_token);
+  assignment->set_allocated_temp_var(tmp);
+
+  gmutex.lock();
+  assign_id++;
+  tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+  gmutex.unlock();
+  const AstRawString* one_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+  closure_scope->NewUnresolved(factory(), one_tmp_token);
+  assignment->set_allocated_temp_var_for_asg(tmp);
+
   block_->statements()->Add(factory()->NewExpressionStatement(assignment, pos),
                             zone());
 }
@@ -304,6 +343,24 @@ Variable* PatternRewriter::CreateTempVar(Expression* value) {
     auto assignment = factory()->NewAssignment(
         Token::ASSIGN, factory()->NewVariableProxy(temp), value,
         kNoSourcePosition);
+    Scope* closure_scope = scope();
+    while(closure_scope->outer_scope())
+      closure_scope = closure_scope->outer_scope();
+    gmutex.lock();
+    assign_id++;
+    std::string tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+    gmutex.unlock();
+    const AstRawString* tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+    closure_scope->NewUnresolved(factory(), tmp_token);
+    assignment->set_allocated_temp_var(tmp);
+
+    gmutex.lock();
+    assign_id++;
+    tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+    gmutex.unlock();
+    const AstRawString* one_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+    closure_scope->NewUnresolved(factory(), one_tmp_token);
+    assignment->set_allocated_temp_var_for_asg(tmp);
 
     block_->statements()->Add(
         factory()->NewExpressionStatement(assignment, kNoSourcePosition),
@@ -461,6 +518,24 @@ void PatternRewriter::VisitArrayLiteral(ArrayLiteral* node,
       auto assign_undefined = factory()->NewAssignment(
           Token::ASSIGN, factory()->NewVariableProxy(v),
           factory()->NewUndefinedLiteral(kNoSourcePosition), kNoSourcePosition);
+      Scope* closure_scope = scope();
+      while(closure_scope->outer_scope())
+        closure_scope = closure_scope->outer_scope();
+      gmutex.lock();
+      assign_id++;
+      std::string tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+      gmutex.unlock();
+      const AstRawString* tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+      closure_scope->NewUnresolved(factory(), tmp_token);
+      assign_undefined->set_allocated_temp_var(tmp);
+
+      gmutex.lock();
+      assign_id++;
+      tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+      gmutex.unlock();
+      const AstRawString* one_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+      closure_scope->NewUnresolved(factory(), one_tmp_token);
+      assign_undefined->set_allocated_temp_var_for_asg(tmp);
 
       auto assign_value = factory()->NewAssignment(
           Token::ASSIGN, factory()->NewVariableProxy(v),
@@ -471,11 +546,45 @@ void PatternRewriter::VisitArrayLiteral(ArrayLiteral* node,
               kNoSourcePosition),
           kNoSourcePosition);
 
+      gmutex.lock();
+      assign_id++;
+      tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+      gmutex.unlock();
+      const AstRawString* two_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+      closure_scope->NewUnresolved(factory(), two_tmp_token);
+      assign_value->set_allocated_temp_var(tmp);
+
+      gmutex.lock();
+      assign_id++;
+      tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+      gmutex.unlock();
+      const AstRawString* three_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+      closure_scope->NewUnresolved(factory(), three_tmp_token);
+      assign_value->set_allocated_temp_var_for_asg(tmp);
+
       auto unset_done = factory()->NewAssignment(
           Token::ASSIGN, factory()->NewVariableProxy(done),
           factory()->NewBooleanLiteral(false, kNoSourcePosition),
           kNoSourcePosition);
 
+
+      gmutex.lock();
+      assign_id++;
+      tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+      gmutex.unlock();
+      const AstRawString* four_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+      closure_scope->NewUnresolved(factory(), four_tmp_token);
+      unset_done->set_allocated_temp_var(tmp);
+
+      gmutex.lock();
+      assign_id++;
+      tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+      gmutex.unlock();
+      const AstRawString* five_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+      closure_scope->NewUnresolved(factory(), five_tmp_token);
+      unset_done->set_allocated_temp_var_for_asg(tmp);
+
+
       auto inner_else = factory()->NewBlock(2, true);
       inner_else->statements()->Add(
           factory()->NewExpressionStatement(assign_value, nopos), zone());
@@ -488,11 +597,28 @@ void PatternRewriter::VisitArrayLiteral(ArrayLiteral* node,
           inner_else, nopos);
 
       auto next_block = factory()->NewBlock(3, true);
+
+
+      Assignment* assignment = factory()->NewAssignment(Token::ASSIGN, factory()->NewVariableProxy(done), factory()->NewBooleanLiteral(true, nopos), nopos);
+      gmutex.lock();
+      assign_id++;
+      tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+      gmutex.unlock();
+      const AstRawString* six_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+      closure_scope->NewUnresolved(factory(), six_tmp_token);
+      assignment->set_allocated_temp_var(tmp);
+
+      gmutex.lock();
+      assign_id++;
+      tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+      gmutex.unlock();
+      const AstRawString* seven_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+      closure_scope->NewUnresolved(factory(), seven_tmp_token);
+      assignment->set_allocated_temp_var_for_asg(tmp);
+
       next_block->statements()->Add(
           factory()->NewExpressionStatement(
-              factory()->NewAssignment(
-                  Token::ASSIGN, factory()->NewVariableProxy(done),
-                  factory()->NewBooleanLiteral(true, nopos), nopos),
+              assignment,
               nopos),
           zone());
       next_block->statements()->Add(
@@ -520,6 +646,25 @@ void PatternRewriter::VisitArrayLiteral(ArrayLiteral* node,
         Expression* assignment = factory()->NewAssignment(
             Token::ASSIGN, proxy,
             factory()->NewSmiLiteral(Parser::kAbruptCompletion, nopos), nopos);
+        Scope* closure_scope = scope();
+        while(closure_scope->outer_scope())
+          closure_scope = closure_scope->outer_scope();
+        gmutex.lock();
+        assign_id++;
+        std::string tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+        gmutex.unlock();
+        const AstRawString* tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+        closure_scope->NewUnresolved(factory(), tmp_token);
+        assignment->set_allocated_temp_var(tmp);
+
+        gmutex.lock();
+        assign_id++;
+        tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+        gmutex.unlock();
+        const AstRawString* one_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+        closure_scope->NewUnresolved(factory(), one_tmp_token);
+        assignment->set_allocated_temp_var_for_asg(tmp);
+
         block_->statements()->Add(
             factory()->NewExpressionStatement(assignment, nopos), zone());
       }
@@ -532,6 +677,25 @@ void PatternRewriter::VisitArrayLiteral(ArrayLiteral* node,
         Expression* assignment = factory()->NewAssignment(
             Token::ASSIGN, proxy,
             factory()->NewSmiLiteral(Parser::kNormalCompletion, nopos), nopos);
+        Scope* closure_scope = scope();
+        while(closure_scope->outer_scope())
+          closure_scope = closure_scope->outer_scope();
+        gmutex.lock();
+        assign_id++;
+        std::string tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+        gmutex.unlock();
+        const AstRawString* tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+        closure_scope->NewUnresolved(factory(), tmp_token);
+        assignment->set_allocated_temp_var(tmp);
+
+        gmutex.lock();
+        assign_id++;
+        tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+        gmutex.unlock();
+        const AstRawString* one_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+        closure_scope->NewUnresolved(factory(), one_tmp_token);
+        assignment->set_allocated_temp_var_for_asg(tmp);
+
         block_->statements()->Add(
             factory()->NewExpressionStatement(assignment, nopos), zone());
       }
@@ -567,10 +731,29 @@ void PatternRewriter::VisitArrayLiteral(ArrayLiteral* node,
         CreateTempVar(factory()->NewSmiLiteral(0, kNoSourcePosition));
 
     // done = true;
+    Assignment* assignment = factory()->NewAssignment(Token::ASSIGN, factory()->NewVariableProxy(done), factory()->NewBooleanLiteral(true, nopos), nopos);
+    Scope* closure_scope = scope();
+    while(closure_scope->outer_scope())
+      closure_scope = closure_scope->outer_scope();
+    gmutex.lock();
+    assign_id++;
+    std::string tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+    gmutex.unlock();
+    const AstRawString* tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+    closure_scope->NewUnresolved(factory(), tmp_token);
+    assignment->set_allocated_temp_var(tmp);
+
+    gmutex.lock();
+    assign_id++;
+    tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+    gmutex.unlock();
+    const AstRawString* one_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+    closure_scope->NewUnresolved(factory(), one_tmp_token);
+    assignment->set_allocated_temp_var_for_asg(tmp);
+
+
     Statement* set_done = factory()->NewExpressionStatement(
-        factory()->NewAssignment(
-            Token::ASSIGN, factory()->NewVariableProxy(done),
-            factory()->NewBooleanLiteral(true, nopos), nopos),
+        assignment,
         nopos);
 
     // result = IteratorNext(iterator);
@@ -596,10 +779,27 @@ void PatternRewriter::VisitArrayLiteral(ArrayLiteral* node,
     }
 
     // done = false;
+    Assignment* one_assignment = factory()->NewAssignment(Token::ASSIGN, factory()->NewVariableProxy(done), factory()->NewBooleanLiteral(false, nopos), nopos);
+    gmutex.lock();
+    assign_id++;
+    tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+    gmutex.unlock();
+    const AstRawString* two_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+    closure_scope->NewUnresolved(factory(), two_tmp_token);
+    one_assignment->set_allocated_temp_var(tmp);
+
+    gmutex.lock();
+    assign_id++;
+    tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+    gmutex.unlock();
+    const AstRawString* three_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+    closure_scope->NewUnresolved(factory(), three_tmp_token);
+    one_assignment->set_allocated_temp_var_for_asg(tmp);
+
+
+
     Statement* unset_done = factory()->NewExpressionStatement(
-        factory()->NewAssignment(
-            Token::ASSIGN, factory()->NewVariableProxy(done),
-            factory()->NewBooleanLiteral(false, nopos), nopos),
+        one_assignment,
         nopos);
 
     // if (!result.done) { #store; #unset_done }
@@ -683,6 +883,26 @@ void PatternRewriter::VisitAssignment(Assignment* node) {
   value = factory()->NewConditional(is_undefined, initializer,
                                     factory()->NewVariableProxy(temp),
                                     kNoSourcePosition);
+  Scope* closure_scope = scope();
+  while(closure_scope->outer_scope())
+    closure_scope = closure_scope->outer_scope();
+  gmutex.lock();
+  assign_id++;
+  std::string tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+  gmutex.unlock();
+  const AstRawString* tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+  //AstNodeFactory ast_node_factory(info->GetOrCreateAstValueFactory(), info->zone());
+  closure_scope->NewUnresolved(factory(), tmp_token);
+  value->set_allocated_temp_var(tmp);
+
+  gmutex.lock();
+  assign_id++;
+  tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+  gmutex.unlock();
+  const AstRawString* one_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+  //AstNodeFactory ast_node_factory(info->GetOrCreateAstValueFactory(), info->zone());
+  closure_scope->NewUnresolved(factory(), one_tmp_token);
+  value->set_allocated_temp_var_for_asg(tmp);
 
   // Initializer may have been parsed in the wrong scope.
   RewriteParameterScopes(initializer);
@@ -699,6 +919,24 @@ void PatternRewriter::VisitProperty(v8::internal::Property* node) {
 
   Assignment* assignment =
       factory()->NewAssignment(Token::ASSIGN, node, value, node->position());
+  Scope* closure_scope = scope();
+  while(closure_scope->outer_scope())
+    closure_scope = closure_scope->outer_scope();
+  gmutex.lock();
+  assign_id++;
+  std::string tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+  gmutex.unlock();
+  const AstRawString* tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+  closure_scope->NewUnresolved(factory(), tmp_token);
+  assignment->set_allocated_temp_var(tmp);
+
+  gmutex.lock();
+  assign_id++;
+  tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+  gmutex.unlock();
+  const AstRawString* one_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+  closure_scope->NewUnresolved(factory(), one_tmp_token);
+  assignment->set_allocated_temp_var_for_asg(tmp);
 
   block_->statements()->Add(
       factory()->NewExpressionStatement(assignment, kNoSourcePosition), zone());
diff --git a/src/parsing/preparser.cc b/src/parsing/preparser.cc
index 0e74014..327c7a6 100644
--- a/src/parsing/preparser.cc
+++ b/src/parsing/preparser.cc
@@ -1,7 +1,7 @@
 // Copyright 2011 the V8 project authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
-
+#include "src/ast/prettyprinter.h"
 #include <cmath>
 
 #include "src/allocation.h"
@@ -104,7 +104,8 @@ PreParser::PreParseResult PreParser::PreParseProgram() {
   bool ok = true;
   int start_position = scanner()->peek_location().beg_pos;
   PreParserStatementList body;
-  ParseStatementList(body, Token::EOS, &ok);
+
+  ParseStatementList(nullptr, body, Token::EOS, &ok); 
   original_scope_ = nullptr;
   if (stack_overflow()) return kPreParseStackOverflow;
   if (!ok) {
@@ -167,11 +168,13 @@ PreParser::PreParseResult PreParser::PreParseFunction(
     formals_classifier.reset(new ExpressionClassifier(this, &duplicate_finder));
     // We return kPreParseSuccess in failure cases too - errors are retrieved
     // separately by Parser::SkipLazyFunctionBody.
+    
     ParseFormalParameterList(
+        nullptr,
         &formals,
         CHECK_OK_VALUE(pending_error_handler()->ErrorUnidentifiableByPreParser()
                            ? kPreParseNotIdentifiableError
-                           : kPreParseSuccess));
+                           : kPreParseSuccess)); 
     Expect(Token::RPAREN, CHECK_OK_VALUE(kPreParseSuccess));
     int formals_end_position = scanner()->location().end_pos;
 
@@ -184,7 +187,7 @@ PreParser::PreParseResult PreParser::PreParseFunction(
   DeclarationScope* inner_scope = function_scope;
   LazyParsingResult result;
 
-  if (!formals.is_simple) {
+  if(!formals.is_simple) {
     inner_scope = NewVarblockScope();
     inner_scope->set_start_position(scanner()->location().beg_pos);
   }
@@ -283,16 +286,19 @@ PreParser::PreParseResult PreParser::PreParseFunction(
 // it is used) are generally omitted.
 
 PreParser::Expression PreParser::ParseFunctionLiteral(
-    Identifier function_name, Scanner::Location function_name_location,
+    ParseInfo* info, Identifier function_name, Scanner::Location function_name_location,
     FunctionNameValidity function_name_validity, FunctionKind kind,
     int function_token_pos, FunctionLiteral::FunctionType function_type,
     LanguageMode language_mode,
     ZonePtrList<const AstRawString>* arguments_for_wrapped_function, bool* ok) {
   // Wrapped functions are not parsed in the preparser.
+
   DCHECK_NULL(arguments_for_wrapped_function);
   DCHECK_NE(FunctionLiteral::kWrapped, function_type);
   // Function ::
   //   '(' FormalParameterList? ')' '{' FunctionBody '}'
+  //
+
   const RuntimeCallCounterId counters[2][2] = {
       {RuntimeCallCounterId::kPreParseBackgroundNoVariableResolution,
        RuntimeCallCounterId::kPreParseNoVariableResolution},
@@ -316,6 +322,7 @@ PreParser::Expression PreParser::ParseFunctionLiteral(
       preparsed_scope_data_builder_ != nullptr) {
     DCHECK(FLAG_preparser_scope_analysis);
     DCHECK(track_unresolved_variables_);
+
     preparsed_scope_data_builder_scope.reset(
         new PreParsedScopeDataBuilder::DataGatheringScope(function_scope,
                                                           this));
@@ -330,7 +337,7 @@ PreParser::Expression PreParser::ParseFunctionLiteral(
   int start_position = scanner()->location().beg_pos;
   function_scope->set_start_position(start_position);
   PreParserFormalParameters formals(function_scope);
-  ParseFormalParameterList(&formals, CHECK_OK);
+  ParseFormalParameterList(info, &formals, CHECK_OK);
   Expect(Token::RPAREN, CHECK_OK);
   int formals_end_position = scanner()->location().end_pos;
 
@@ -343,7 +350,7 @@ PreParser::Expression PreParser::ParseFunctionLiteral(
   PreParserStatementList body;
   int pos = function_token_pos == kNoSourcePosition ? peek_position()
                                                     : function_token_pos;
-  ParseFunctionBody(body, function_name, pos, formals, kind, function_type,
+  ParseFunctionBody(info, body, function_name, pos, formals, kind, function_type,
                     FunctionBodyType::kBlock, true, CHECK_OK);
 
   // Parsing the body may change the language mode in our scope.
@@ -388,15 +395,15 @@ PreParser::Expression PreParser::ParseFunctionLiteral(
         event_name, script_id(), ms, function_scope->start_position(),
         function_scope->end_position(), name, name_byte_length);
   }
-
   return Expression::Default();
 }
 
 PreParser::LazyParsingResult PreParser::ParseStatementListAndLogFunction(
     PreParserFormalParameters* formals, bool may_abort, bool* ok) {
   PreParserStatementList body;
+
   LazyParsingResult result = ParseStatementList(
-      body, Token::RBRACE, may_abort, CHECK_OK_VALUE(kLazyParsingComplete));
+      nullptr, body, Token::RBRACE, may_abort, CHECK_OK_VALUE(kLazyParsingComplete));
   if (result == kLazyParsingAborted) return result;
 
   // Position right after terminal '}'.
diff --git a/src/parsing/preparser.h b/src/parsing/preparser.h
index 65509a2..dc0d5d7 100644
--- a/src/parsing/preparser.h
+++ b/src/parsing/preparser.h
@@ -415,6 +415,7 @@ class PreParserExpression {
   friend class PreParser;
   friend class PreParserFactory;
   friend class PreParserExpressionList;
+
 };
 
 
@@ -1037,6 +1038,17 @@ class PreParser : public ParserBase<PreParser> {
     preparsed_scope_data_builder_ = preparsed_scope_data_builder;
   }
 
+  V8_INLINE void SetExpressionAsGlobal(ExpressionT expr, ParseInfo* info) {}
+  V8_INLINE void appendDeclaration(ExpressionT expr, ParseInfo* info) {}
+  V8_INLINE void PrintExpression(ParseInfo* info, ExpressionT expr) {}
+  V8_INLINE void appendDeclarationParam(DeclarationScope* scope, ExpressionT param, ExpressionT initializer, ParseInfo* info) {}
+  V8_INLINE void SetFunctionID(FunctionLiteralT func, int id) {}
+  V8_INLINE void set_function_id_for_scope(FunctionLiteralT it) {}
+  V8_INLINE void SetTempVarForExpression(ExpressionT expr, bool flag=false) {}
+  V8_INLINE void SetTempVarForStatement(StatementT expr, bool flag=false) {}
+  V8_INLINE void DeclareWindowAsUnresolved(FunctionLiteralT function_literal) {}
+  V8_INLINE void SetTempVarForObjectLiteralProperty(ObjectLiteralPropertyT prop) {}
+
  private:
   // These types form an algebra over syntactic categories that is just
   // rich enough to let us recognize and propagate the constructs that
@@ -1068,7 +1080,7 @@ class PreParser : public ParserBase<PreParser> {
   }
 
   Expression ParseFunctionLiteral(
-      Identifier name, Scanner::Location function_name_location,
+      ParseInfo* info, Identifier name, Scanner::Location function_name_location,
       FunctionNameValidity function_name_validity, FunctionKind kind,
       int function_token_pos, FunctionLiteral::FunctionType function_type,
       LanguageMode language_mode,
@@ -1175,12 +1187,12 @@ class PreParser : public ParserBase<PreParser> {
   }
 
   V8_INLINE void ParseAndRewriteGeneratorFunctionBody(
-      int pos, FunctionKind kind, PreParserStatementList body, bool* ok) {
-    ParseStatementList(body, Token::RBRACE, ok);
+      ParseInfo* info, int pos, FunctionKind kind, PreParserStatementList body, bool* ok) {
+    ParseStatementList(info, body, Token::RBRACE, ok);
   }
   V8_INLINE void ParseAndRewriteAsyncGeneratorFunctionBody(
-      int pos, FunctionKind kind, PreParserStatementList body, bool* ok) {
-    ParseStatementList(body, Token::RBRACE, ok);
+      ParseInfo* info, int pos, FunctionKind kind, PreParserStatementList body, bool* ok) {
+    ParseStatementList(info, body, Token::RBRACE, ok);
   }
   V8_INLINE void DeclareFunctionNameVar(
       const AstRawString* function_name,
@@ -1222,8 +1234,10 @@ class PreParser : public ParserBase<PreParser> {
   DeclareFunction(const PreParserIdentifier& variable_name,
                   const PreParserExpression& function, VariableMode mode,
                   int pos, bool is_sloppy_block_function,
-                  ZonePtrList<const AstRawString>* names, bool* ok) {
+                  ZonePtrList<const AstRawString>* names, bool* ok, ParseInfo* info=nullptr) {
+
     DCHECK_NULL(names);
+
     if (variable_name.string_ != nullptr) {
       DCHECK(track_unresolved_variables_);
       scope()->DeclareVariableName(variable_name.string_, mode);
@@ -1398,6 +1412,12 @@ class PreParser : public ParserBase<PreParser> {
   // operations interleaved with the recursive descent.
   V8_INLINE static void PushLiteralName(const PreParserIdentifier& id) {}
   V8_INLINE static void PushVariableName(const PreParserIdentifier& id) {}
+  V8_INLINE void LogVariableInfo(ExpressionT var_name, ExpressionT value, ParseInfo* info, int beg_pos, int peek_pos, bool force_log) {}
+  //V8_INLINE void LogFunctionInfo(FunctionLiteral* function) {}
+  V8_INLINE std::string ConvertIdentifierToString(const IdentifierT identifier){return std::string("-1");}
+  V8_INLINE void PushNewedFunction(ExpressionT var_name, ExpressionT value, ParseInfo* info) {}
+  V8_INLINE ExpressionT construct_asg_for_obj_literal(ExpressionT expr, ExpressionT rhs, bool* flag) {*flag = false; return PreParserExpression();} 
+
   V8_INLINE void PushPropertyName(const PreParserExpression& expression) {}
   V8_INLINE void PushEnclosingName(const PreParserIdentifier& name) {}
   V8_INLINE static void AddFunctionForNameInference(
@@ -1405,7 +1425,7 @@ class PreParser : public ParserBase<PreParser> {
   V8_INLINE static void InferFunctionName() {}
 
   V8_INLINE static void CheckAssigningFunctionLiteralToProperty(
-      const PreParserExpression& left, const PreParserExpression& right) {}
+      ParseInfo* info, const PreParserExpression& left, const PreParserExpression& right, bool is_this) {}
 
   V8_INLINE void MarkExpressionAsAssigned(
       const PreParserExpression& expression) {
@@ -1663,7 +1683,7 @@ class PreParser : public ParserBase<PreParser> {
       const PreParserIdentifier& name, int start_position,
       InferName infer = InferName::kYes);
 
-  V8_INLINE PreParserExpression ExpressionFromString(int pos) {
+  V8_INLINE PreParserExpression ExpressionFromString(int pos, bool quote=false) {
     if (scanner()->IsUseStrict()) {
       return PreParserExpression::UseStrictStringLiteral();
     }
@@ -1772,7 +1792,7 @@ class PreParser : public ParserBase<PreParser> {
       const PreParserExpression& property, const PreParserIdentifier& name,
       const AstRawString* prefix = nullptr) {}
   V8_INLINE void SetFunctionNameFromIdentifierRef(
-      const PreParserExpression& value, const PreParserExpression& identifier) {
+      ParseInfo* info, const PreParserExpression& value, const PreParserExpression& identifier) {
   }
 
   V8_INLINE ZoneList<typename ExpressionClassifier::Error>*
diff --git a/src/parsing/rewriter.cc b/src/parsing/rewriter.cc
index 151244f..33a1132 100644
--- a/src/parsing/rewriter.cc
+++ b/src/parsing/rewriter.cc
@@ -54,8 +54,28 @@ class Processor final : public AstVisitor<Processor> {
   Expression* SetResult(Expression* value) {
     result_assigned_ = true;
     VariableProxy* result_proxy = factory()->NewVariableProxy(result_);
-    return factory()->NewAssignment(Token::ASSIGN, result_proxy, value,
+    Assignment* assignment = factory()->NewAssignment(Token::ASSIGN, result_proxy, value,
                                     kNoSourcePosition);
+    Scope* scope = closure_scope();
+    while(scope->outer_scope())
+      scope = scope->outer_scope();
+    gmutex.lock();
+    assign_id++;
+    std::string tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+    gmutex.unlock();
+    const AstRawString* one_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+    scope->NewUnresolved(factory(), one_tmp_token);
+    assignment->set_allocated_temp_var(tmp);
+
+    gmutex.lock();
+    assign_id++;
+    tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+    gmutex.unlock();
+    const AstRawString* tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+    scope->NewUnresolved(factory(), tmp_token);
+    assignment->set_allocated_temp_var_for_asg(tmp);
+
+    return assignment;
   }
 
   // Inserts '.result = undefined' in front of the given statement.
@@ -256,8 +276,49 @@ void Processor::VisitTryFinallyStatement(TryFinallyStatement* node) {
     Expression* result_proxy = factory()->NewVariableProxy(result_);
     Expression* save = factory()->NewAssignment(
         Token::ASSIGN, backup_proxy, result_proxy, kNoSourcePosition);
+
+    Scope* scope = closure_scope();
+    while(scope->outer_scope())
+      scope = scope->outer_scope();
+    gmutex.lock();
+    assign_id++;
+    std::string tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+    gmutex.unlock();
+    const AstRawString* one_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+    scope->NewUnresolved(factory(), one_tmp_token);
+    save->set_allocated_temp_var(tmp);
+
+    gmutex.lock();
+    assign_id++;
+    tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+    gmutex.unlock();
+    const AstRawString* tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+    scope->NewUnresolved(factory(), tmp_token);
+    save->set_allocated_temp_var_for_asg(tmp);
+
+
+
+
+
     Expression* restore = factory()->NewAssignment(
         Token::ASSIGN, result_proxy, backup_proxy, kNoSourcePosition);
+    gmutex.lock();
+    assign_id++;
+    tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+    gmutex.unlock();
+    const AstRawString* two_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+    scope->NewUnresolved(factory(), two_tmp_token);
+    restore->set_allocated_temp_var(tmp);
+
+    gmutex.lock();
+    assign_id++;
+    tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+    gmutex.unlock();
+    const AstRawString* three_tmp_token = factory()->ast_value_factory()->GetOneByteString(tmp.c_str());
+    scope->NewUnresolved(factory(), three_tmp_token);
+    restore->set_allocated_temp_var_for_asg(tmp);
+
+
     node->finally_block()->statements()->InsertAt(
         0, factory()->NewExpressionStatement(save, kNoSourcePosition), zone());
     node->finally_block()->statements()->Add(
@@ -396,6 +457,27 @@ bool Rewriter::Rewrite(ParseInfo* info) {
           processor.factory()->NewVariableProxy(result, pos);
       Statement* result_statement =
           processor.factory()->NewReturnStatement(result_value, pos);
+
+      Scope* closure_scope = scope;
+      while(closure_scope->outer_scope())
+        closure_scope = closure_scope->outer_scope();
+      gmutex.lock();
+      assign_id++;
+      std::string tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+      gmutex.unlock();
+      const AstRawString* one_tmp_token = info->ast_value_factory()->GetOneByteString(tmp.c_str());
+      AstNodeFactory ast_node_factory(info->ast_value_factory(), info->zone());
+      closure_scope->NewUnresolved(&ast_node_factory, one_tmp_token);
+      result_statement->set_allocated_temp_var(tmp);
+
+      gmutex.lock();
+      assign_id++;
+      tmp = "Yx$Q7r$zJUnQUy__" + std::to_string(assign_id);
+      gmutex.unlock();
+      const AstRawString* two_tmp_token = info->ast_value_factory()->GetOneByteString(tmp.c_str());
+      closure_scope->NewUnresolved(&ast_node_factory, two_tmp_token);
+      result_statement->set_allocated_temp_var_for_asg(tmp);
+
       body->Add(result_statement, info->zone());
     }
 
diff --git a/src/unoptimized-compilation-info.cc b/src/unoptimized-compilation-info.cc
index b58fe97..29fccfb 100644
--- a/src/unoptimized-compilation-info.cc
+++ b/src/unoptimized-compilation-info.cc
@@ -29,6 +29,7 @@ UnoptimizedCompilationInfo::UnoptimizedCompilationInfo(Zone* zone,
   // OptimizedCompilationInfo.
   DCHECK_NOT_NULL(literal);
   literal_ = literal;
+  parse_info_ = parse_info;
   source_range_map_ = parse_info->source_range_map();
 
   if (parse_info->is_eval()) MarkAsEval();
diff --git a/src/unoptimized-compilation-info.h b/src/unoptimized-compilation-info.h
index 5329581..7fd1a34 100644
--- a/src/unoptimized-compilation-info.h
+++ b/src/unoptimized-compilation-info.h
@@ -55,6 +55,9 @@ class V8_EXPORT_PRIVATE UnoptimizedCompilationInfo final {
 
   DeclarationScope* scope() const;
 
+  ParseInfo* parse_info() const {return parse_info_;}
+
+
   int num_parameters() const;
   int num_parameters_including_this() const;
 
@@ -128,6 +131,9 @@ class V8_EXPORT_PRIVATE UnoptimizedCompilationInfo final {
 
   // Holds the feedback vector spec generated during compilation
   FeedbackVectorSpec feedback_vector_spec_;
+
+  // Holds the parse info, this is for retrieving the bounded ast value factory later.
+  ParseInfo* parse_info_;
 };
 
 }  // namespace internal
